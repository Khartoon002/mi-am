(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["object" == typeof document ? document.currentScript : void 0, {
    28662: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            QueryClientContext: () => s,
            QueryClientProvider: () => o,
            useQueryClient: () => a
        });
        var n = e.i(38653)
          , i = e.i(31636)
          , s = (0,
        n.createContext)(void 0)
          , a = e => {
            let t = (0,
            n.useContext)(s);
            if (e)
                return e;
            if (!t)
                throw Error("No QueryClient set, use QueryClientProvider to set one");
            return t
        }
          , o = ({client: e, children: t}) => ((0,
        n.useEffect)( () => (e.mount(),
        () => {
            e.unmount()
        }
        ), [e]),
        (0,
        i.jsx)(s.Provider, {
            value: e,
            children: t
        }))
    }
    ,
    68423: function(e) {
        var {g: t, __dirname: r, m: n, e: i} = e;
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        });
        var s = {
            assign: function() {
                return h
            },
            searchParamsToUrlQuery: function() {
                return o
            },
            urlQueryToSearchParams: function() {
                return u
            }
        };
        for (var a in s)
            Object.defineProperty(i, a, {
                enumerable: !0,
                get: s[a]
            });
        function o(e) {
            let t = {};
            for (let[r,n] of e.entries()) {
                let e = t[r];
                void 0 === e ? t[r] = n : Array.isArray(e) ? e.push(n) : t[r] = [e, n]
            }
            return t
        }
        function l(e) {
            return "string" == typeof e ? e : ("number" != typeof e || isNaN(e)) && "boolean" != typeof e ? "" : String(e)
        }
        function u(e) {
            let t = new URLSearchParams;
            for (let[r,n] of Object.entries(e))
                if (Array.isArray(n))
                    for (let e of n)
                        t.append(r, l(e));
                else
                    t.set(r, l(n));
            return t
        }
        function h(e) {
            for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            for (let t of r) {
                for (let r of t.keys())
                    e.delete(r);
                for (let[r,n] of t.entries())
                    e.append(r, n)
            }
            return e
        }
    },
    30609: function(e) {
        var {g: t, __dirname: r, m: n, e: i} = e;
        {
            e.i(22271);
            "use strict";
            Object.defineProperty(i, "__esModule", {
                value: !0
            });
            var s = {
                formatUrl: function() {
                    return o
                },
                formatWithValidation: function() {
                    return l
                },
                urlObjectKeys: function() {
                    return n
                }
            };
            for (var a in s)
                Object.defineProperty(i, a, {
                    enumerable: !0,
                    get: s[a]
                });
            let t = e.r(81369)._(e.r(68423))
              , r = /https?|ftp|gopher|file/;
            function o(e) {
                let {auth: n, hostname: i} = e
                  , s = e.protocol || ""
                  , a = e.pathname || ""
                  , o = e.hash || ""
                  , l = e.query || ""
                  , u = !1;
                n = n ? encodeURIComponent(n).replace(/%3A/i, ":") + "@" : "",
                e.host ? u = n + e.host : i && (u = n + (~i.indexOf(":") ? "[" + i + "]" : i),
                e.port && (u += ":" + e.port)),
                l && "object" == typeof l && (l = String(t.urlQueryToSearchParams(l)));
                let h = e.search || l && "?" + l || "";
                return s && !s.endsWith(":") && (s += ":"),
                e.slashes || (!s || r.test(s)) && !1 !== u ? (u = "//" + (u || ""),
                a && "/" !== a[0] && (a = "/" + a)) : u || (u = ""),
                o && "#" !== o[0] && (o = "#" + o),
                h && "?" !== h[0] && (h = "?" + h),
                "" + s + u + (a = a.replace(/[?#]/g, encodeURIComponent)) + (h = h.replace("#", "%23")) + o
            }
            let n = ["auth", "hash", "host", "hostname", "href", "path", "pathname", "port", "protocol", "query", "search", "slashes"];
            function l(e) {
                return o(e)
            }
        }
    },
    95863: function(e) {
        var {g: t, __dirname: r, m: n, e: i} = e;
        {
            e.i(22271);
            "use strict";
            Object.defineProperty(i, "__esModule", {
                value: !0
            });
            var s = {
                DecodeError: function() {
                    return y
                },
                MiddlewareNotFoundError: function() {
                    return E
                },
                MissingStaticPage: function() {
                    return b
                },
                NormalizeError: function() {
                    return v
                },
                PageNotFoundError: function() {
                    return w
                },
                SP: function() {
                    return g
                },
                ST: function() {
                    return m
                },
                WEB_VITALS: function() {
                    return t
                },
                execOnce: function() {
                    return o
                },
                getDisplayName: function() {
                    return h
                },
                getLocationOrigin: function() {
                    return l
                },
                getURL: function() {
                    return u
                },
                isAbsoluteUrl: function() {
                    return n
                },
                isResSent: function() {
                    return c
                },
                loadGetInitialProps: function() {
                    return f
                },
                normalizeRepeatedSlashes: function() {
                    return d
                },
                stringifyError: function() {
                    return p
                }
            };
            for (var a in s)
                Object.defineProperty(i, a, {
                    enumerable: !0,
                    get: s[a]
                });
            let t = ["CLS", "FCP", "FID", "INP", "LCP", "TTFB"];
            function o(e) {
                let t, r = !1;
                return function() {
                    for (var n = arguments.length, i = Array(n), s = 0; s < n; s++)
                        i[s] = arguments[s];
                    return r || (r = !0,
                    t = e(...i)),
                    t
                }
            }
            let r = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/
              , n = e => r.test(e);
            function l() {
                let {protocol: e, hostname: t, port: r} = window.location;
                return e + "//" + t + (r ? ":" + r : "")
            }
            function u() {
                let {href: e} = window.location
                  , t = l();
                return e.substring(t.length)
            }
            function h(e) {
                return "string" == typeof e ? e : e.displayName || e.name || "Unknown"
            }
            function c(e) {
                return e.finished || e.headersSent
            }
            function d(e) {
                let t = e.split("?");
                return t[0].replace(/\\/g, "/").replace(/\/\/+/g, "/") + (t[1] ? "?" + t.slice(1).join("?") : "")
            }
            async function f(e, t) {
                let r = t.res || t.ctx && t.ctx.res;
                if (!e.getInitialProps)
                    return t.ctx && t.Component ? {
                        pageProps: await f(t.Component, t.ctx)
                    } : {};
                let n = await e.getInitialProps(t);
                if (r && c(r))
                    return n;
                if (!n)
                    throw Object.defineProperty(Error('"' + h(e) + '.getInitialProps()" should resolve to an object. But found "' + n + '" instead.'), "__NEXT_ERROR_CODE", {
                        value: "E394",
                        enumerable: !1,
                        configurable: !0
                    });
                return n
            }
            let g = "undefined" != typeof performance
              , m = g && ["mark", "measure", "getEntriesByName"].every(e => "function" == typeof performance[e]);
            class y extends Error {
            }
            class v extends Error {
            }
            class w extends Error {
                constructor(e) {
                    super(),
                    this.code = "ENOENT",
                    this.name = "PageNotFoundError",
                    this.message = "Cannot find module for page: " + e
                }
            }
            class b extends Error {
                constructor(e, t) {
                    super(),
                    this.message = "Failed to load static file for page: " + e + " " + t
                }
            }
            class E extends Error {
                constructor() {
                    super(),
                    this.code = "ENOENT",
                    this.message = "Cannot find the middleware module"
                }
            }
            function p(e) {
                return JSON.stringify({
                    message: e.message,
                    stack: e.stack
                })
            }
        }
    },
    52100: function(e) {
        var {g: t, __dirname: r, m: n, e: i} = e;
        {
            "use strict";
            Object.defineProperty(i, "__esModule", {
                value: !0
            }),
            Object.defineProperty(i, "isLocalURL", {
                enumerable: !0,
                get: function() {
                    return s
                }
            });
            let t = e.r(95863)
              , r = e.r(90225);
            function s(e) {
                if (!(0,
                t.isAbsoluteUrl)(e))
                    return !0;
                try {
                    let n = (0,
                    t.getLocationOrigin)()
                      , i = new URL(e,n);
                    return i.origin === n && (0,
                    r.hasBasePath)(i.pathname)
                } catch (e) {
                    return !1
                }
            }
        }
    },
    90972: function(e) {
        var {g: t, __dirname: r, m: n, e: i} = e;
        {
            "use strict";
            e.i(22271),
            Object.defineProperty(i, "__esModule", {
                value: !0
            }),
            Object.defineProperty(i, "errorOnce", {
                enumerable: !0,
                get: function() {
                    return t
                }
            });
            let t = e => {}
        }
    },
    86240: function(e) {
        var {g: t, __dirname: r, m: n, e: i} = e;
        {
            "use strict";
            e.i(22271),
            Object.defineProperty(i, "__esModule", {
                value: !0
            });
            var s = {
                default: function() {
                    return l
                },
                useLinkStatus: function() {
                    return b
                }
            };
            for (var a in s)
                Object.defineProperty(i, a, {
                    enumerable: !0,
                    get: s[a]
                });
            let t = e.r(81369)
              , r = e.r(31636)
              , u = t._(e.r(38653))
              , h = e.r(30609)
              , c = e.r(84948)
              , d = e.r(59708)
              , f = e.r(48757)
              , p = e.r(95863)
              , g = e.r(44910);
            e.r(12597);
            let m = e.r(91981)
              , y = e.r(52100)
              , v = e.r(1541);
            function o(e) {
                return "string" == typeof e ? e : (0,
                h.formatUrl)(e)
            }
            function l(e) {
                let t, n, i, [s,a] = (0,
                u.useOptimistic)(m.IDLE_LINK_STATUS), l = (0,
                u.useRef)(null), {href: h, as: b, children: E, prefetch: I=null, passHref: _, replace: T, shallow: S, scroll: C, onClick: x, onMouseEnter: A, onTouchStart: D, legacyBehavior: k=!1, onNavigate: N, ref: O, unstable_dynamicOnHover: R, ...M} = e;
                t = E,
                k && ("string" == typeof t || "number" == typeof t) && (t = (0,
                r.jsx)("a", {
                    children: t
                }));
                let P = u.default.useContext(c.AppRouterContext)
                  , L = !1 !== I
                  , F = null === I ? d.PrefetchKind.AUTO : d.PrefetchKind.FULL
                  , {href: B, as: V} = u.default.useMemo( () => {
                    let e = o(h);
                    return {
                        href: e,
                        as: b ? o(b) : e
                    }
                }
                , [h, b]);
                k && (n = u.default.Children.only(t));
                let U = k ? n && "object" == typeof n && n.ref : O
                  , q = u.default.useCallback(e => (null !== P && (l.current = (0,
                m.mountLinkInstance)(e, B, P, F, L, a)),
                () => {
                    l.current && ((0,
                    m.unmountLinkForCurrentNavigation)(l.current),
                    l.current = null),
                    (0,
                    m.unmountPrefetchableInstance)(e)
                }
                ), [L, B, P, F, a])
                  , j = {
                    ref: (0,
                    f.useMergedRef)(q, U),
                    onClick(e) {
                        k || "function" != typeof x || x(e),
                        k && n.props && "function" == typeof n.props.onClick && n.props.onClick(e),
                        P && (e.defaultPrevented || function(e, t, r, n, i, s, a) {
                            let {nodeName: o} = e.currentTarget;
                            if (!("A" === o.toUpperCase() && function(e) {
                                let t = e.currentTarget.getAttribute("target");
                                return t && "_self" !== t || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey || e.nativeEvent && 2 === e.nativeEvent.which
                            }(e) || e.currentTarget.hasAttribute("download"))) {
                                if (!(0,
                                y.isLocalURL)(t)) {
                                    i && (e.preventDefault(),
                                    location.replace(t));
                                    return
                                }
                                e.preventDefault(),
                                u.default.startTransition( () => {
                                    if (a) {
                                        let e = !1;
                                        if (a({
                                            preventDefault: () => {
                                                e = !0
                                            }
                                        }),
                                        e)
                                            return
                                    }
                                    (0,
                                    v.dispatchNavigateAction)(r || t, i ? "replace" : "push", null == s || s, n.current)
                                }
                                )
                            }
                        }(e, B, V, l, T, C, N))
                    },
                    onMouseEnter(e) {
                        k || "function" != typeof A || A(e),
                        k && n.props && "function" == typeof n.props.onMouseEnter && n.props.onMouseEnter(e),
                        P && L && (0,
                        m.onNavigationIntent)(e.currentTarget, !0 === R)
                    },
                    onTouchStart: function(e) {
                        k || "function" != typeof D || D(e),
                        k && n.props && "function" == typeof n.props.onTouchStart && n.props.onTouchStart(e),
                        P && L && (0,
                        m.onNavigationIntent)(e.currentTarget, !0 === R)
                    }
                };
                return (0,
                p.isAbsoluteUrl)(V) ? j.href = V : k && !_ && ("a" !== n.type || "href"in n.props) || (j.href = (0,
                g.addBasePath)(V)),
                i = k ? u.default.cloneElement(n, j) : (0,
                r.jsx)("a", {
                    ...M,
                    ...j,
                    children: t
                }),
                (0,
                r.jsx)(w.Provider, {
                    value: s,
                    children: i
                })
            }
            e.r(90972);
            let w = (0,
            u.createContext)(m.IDLE_LINK_STATUS)
              , b = () => (0,
            u.useContext)(w);
            ("function" == typeof i.default || "object" == typeof i.default && null !== i.default) && void 0 === i.default.__esModule && (Object.defineProperty(i.default, "__esModule", {
                value: !0
            }),
            Object.assign(i.default, i),
            n.exports = i.default)
        }
    },
    44282: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        function n() {}
        e.s({
            noop: () => n
        })
    }
    ,
    55583: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            createSyncStoragePersister: () => i
        });
        var n = e.i(44282);
        function i({storage: e, key: t="REACT_QUERY_OFFLINE_CACHE", throttleTime: r=1e3, serialize: i=JSON.stringify, deserialize: s=JSON.parse, retry: a}) {
            if (e) {
                let n = r => {
                    try {
                        e.setItem(t, i(r));
                        return
                    } catch (e) {
                        return e
                    }
                }
                ;
                return {
                    persistClient: function(e, t=100) {
                        let r, n = null;
                        return function(...i) {
                            r = i,
                            null === n && (n = setTimeout( () => {
                                e(...r),
                                n = null
                            }
                            , t))
                        }
                    }(e => {
                        let t = e
                          , r = n(t)
                          , i = 0;
                        for (; r && t; )
                            i++,
                            (t = a?.({
                                persistedClient: t,
                                error: r,
                                errorCount: i
                            })) && (r = n(t))
                    }
                    , r),
                    restoreClient: () => {
                        let r = e.getItem(t);
                        if (r)
                            return s(r)
                    }
                    ,
                    removeClient: () => {
                        e.removeItem(t)
                    }
                }
            }
            return {
                persistClient: n.noop,
                restoreClient: n.noop,
                removeClient: n.noop
            }
        }
    }
    ,
    45897: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            addToEnd: () => _,
            addToStart: () => T,
            ensureQueryFn: () => C,
            functionalUpdate: () => s,
            hashKey: () => f,
            hashQueryKeyByOptions: () => d,
            isPlainArray: () => y,
            isPlainObject: () => v,
            isServer: () => n,
            isValidTimeout: () => a,
            keepPreviousData: () => I,
            matchMutation: () => c,
            matchQuery: () => h,
            noop: () => i,
            partialMatchKey: () => p,
            replaceData: () => E,
            replaceEqualDeep: () => g,
            resolveEnabled: () => u,
            resolveStaleTime: () => l,
            shallowEqualObjects: () => m,
            shouldThrowError: () => x,
            skipToken: () => S,
            sleep: () => b,
            timeUntilStale: () => o
        }),
        e.i(22271);
        var n = "undefined" == typeof window || "Deno"in globalThis;
        function i() {}
        function s(e, t) {
            return "function" == typeof e ? e(t) : e
        }
        function a(e) {
            return "number" == typeof e && e >= 0 && e !== 1 / 0
        }
        function o(e, t) {
            return Math.max(e + (t || 0) - Date.now(), 0)
        }
        function l(e, t) {
            return "function" == typeof e ? e(t) : e
        }
        function u(e, t) {
            return "function" == typeof e ? e(t) : e
        }
        function h(e, t) {
            let {type: r="all", exact: n, fetchStatus: i, predicate: s, queryKey: a, stale: o} = e;
            if (a) {
                if (n) {
                    if (t.queryHash !== d(a, t.options))
                        return !1
                } else if (!p(t.queryKey, a))
                    return !1
            }
            if ("all" !== r) {
                let e = t.isActive();
                if ("active" === r && !e || "inactive" === r && e)
                    return !1
            }
            return ("boolean" != typeof o || t.isStale() === o) && (!i || i === t.state.fetchStatus) && (!s || !!s(t))
        }
        function c(e, t) {
            let {exact: r, status: n, predicate: i, mutationKey: s} = e;
            if (s) {
                if (!t.options.mutationKey)
                    return !1;
                if (r) {
                    if (f(t.options.mutationKey) !== f(s))
                        return !1
                } else if (!p(t.options.mutationKey, s))
                    return !1
            }
            return (!n || t.state.status === n) && (!i || !!i(t))
        }
        function d(e, t) {
            return (t?.queryKeyHashFn || f)(e)
        }
        function f(e) {
            return JSON.stringify(e, (e, t) => v(t) ? Object.keys(t).sort().reduce( (e, r) => (e[r] = t[r],
            e), {}) : t)
        }
        function p(e, t) {
            return e === t || typeof e == typeof t && !!e && !!t && "object" == typeof e && "object" == typeof t && Object.keys(t).every(r => p(e[r], t[r]))
        }
        function g(e, t) {
            if (e === t)
                return e;
            let r = y(e) && y(t);
            if (r || v(e) && v(t)) {
                let n = r ? e : Object.keys(e)
                  , i = n.length
                  , s = r ? t : Object.keys(t)
                  , a = s.length
                  , o = r ? [] : {}
                  , l = 0;
                for (let i = 0; i < a; i++) {
                    let a = r ? i : s[i];
                    (!r && n.includes(a) || r) && void 0 === e[a] && void 0 === t[a] ? (o[a] = void 0,
                    l++) : (o[a] = g(e[a], t[a]),
                    o[a] === e[a] && void 0 !== e[a] && l++)
                }
                return i === a && l === i ? e : o
            }
            return t
        }
        function m(e, t) {
            if (!t || Object.keys(e).length !== Object.keys(t).length)
                return !1;
            for (let r in e)
                if (e[r] !== t[r])
                    return !1;
            return !0
        }
        function y(e) {
            return Array.isArray(e) && e.length === Object.keys(e).length
        }
        function v(e) {
            if (!w(e))
                return !1;
            let t = e.constructor;
            if (void 0 === t)
                return !0;
            let r = t.prototype;
            return !!w(r) && !!r.hasOwnProperty("isPrototypeOf") && Object.getPrototypeOf(e) === Object.prototype
        }
        function w(e) {
            return "[object Object]" === Object.prototype.toString.call(e)
        }
        function b(e) {
            return new Promise(t => {
                setTimeout(t, e)
            }
            )
        }
        function E(e, t, r) {
            return "function" == typeof r.structuralSharing ? r.structuralSharing(e, t) : !1 !== r.structuralSharing ? g(e, t) : t
        }
        function I(e) {
            return e
        }
        function _(e, t, r=0) {
            let n = [...e, t];
            return r && n.length > r ? n.slice(1) : n
        }
        function T(e, t, r=0) {
            let n = [t, ...e];
            return r && n.length > r ? n.slice(0, -1) : n
        }
        var S = Symbol();
        function C(e, t) {
            return !e.queryFn && t?.initialPromise ? () => t.initialPromise : e.queryFn && e.queryFn !== S ? e.queryFn : () => Promise.reject(Error(`Missing queryFn: '${e.queryHash}'`))
        }
        function x(e, t) {
            return "function" == typeof e ? e(...t) : !!e
        }
    }
    ,
    80431: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            createNotifyManager: () => i,
            defaultScheduler: () => n,
            notifyManager: () => s
        });
        var n = e => setTimeout(e, 0);
        function i() {
            let e = []
              , t = 0
              , r = e => {
                e()
            }
              , i = e => {
                e()
            }
              , s = n
              , a = n => {
                t ? e.push(n) : s( () => {
                    r(n)
                }
                )
            }
              , o = () => {
                let t = e;
                e = [],
                t.length && s( () => {
                    i( () => {
                        t.forEach(e => {
                            r(e)
                        }
                        )
                    }
                    )
                }
                )
            }
            ;
            return {
                batch: e => {
                    let r;
                    t++;
                    try {
                        r = e()
                    } finally {
                        --t || o()
                    }
                    return r
                }
                ,
                batchCalls: e => (...t) => {
                    a( () => {
                        e(...t)
                    }
                    )
                }
                ,
                schedule: a,
                setNotifyFunction: e => {
                    r = e
                }
                ,
                setBatchNotifyFunction: e => {
                    i = e
                }
                ,
                setScheduler: e => {
                    s = e
                }
            }
        }
        var s = i()
    }
    ,
    41775: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            Subscribable: () => n
        });
        var n = class {
            constructor() {
                this.listeners = new Set,
                this.subscribe = this.subscribe.bind(this)
            }
            subscribe(e) {
                return this.listeners.add(e),
                this.onSubscribe(),
                () => {
                    this.listeners.delete(e),
                    this.onUnsubscribe()
                }
            }
            hasListeners() {
                return this.listeners.size > 0
            }
            onSubscribe() {}
            onUnsubscribe() {}
        }
    }
    ,
    47011: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            FocusManager: () => s,
            focusManager: () => a
        });
        var n = e.i(41775)
          , i = e.i(45897)
          , s = class extends n.Subscribable {
            #e;
            #t;
            #r;
            constructor() {
                super(),
                this.#r = e => {
                    if (!i.isServer && window.addEventListener) {
                        let t = () => e();
                        return window.addEventListener("visibilitychange", t, !1),
                        () => {
                            window.removeEventListener("visibilitychange", t)
                        }
                    }
                }
            }
            onSubscribe() {
                this.#t || this.setEventListener(this.#r)
            }
            onUnsubscribe() {
                this.hasListeners() || (this.#t?.(),
                this.#t = void 0)
            }
            setEventListener(e) {
                this.#r = e,
                this.#t?.(),
                this.#t = e(e => {
                    "boolean" == typeof e ? this.setFocused(e) : this.onFocus()
                }
                )
            }
            setFocused(e) {
                this.#e !== e && (this.#e = e,
                this.onFocus())
            }
            onFocus() {
                let e = this.isFocused();
                this.listeners.forEach(t => {
                    t(e)
                }
                )
            }
            isFocused() {
                return "boolean" == typeof this.#e ? this.#e : globalThis.document?.visibilityState !== "hidden"
            }
        }
          , a = new s
    }
    ,
    78e3: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            OnlineManager: () => s,
            onlineManager: () => a
        });
        var n = e.i(41775)
          , i = e.i(45897)
          , s = class extends n.Subscribable {
            #n = !0;
            #t;
            #r;
            constructor() {
                super(),
                this.#r = e => {
                    if (!i.isServer && window.addEventListener) {
                        let t = () => e(!0)
                          , r = () => e(!1);
                        return window.addEventListener("online", t, !1),
                        window.addEventListener("offline", r, !1),
                        () => {
                            window.removeEventListener("online", t),
                            window.removeEventListener("offline", r)
                        }
                    }
                }
            }
            onSubscribe() {
                this.#t || this.setEventListener(this.#r)
            }
            onUnsubscribe() {
                this.hasListeners() || (this.#t?.(),
                this.#t = void 0)
            }
            setEventListener(e) {
                this.#r = e,
                this.#t?.(),
                this.#t = e(this.setOnline.bind(this))
            }
            setOnline(e) {
                this.#n !== e && (this.#n = e,
                this.listeners.forEach(t => {
                    t(e)
                }
                ))
            }
            isOnline() {
                return this.#n
            }
        }
          , a = new s
    }
    ,
    9291: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        function n() {
            let e, t, r = new Promise( (r, n) => {
                e = r,
                t = n
            }
            );
            function n(e) {
                Object.assign(r, e),
                delete r.resolve,
                delete r.reject
            }
            return r.status = "pending",
            r.catch( () => {}
            ),
            r.resolve = t => {
                n({
                    status: "fulfilled",
                    value: t
                }),
                e(t)
            }
            ,
            r.reject = e => {
                n({
                    status: "rejected",
                    reason: e
                }),
                t(e)
            }
            ,
            r
        }
        e.s({
            pendingThenable: () => n
        })
    }
    ,
    71529: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            CancelledError: () => u,
            canFetch: () => l,
            createRetryer: () => c,
            isCancelledError: () => h
        });
        var n = e.i(47011)
          , i = e.i(78e3)
          , s = e.i(9291)
          , a = e.i(45897);
        function o(e) {
            return Math.min(1e3 * 2 ** e, 3e4)
        }
        function l(e) {
            return (e ?? "online") !== "online" || i.onlineManager.isOnline()
        }
        var u = class extends Error {
            constructor(e) {
                super("CancelledError"),
                this.revert = e?.revert,
                this.silent = e?.silent
            }
        }
        ;
        function h(e) {
            return e instanceof u
        }
        function c(e) {
            let t, r = !1, h = 0, c = !1, d = (0,
            s.pendingThenable)(), f = () => n.focusManager.isFocused() && ("always" === e.networkMode || i.onlineManager.isOnline()) && e.canRun(), p = () => l(e.networkMode) && e.canRun(), g = r => {
                c || (c = !0,
                e.onSuccess?.(r),
                t?.(),
                d.resolve(r))
            }
            , m = r => {
                c || (c = !0,
                e.onError?.(r),
                t?.(),
                d.reject(r))
            }
            , y = () => new Promise(r => {
                t = e => {
                    (c || f()) && r(e)
                }
                ,
                e.onPause?.()
            }
            ).then( () => {
                t = void 0,
                c || e.onContinue?.()
            }
            ), v = () => {
                let t;
                if (c)
                    return;
                let n = 0 === h ? e.initialPromise : void 0;
                try {
                    t = n ?? e.fn()
                } catch (e) {
                    t = Promise.reject(e)
                }
                Promise.resolve(t).then(g).catch(t => {
                    if (c)
                        return;
                    let n = e.retry ?? 3 * !a.isServer
                      , i = e.retryDelay ?? o
                      , s = "function" == typeof i ? i(h, t) : i
                      , l = !0 === n || "number" == typeof n && h < n || "function" == typeof n && n(h, t);
                    if (r || !l)
                        return void m(t);
                    h++,
                    e.onFail?.(h, t),
                    (0,
                    a.sleep)(s).then( () => f() ? void 0 : y()).then( () => {
                        r ? m(t) : v()
                    }
                    )
                }
                )
            }
            ;
            return {
                promise: d,
                cancel: t => {
                    c || (m(new u(t)),
                    e.abort?.())
                }
                ,
                continue: () => (t?.(),
                d),
                cancelRetry: () => {
                    r = !0
                }
                ,
                continueRetry: () => {
                    r = !1
                }
                ,
                canStart: p,
                start: () => (p() ? v() : y().then(v),
                d)
            }
        }
    }
    ,
    53259: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            Removable: () => i
        });
        var n = e.i(45897)
          , i = class {
            #i;
            destroy() {
                this.clearGcTimeout()
            }
            scheduleGc() {
                this.clearGcTimeout(),
                (0,
                n.isValidTimeout)(this.gcTime) && (this.#i = setTimeout( () => {
                    this.optionalRemove()
                }
                , this.gcTime))
            }
            updateGcTime(e) {
                this.gcTime = Math.max(this.gcTime || 0, e ?? (n.isServer ? 1 / 0 : 3e5))
            }
            clearGcTimeout() {
                this.#i && (clearTimeout(this.#i),
                this.#i = void 0)
            }
        }
    }
    ,
    82907: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            Query: () => o,
            fetchState: () => l
        }),
        e.i(22271);
        var n = e.i(45897)
          , i = e.i(80431)
          , s = e.i(71529)
          , a = e.i(53259)
          , o = class extends a.Removable {
            #s;
            #a;
            #o;
            #l;
            #u;
            #h;
            #c;
            constructor(e) {
                super(),
                this.#c = !1,
                this.#h = e.defaultOptions,
                this.setOptions(e.options),
                this.observers = [],
                this.#l = e.client,
                this.#o = this.#l.getQueryCache(),
                this.queryKey = e.queryKey,
                this.queryHash = e.queryHash,
                this.#s = function(e) {
                    let t = "function" == typeof e.initialData ? e.initialData() : e.initialData
                      , r = void 0 !== t
                      , n = r ? "function" == typeof e.initialDataUpdatedAt ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
                    return {
                        data: t,
                        dataUpdateCount: 0,
                        dataUpdatedAt: r ? n ?? Date.now() : 0,
                        error: null,
                        errorUpdateCount: 0,
                        errorUpdatedAt: 0,
                        fetchFailureCount: 0,
                        fetchFailureReason: null,
                        fetchMeta: null,
                        isInvalidated: !1,
                        status: r ? "success" : "pending",
                        fetchStatus: "idle"
                    }
                }(this.options),
                this.state = e.state ?? this.#s,
                this.scheduleGc()
            }
            get meta() {
                return this.options.meta
            }
            get promise() {
                return this.#u?.promise
            }
            setOptions(e) {
                this.options = {
                    ...this.#h,
                    ...e
                },
                this.updateGcTime(this.options.gcTime)
            }
            optionalRemove() {
                this.observers.length || "idle" !== this.state.fetchStatus || this.#o.remove(this)
            }
            setData(e, t) {
                let r = (0,
                n.replaceData)(this.state.data, e, this.options);
                return this.#d({
                    data: r,
                    type: "success",
                    dataUpdatedAt: t?.updatedAt,
                    manual: t?.manual
                }),
                r
            }
            setState(e, t) {
                this.#d({
                    type: "setState",
                    state: e,
                    setStateOptions: t
                })
            }
            cancel(e) {
                let t = this.#u?.promise;
                return this.#u?.cancel(e),
                t ? t.then(n.noop).catch(n.noop) : Promise.resolve()
            }
            destroy() {
                super.destroy(),
                this.cancel({
                    silent: !0
                })
            }
            reset() {
                this.destroy(),
                this.setState(this.#s)
            }
            isActive() {
                return this.observers.some(e => !1 !== (0,
                n.resolveEnabled)(e.options.enabled, this))
            }
            isDisabled() {
                return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === n.skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
            }
            isStale() {
                return !!this.state.isInvalidated || (this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : void 0 === this.state.data)
            }
            isStaleByTime(e=0) {
                return this.state.isInvalidated || void 0 === this.state.data || !(0,
                n.timeUntilStale)(this.state.dataUpdatedAt, e)
            }
            onFocus() {
                let e = this.observers.find(e => e.shouldFetchOnWindowFocus());
                e?.refetch({
                    cancelRefetch: !1
                }),
                this.#u?.continue()
            }
            onOnline() {
                let e = this.observers.find(e => e.shouldFetchOnReconnect());
                e?.refetch({
                    cancelRefetch: !1
                }),
                this.#u?.continue()
            }
            addObserver(e) {
                this.observers.includes(e) || (this.observers.push(e),
                this.clearGcTimeout(),
                this.#o.notify({
                    type: "observerAdded",
                    query: this,
                    observer: e
                }))
            }
            removeObserver(e) {
                this.observers.includes(e) && (this.observers = this.observers.filter(t => t !== e),
                this.observers.length || (this.#u && (this.#c ? this.#u.cancel({
                    revert: !0
                }) : this.#u.cancelRetry()),
                this.scheduleGc()),
                this.#o.notify({
                    type: "observerRemoved",
                    query: this,
                    observer: e
                }))
            }
            getObserversCount() {
                return this.observers.length
            }
            invalidate() {
                this.state.isInvalidated || this.#d({
                    type: "invalidate"
                })
            }
            fetch(e, t) {
                if ("idle" !== this.state.fetchStatus) {
                    if (void 0 !== this.state.data && t?.cancelRefetch)
                        this.cancel({
                            silent: !0
                        });
                    else if (this.#u)
                        return this.#u.continueRetry(),
                        this.#u.promise
                }
                if (e && this.setOptions(e),
                !this.options.queryFn) {
                    let e = this.observers.find(e => e.options.queryFn);
                    e && this.setOptions(e.options)
                }
                let r = new AbortController
                  , i = e => {
                    Object.defineProperty(e, "signal", {
                        enumerable: !0,
                        get: () => (this.#c = !0,
                        r.signal)
                    })
                }
                  , a = {
                    fetchOptions: t,
                    options: this.options,
                    queryKey: this.queryKey,
                    client: this.#l,
                    state: this.state,
                    fetchFn: () => {
                        let e = (0,
                        n.ensureQueryFn)(this.options, t)
                          , r = {
                            client: this.#l,
                            queryKey: this.queryKey,
                            meta: this.meta
                        };
                        return (i(r),
                        this.#c = !1,
                        this.options.persister) ? this.options.persister(e, r, this) : e(r)
                    }
                };
                i(a),
                this.options.behavior?.onFetch(a, this),
                this.#a = this.state,
                ("idle" === this.state.fetchStatus || this.state.fetchMeta !== a.fetchOptions?.meta) && this.#d({
                    type: "fetch",
                    meta: a.fetchOptions?.meta
                });
                let o = e => {
                    (0,
                    s.isCancelledError)(e) && e.silent || this.#d({
                        type: "error",
                        error: e
                    }),
                    (0,
                    s.isCancelledError)(e) || (this.#o.config.onError?.(e, this),
                    this.#o.config.onSettled?.(this.state.data, e, this)),
                    this.scheduleGc()
                }
                ;
                return this.#u = (0,
                s.createRetryer)({
                    initialPromise: t?.initialPromise,
                    fn: a.fetchFn,
                    abort: r.abort.bind(r),
                    onSuccess: e => {
                        if (void 0 === e)
                            return void o(Error(`${this.queryHash} data is undefined`));
                        try {
                            this.setData(e)
                        } catch (e) {
                            o(e);
                            return
                        }
                        this.#o.config.onSuccess?.(e, this),
                        this.#o.config.onSettled?.(e, this.state.error, this),
                        this.scheduleGc()
                    }
                    ,
                    onError: o,
                    onFail: (e, t) => {
                        this.#d({
                            type: "failed",
                            failureCount: e,
                            error: t
                        })
                    }
                    ,
                    onPause: () => {
                        this.#d({
                            type: "pause"
                        })
                    }
                    ,
                    onContinue: () => {
                        this.#d({
                            type: "continue"
                        })
                    }
                    ,
                    retry: a.options.retry,
                    retryDelay: a.options.retryDelay,
                    networkMode: a.options.networkMode,
                    canRun: () => !0
                }),
                this.#u.start()
            }
            #d(e) {
                this.state = (t => {
                    switch (e.type) {
                    case "failed":
                        return {
                            ...t,
                            fetchFailureCount: e.failureCount,
                            fetchFailureReason: e.error
                        };
                    case "pause":
                        return {
                            ...t,
                            fetchStatus: "paused"
                        };
                    case "continue":
                        return {
                            ...t,
                            fetchStatus: "fetching"
                        };
                    case "fetch":
                        return {
                            ...t,
                            ...l(t.data, this.options),
                            fetchMeta: e.meta ?? null
                        };
                    case "success":
                        return {
                            ...t,
                            data: e.data,
                            dataUpdateCount: t.dataUpdateCount + 1,
                            dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                            error: null,
                            isInvalidated: !1,
                            status: "success",
                            ...!e.manual && {
                                fetchStatus: "idle",
                                fetchFailureCount: 0,
                                fetchFailureReason: null
                            }
                        };
                    case "error":
                        let r = e.error;
                        if ((0,
                        s.isCancelledError)(r) && r.revert && this.#a)
                            return {
                                ...this.#a,
                                fetchStatus: "idle"
                            };
                        return {
                            ...t,
                            error: r,
                            errorUpdateCount: t.errorUpdateCount + 1,
                            errorUpdatedAt: Date.now(),
                            fetchFailureCount: t.fetchFailureCount + 1,
                            fetchFailureReason: r,
                            fetchStatus: "idle",
                            status: "error"
                        };
                    case "invalidate":
                        return {
                            ...t,
                            isInvalidated: !0
                        };
                    case "setState":
                        return {
                            ...t,
                            ...e.state
                        }
                    }
                }
                )(this.state),
                i.notifyManager.batch( () => {
                    this.observers.forEach(e => {
                        e.onQueryUpdate()
                    }
                    ),
                    this.#o.notify({
                        query: this,
                        type: "updated",
                        action: e
                    })
                }
                )
            }
        }
        ;
        function l(e, t) {
            return {
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchStatus: (0,
                s.canFetch)(t.networkMode) ? "fetching" : "paused",
                ...void 0 === e && {
                    error: null,
                    status: "pending"
                }
            }
        }
    }
    ,
    47657: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            QueryCache: () => o
        });
        var n = e.i(45897)
          , i = e.i(82907)
          , s = e.i(80431)
          , a = e.i(41775)
          , o = class extends a.Subscribable {
            constructor(e={}) {
                super(),
                this.config = e,
                this.#f = new Map
            }
            #f;
            build(e, t, r) {
                let s = t.queryKey
                  , a = t.queryHash ?? (0,
                n.hashQueryKeyByOptions)(s, t)
                  , o = this.get(a);
                return o || (o = new i.Query({
                    client: e,
                    queryKey: s,
                    queryHash: a,
                    options: e.defaultQueryOptions(t),
                    state: r,
                    defaultOptions: e.getQueryDefaults(s)
                }),
                this.add(o)),
                o
            }
            add(e) {
                this.#f.has(e.queryHash) || (this.#f.set(e.queryHash, e),
                this.notify({
                    type: "added",
                    query: e
                }))
            }
            remove(e) {
                let t = this.#f.get(e.queryHash);
                t && (e.destroy(),
                t === e && this.#f.delete(e.queryHash),
                this.notify({
                    type: "removed",
                    query: e
                }))
            }
            clear() {
                s.notifyManager.batch( () => {
                    this.getAll().forEach(e => {
                        this.remove(e)
                    }
                    )
                }
                )
            }
            get(e) {
                return this.#f.get(e)
            }
            getAll() {
                return [...this.#f.values()]
            }
            find(e) {
                let t = {
                    exact: !0,
                    ...e
                };
                return this.getAll().find(e => (0,
                n.matchQuery)(t, e))
            }
            findAll(e={}) {
                let t = this.getAll();
                return Object.keys(e).length > 0 ? t.filter(t => (0,
                n.matchQuery)(e, t)) : t
            }
            notify(e) {
                s.notifyManager.batch( () => {
                    this.listeners.forEach(t => {
                        t(e)
                    }
                    )
                }
                )
            }
            onFocus() {
                s.notifyManager.batch( () => {
                    this.getAll().forEach(e => {
                        e.onFocus()
                    }
                    )
                }
                )
            }
            onOnline() {
                s.notifyManager.batch( () => {
                    this.getAll().forEach(e => {
                        e.onOnline()
                    }
                    )
                }
                )
            }
        }
    }
    ,
    5632: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            Mutation: () => a,
            getDefaultState: () => o
        });
        var n = e.i(80431)
          , i = e.i(53259)
          , s = e.i(71529)
          , a = class extends i.Removable {
            #p;
            #g;
            #u;
            constructor(e) {
                super(),
                this.mutationId = e.mutationId,
                this.#g = e.mutationCache,
                this.#p = [],
                this.state = e.state || o(),
                this.setOptions(e.options),
                this.scheduleGc()
            }
            setOptions(e) {
                this.options = e,
                this.updateGcTime(this.options.gcTime)
            }
            get meta() {
                return this.options.meta
            }
            addObserver(e) {
                this.#p.includes(e) || (this.#p.push(e),
                this.clearGcTimeout(),
                this.#g.notify({
                    type: "observerAdded",
                    mutation: this,
                    observer: e
                }))
            }
            removeObserver(e) {
                this.#p = this.#p.filter(t => t !== e),
                this.scheduleGc(),
                this.#g.notify({
                    type: "observerRemoved",
                    mutation: this,
                    observer: e
                })
            }
            optionalRemove() {
                this.#p.length || ("pending" === this.state.status ? this.scheduleGc() : this.#g.remove(this))
            }
            continue() {
                return this.#u?.continue() ?? this.execute(this.state.variables)
            }
            async execute(e) {
                let t = () => {
                    this.#d({
                        type: "continue"
                    })
                }
                ;
                this.#u = (0,
                s.createRetryer)({
                    fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(Error("No mutationFn found")),
                    onFail: (e, t) => {
                        this.#d({
                            type: "failed",
                            failureCount: e,
                            error: t
                        })
                    }
                    ,
                    onPause: () => {
                        this.#d({
                            type: "pause"
                        })
                    }
                    ,
                    onContinue: t,
                    retry: this.options.retry ?? 0,
                    retryDelay: this.options.retryDelay,
                    networkMode: this.options.networkMode,
                    canRun: () => this.#g.canRun(this)
                });
                let r = "pending" === this.state.status
                  , n = !this.#u.canStart();
                try {
                    if (r)
                        t();
                    else {
                        this.#d({
                            type: "pending",
                            variables: e,
                            isPaused: n
                        }),
                        await this.#g.config.onMutate?.(e, this);
                        let t = await this.options.onMutate?.(e);
                        t !== this.state.context && this.#d({
                            type: "pending",
                            context: t,
                            variables: e,
                            isPaused: n
                        })
                    }
                    let i = await this.#u.start();
                    return await this.#g.config.onSuccess?.(i, e, this.state.context, this),
                    await this.options.onSuccess?.(i, e, this.state.context),
                    await this.#g.config.onSettled?.(i, null, this.state.variables, this.state.context, this),
                    await this.options.onSettled?.(i, null, e, this.state.context),
                    this.#d({
                        type: "success",
                        data: i
                    }),
                    i
                } catch (t) {
                    try {
                        throw await this.#g.config.onError?.(t, e, this.state.context, this),
                        await this.options.onError?.(t, e, this.state.context),
                        await this.#g.config.onSettled?.(void 0, t, this.state.variables, this.state.context, this),
                        await this.options.onSettled?.(void 0, t, e, this.state.context),
                        t
                    } finally {
                        this.#d({
                            type: "error",
                            error: t
                        })
                    }
                } finally {
                    this.#g.runNext(this)
                }
            }
            #d(e) {
                this.state = (t => {
                    switch (e.type) {
                    case "failed":
                        return {
                            ...t,
                            failureCount: e.failureCount,
                            failureReason: e.error
                        };
                    case "pause":
                        return {
                            ...t,
                            isPaused: !0
                        };
                    case "continue":
                        return {
                            ...t,
                            isPaused: !1
                        };
                    case "pending":
                        return {
                            ...t,
                            context: e.context,
                            data: void 0,
                            failureCount: 0,
                            failureReason: null,
                            error: null,
                            isPaused: e.isPaused,
                            status: "pending",
                            variables: e.variables,
                            submittedAt: Date.now()
                        };
                    case "success":
                        return {
                            ...t,
                            data: e.data,
                            failureCount: 0,
                            failureReason: null,
                            error: null,
                            status: "success",
                            isPaused: !1
                        };
                    case "error":
                        return {
                            ...t,
                            data: void 0,
                            error: e.error,
                            failureCount: t.failureCount + 1,
                            failureReason: e.error,
                            isPaused: !1,
                            status: "error"
                        }
                    }
                }
                )(this.state),
                n.notifyManager.batch( () => {
                    this.#p.forEach(t => {
                        t.onMutationUpdate(e)
                    }
                    ),
                    this.#g.notify({
                        mutation: this,
                        type: "updated",
                        action: e
                    })
                }
                )
            }
        }
        ;
        function o() {
            return {
                context: void 0,
                data: void 0,
                error: null,
                failureCount: 0,
                failureReason: null,
                isPaused: !1,
                status: "idle",
                variables: void 0,
                submittedAt: 0
            }
        }
    }
    ,
    12766: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            MutationCache: () => o
        });
        var n = e.i(80431)
          , i = e.i(5632)
          , s = e.i(45897)
          , a = e.i(41775)
          , o = class extends a.Subscribable {
            constructor(e={}) {
                super(),
                this.config = e,
                this.#m = new Set,
                this.#y = new Map,
                this.#v = 0
            }
            #m;
            #y;
            #v;
            build(e, t, r) {
                let n = new i.Mutation({
                    mutationCache: this,
                    mutationId: ++this.#v,
                    options: e.defaultMutationOptions(t),
                    state: r
                });
                return this.add(n),
                n
            }
            add(e) {
                this.#m.add(e);
                let t = l(e);
                if ("string" == typeof t) {
                    let r = this.#y.get(t);
                    r ? r.push(e) : this.#y.set(t, [e])
                }
                this.notify({
                    type: "added",
                    mutation: e
                })
            }
            remove(e) {
                if (this.#m.delete(e)) {
                    let t = l(e);
                    if ("string" == typeof t) {
                        let r = this.#y.get(t);
                        if (r)
                            if (r.length > 1) {
                                let t = r.indexOf(e);
                                -1 !== t && r.splice(t, 1)
                            } else
                                r[0] === e && this.#y.delete(t)
                    }
                }
                this.notify({
                    type: "removed",
                    mutation: e
                })
            }
            canRun(e) {
                let t = l(e);
                if ("string" != typeof t)
                    return !0;
                {
                    let r = this.#y.get(t)
                      , n = r?.find(e => "pending" === e.state.status);
                    return !n || n === e
                }
            }
            runNext(e) {
                let t = l(e);
                if ("string" != typeof t)
                    return Promise.resolve();
                {
                    let r = this.#y.get(t)?.find(t => t !== e && t.state.isPaused);
                    return r?.continue() ?? Promise.resolve()
                }
            }
            clear() {
                n.notifyManager.batch( () => {
                    this.#m.forEach(e => {
                        this.notify({
                            type: "removed",
                            mutation: e
                        })
                    }
                    ),
                    this.#m.clear(),
                    this.#y.clear()
                }
                )
            }
            getAll() {
                return Array.from(this.#m)
            }
            find(e) {
                let t = {
                    exact: !0,
                    ...e
                };
                return this.getAll().find(e => (0,
                s.matchMutation)(t, e))
            }
            findAll(e={}) {
                return this.getAll().filter(t => (0,
                s.matchMutation)(e, t))
            }
            notify(e) {
                n.notifyManager.batch( () => {
                    this.listeners.forEach(t => {
                        t(e)
                    }
                    )
                }
                )
            }
            resumePausedMutations() {
                let e = this.getAll().filter(e => e.state.isPaused);
                return n.notifyManager.batch( () => Promise.all(e.map(e => e.continue().catch(s.noop))))
            }
        }
        ;
        function l(e) {
            return e.options.scope?.id
        }
    }
    ,
    91323: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            hasNextPage: () => o,
            hasPreviousPage: () => l,
            infiniteQueryBehavior: () => i
        });
        var n = e.i(45897);
        function i(e) {
            return {
                onFetch: (t, r) => {
                    let i = t.options
                      , o = t.fetchOptions?.meta?.fetchMore?.direction
                      , l = t.state.data?.pages || []
                      , u = t.state.data?.pageParams || []
                      , h = {
                        pages: [],
                        pageParams: []
                    }
                      , c = 0
                      , d = async () => {
                        let r = !1
                          , d = e => {
                            Object.defineProperty(e, "signal", {
                                enumerable: !0,
                                get: () => (t.signal.aborted ? r = !0 : t.signal.addEventListener("abort", () => {
                                    r = !0
                                }
                                ),
                                t.signal)
                            })
                        }
                          , f = (0,
                        n.ensureQueryFn)(t.options, t.fetchOptions)
                          , p = async (e, i, s) => {
                            if (r)
                                return Promise.reject();
                            if (null == i && e.pages.length)
                                return Promise.resolve(e);
                            let a = {
                                client: t.client,
                                queryKey: t.queryKey,
                                pageParam: i,
                                direction: s ? "backward" : "forward",
                                meta: t.options.meta
                            };
                            d(a);
                            let o = await f(a)
                              , {maxPages: l} = t.options
                              , u = s ? n.addToStart : n.addToEnd;
                            return {
                                pages: u(e.pages, o, l),
                                pageParams: u(e.pageParams, i, l)
                            }
                        }
                        ;
                        if (o && l.length) {
                            let e = "backward" === o
                              , t = {
                                pages: l,
                                pageParams: u
                            }
                              , r = (e ? a : s)(i, t);
                            h = await p(t, r, e)
                        } else {
                            let t = e ?? l.length;
                            do {
                                let e = 0 === c ? u[0] ?? i.initialPageParam : s(i, h);
                                if (c > 0 && null == e)
                                    break;
                                h = await p(h, e),
                                c++
                            } while (c < t)
                        }
                        return h
                    }
                    ;
                    t.options.persister ? t.fetchFn = () => t.options.persister?.(d, {
                        client: t.client,
                        queryKey: t.queryKey,
                        meta: t.options.meta,
                        signal: t.signal
                    }, r) : t.fetchFn = d
                }
            }
        }
        function s(e, {pages: t, pageParams: r}) {
            let n = t.length - 1;
            return t.length > 0 ? e.getNextPageParam(t[n], t, r[n], r) : void 0
        }
        function a(e, {pages: t, pageParams: r}) {
            return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, r[0], r) : void 0
        }
        function o(e, t) {
            return !!t && null != s(e, t)
        }
        function l(e, t) {
            return !!t && !!e.getPreviousPageParam && null != a(e, t)
        }
    }
    ,
    40791: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            QueryClient: () => h
        });
        var n = e.i(45897)
          , i = e.i(47657)
          , s = e.i(12766)
          , a = e.i(47011)
          , o = e.i(78e3)
          , l = e.i(80431)
          , u = e.i(91323)
          , h = class {
            #w;
            #g;
            #h;
            #b;
            #E;
            #I;
            #_;
            #T;
            constructor(e={}) {
                this.#w = e.queryCache || new i.QueryCache,
                this.#g = e.mutationCache || new s.MutationCache,
                this.#h = e.defaultOptions || {},
                this.#b = new Map,
                this.#E = new Map,
                this.#I = 0
            }
            mount() {
                this.#I++,
                1 === this.#I && (this.#_ = a.focusManager.subscribe(async e => {
                    e && (await this.resumePausedMutations(),
                    this.#w.onFocus())
                }
                ),
                this.#T = o.onlineManager.subscribe(async e => {
                    e && (await this.resumePausedMutations(),
                    this.#w.onOnline())
                }
                ))
            }
            unmount() {
                this.#I--,
                0 === this.#I && (this.#_?.(),
                this.#_ = void 0,
                this.#T?.(),
                this.#T = void 0)
            }
            isFetching(e) {
                return this.#w.findAll({
                    ...e,
                    fetchStatus: "fetching"
                }).length
            }
            isMutating(e) {
                return this.#g.findAll({
                    ...e,
                    status: "pending"
                }).length
            }
            getQueryData(e) {
                let t = this.defaultQueryOptions({
                    queryKey: e
                });
                return this.#w.get(t.queryHash)?.state.data
            }
            ensureQueryData(e) {
                let t = this.defaultQueryOptions(e)
                  , r = this.#w.build(this, t)
                  , i = r.state.data;
                return void 0 === i ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime((0,
                n.resolveStaleTime)(t.staleTime, r)) && this.prefetchQuery(t),
                Promise.resolve(i))
            }
            getQueriesData(e) {
                return this.#w.findAll(e).map( ({queryKey: e, state: t}) => [e, t.data])
            }
            setQueryData(e, t, r) {
                let i = this.defaultQueryOptions({
                    queryKey: e
                })
                  , s = this.#w.get(i.queryHash)
                  , a = s?.state.data
                  , o = (0,
                n.functionalUpdate)(t, a);
                if (void 0 !== o)
                    return this.#w.build(this, i).setData(o, {
                        ...r,
                        manual: !0
                    })
            }
            setQueriesData(e, t, r) {
                return l.notifyManager.batch( () => this.#w.findAll(e).map( ({queryKey: e}) => [e, this.setQueryData(e, t, r)]))
            }
            getQueryState(e) {
                let t = this.defaultQueryOptions({
                    queryKey: e
                });
                return this.#w.get(t.queryHash)?.state
            }
            removeQueries(e) {
                let t = this.#w;
                l.notifyManager.batch( () => {
                    t.findAll(e).forEach(e => {
                        t.remove(e)
                    }
                    )
                }
                )
            }
            resetQueries(e, t) {
                let r = this.#w;
                return l.notifyManager.batch( () => (r.findAll(e).forEach(e => {
                    e.reset()
                }
                ),
                this.refetchQueries({
                    type: "active",
                    ...e
                }, t)))
            }
            cancelQueries(e, t={}) {
                let r = {
                    revert: !0,
                    ...t
                };
                return Promise.all(l.notifyManager.batch( () => this.#w.findAll(e).map(e => e.cancel(r)))).then(n.noop).catch(n.noop)
            }
            invalidateQueries(e, t={}) {
                return l.notifyManager.batch( () => (this.#w.findAll(e).forEach(e => {
                    e.invalidate()
                }
                ),
                e?.refetchType === "none") ? Promise.resolve() : this.refetchQueries({
                    ...e,
                    type: e?.refetchType ?? e?.type ?? "active"
                }, t))
            }
            refetchQueries(e, t={}) {
                let r = {
                    ...t,
                    cancelRefetch: t.cancelRefetch ?? !0
                };
                return Promise.all(l.notifyManager.batch( () => this.#w.findAll(e).filter(e => !e.isDisabled()).map(e => {
                    let t = e.fetch(void 0, r);
                    return r.throwOnError || (t = t.catch(n.noop)),
                    "paused" === e.state.fetchStatus ? Promise.resolve() : t
                }
                ))).then(n.noop)
            }
            fetchQuery(e) {
                let t = this.defaultQueryOptions(e);
                void 0 === t.retry && (t.retry = !1);
                let r = this.#w.build(this, t);
                return r.isStaleByTime((0,
                n.resolveStaleTime)(t.staleTime, r)) ? r.fetch(t) : Promise.resolve(r.state.data)
            }
            prefetchQuery(e) {
                return this.fetchQuery(e).then(n.noop).catch(n.noop)
            }
            fetchInfiniteQuery(e) {
                return e.behavior = (0,
                u.infiniteQueryBehavior)(e.pages),
                this.fetchQuery(e)
            }
            prefetchInfiniteQuery(e) {
                return this.fetchInfiniteQuery(e).then(n.noop).catch(n.noop)
            }
            ensureInfiniteQueryData(e) {
                return e.behavior = (0,
                u.infiniteQueryBehavior)(e.pages),
                this.ensureQueryData(e)
            }
            resumePausedMutations() {
                return o.onlineManager.isOnline() ? this.#g.resumePausedMutations() : Promise.resolve()
            }
            getQueryCache() {
                return this.#w
            }
            getMutationCache() {
                return this.#g
            }
            getDefaultOptions() {
                return this.#h
            }
            setDefaultOptions(e) {
                this.#h = e
            }
            setQueryDefaults(e, t) {
                this.#b.set((0,
                n.hashKey)(e), {
                    queryKey: e,
                    defaultOptions: t
                })
            }
            getQueryDefaults(e) {
                let t = [...this.#b.values()]
                  , r = {};
                return t.forEach(t => {
                    (0,
                    n.partialMatchKey)(e, t.queryKey) && Object.assign(r, t.defaultOptions)
                }
                ),
                r
            }
            setMutationDefaults(e, t) {
                this.#E.set((0,
                n.hashKey)(e), {
                    mutationKey: e,
                    defaultOptions: t
                })
            }
            getMutationDefaults(e) {
                let t = [...this.#E.values()]
                  , r = {};
                return t.forEach(t => {
                    (0,
                    n.partialMatchKey)(e, t.mutationKey) && Object.assign(r, t.defaultOptions)
                }
                ),
                r
            }
            defaultQueryOptions(e) {
                if (e._defaulted)
                    return e;
                let t = {
                    ...this.#h.queries,
                    ...this.getQueryDefaults(e.queryKey),
                    ...e,
                    _defaulted: !0
                };
                return t.queryHash || (t.queryHash = (0,
                n.hashQueryKeyByOptions)(t.queryKey, t)),
                void 0 === t.refetchOnReconnect && (t.refetchOnReconnect = "always" !== t.networkMode),
                void 0 === t.throwOnError && (t.throwOnError = !!t.suspense),
                !t.networkMode && t.persister && (t.networkMode = "offlineFirst"),
                t.queryFn === n.skipToken && (t.enabled = !1),
                t
            }
            defaultMutationOptions(e) {
                return e?._defaulted ? e : {
                    ...this.#h.mutations,
                    ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
                    ...e,
                    _defaulted: !0
                }
            }
            clear() {
                this.#w.clear(),
                this.#g.clear()
            }
        }
    }
    ,
    89582: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            QueryObserver: () => u
        });
        var n = e.i(47011)
          , i = e.i(80431)
          , s = e.i(82907)
          , a = e.i(41775)
          , o = e.i(9291)
          , l = e.i(45897)
          , u = class extends a.Subscribable {
            constructor(e, t) {
                super(),
                this.options = t,
                this.#l = e,
                this.#S = null,
                this.#C = (0,
                o.pendingThenable)(),
                this.options.experimental_prefetchInRender || this.#C.reject(Error("experimental_prefetchInRender feature flag is not enabled")),
                this.bindMethods(),
                this.setOptions(t)
            }
            #l;
            #x = void 0;
            #A = void 0;
            #D = void 0;
            #k;
            #N;
            #C;
            #S;
            #O;
            #R;
            #M;
            #P;
            #L;
            #F;
            #B = new Set;
            bindMethods() {
                this.refetch = this.refetch.bind(this)
            }
            onSubscribe() {
                1 === this.listeners.size && (this.#x.addObserver(this),
                h(this.#x, this.options) ? this.#V() : this.updateResult(),
                this.#U())
            }
            onUnsubscribe() {
                this.hasListeners() || this.destroy()
            }
            shouldFetchOnReconnect() {
                return c(this.#x, this.options, this.options.refetchOnReconnect)
            }
            shouldFetchOnWindowFocus() {
                return c(this.#x, this.options, this.options.refetchOnWindowFocus)
            }
            destroy() {
                this.listeners = new Set,
                this.#q(),
                this.#j(),
                this.#x.removeObserver(this)
            }
            setOptions(e) {
                let t = this.options
                  , r = this.#x;
                if (this.options = this.#l.defaultQueryOptions(e),
                void 0 !== this.options.enabled && "boolean" != typeof this.options.enabled && "function" != typeof this.options.enabled && "boolean" != typeof (0,
                l.resolveEnabled)(this.options.enabled, this.#x))
                    throw Error("Expected enabled to be a boolean or a callback that returns a boolean");
                this.#z(),
                this.#x.setOptions(this.options),
                t._defaulted && !(0,
                l.shallowEqualObjects)(this.options, t) && this.#l.getQueryCache().notify({
                    type: "observerOptionsUpdated",
                    query: this.#x,
                    observer: this
                });
                let n = this.hasListeners();
                n && d(this.#x, r, this.options, t) && this.#V(),
                this.updateResult(),
                n && (this.#x !== r || (0,
                l.resolveEnabled)(this.options.enabled, this.#x) !== (0,
                l.resolveEnabled)(t.enabled, this.#x) || (0,
                l.resolveStaleTime)(this.options.staleTime, this.#x) !== (0,
                l.resolveStaleTime)(t.staleTime, this.#x)) && this.#Q();
                let i = this.#K();
                n && (this.#x !== r || (0,
                l.resolveEnabled)(this.options.enabled, this.#x) !== (0,
                l.resolveEnabled)(t.enabled, this.#x) || i !== this.#F) && this.#$(i)
            }
            getOptimisticResult(e) {
                var t, r;
                let n = this.#l.getQueryCache().build(this.#l, e)
                  , i = this.createResult(n, e);
                return t = this,
                r = i,
                (0,
                l.shallowEqualObjects)(t.getCurrentResult(), r) || (this.#D = i,
                this.#N = this.options,
                this.#k = this.#x.state),
                i
            }
            getCurrentResult() {
                return this.#D
            }
            trackResult(e, t) {
                return new Proxy(e,{
                    get: (e, r) => (this.trackProp(r),
                    t?.(r),
                    Reflect.get(e, r))
                })
            }
            trackProp(e) {
                this.#B.add(e)
            }
            getCurrentQuery() {
                return this.#x
            }
            refetch({...e}={}) {
                return this.fetch({
                    ...e
                })
            }
            fetchOptimistic(e) {
                let t = this.#l.defaultQueryOptions(e)
                  , r = this.#l.getQueryCache().build(this.#l, t);
                return r.fetch().then( () => this.createResult(r, t))
            }
            fetch(e) {
                return this.#V({
                    ...e,
                    cancelRefetch: e.cancelRefetch ?? !0
                }).then( () => (this.updateResult(),
                this.#D))
            }
            #V(e) {
                this.#z();
                let t = this.#x.fetch(this.options, e);
                return e?.throwOnError || (t = t.catch(l.noop)),
                t
            }
            #Q() {
                this.#q();
                let e = (0,
                l.resolveStaleTime)(this.options.staleTime, this.#x);
                if (l.isServer || this.#D.isStale || !(0,
                l.isValidTimeout)(e))
                    return;
                let t = (0,
                l.timeUntilStale)(this.#D.dataUpdatedAt, e);
                this.#P = setTimeout( () => {
                    this.#D.isStale || this.updateResult()
                }
                , t + 1)
            }
            #K() {
                return ("function" == typeof this.options.refetchInterval ? this.options.refetchInterval(this.#x) : this.options.refetchInterval) ?? !1
            }
            #$(e) {
                this.#j(),
                this.#F = e,
                !l.isServer && !1 !== (0,
                l.resolveEnabled)(this.options.enabled, this.#x) && (0,
                l.isValidTimeout)(this.#F) && 0 !== this.#F && (this.#L = setInterval( () => {
                    (this.options.refetchIntervalInBackground || n.focusManager.isFocused()) && this.#V()
                }
                , this.#F))
            }
            #U() {
                this.#Q(),
                this.#$(this.#K())
            }
            #q() {
                this.#P && (clearTimeout(this.#P),
                this.#P = void 0)
            }
            #j() {
                this.#L && (clearInterval(this.#L),
                this.#L = void 0)
            }
            createResult(e, t) {
                let r, n = this.#x, i = this.options, a = this.#D, u = this.#k, c = this.#N, p = e !== n ? e.state : this.#A, {state: g} = e, m = {
                    ...g
                }, y = !1;
                if (t._optimisticResults) {
                    let r = this.hasListeners()
                      , a = !r && h(e, t)
                      , o = r && d(e, n, t, i);
                    (a || o) && (m = {
                        ...m,
                        ...(0,
                        s.fetchState)(g.data, e.options)
                    }),
                    "isRestoring" === t._optimisticResults && (m.fetchStatus = "idle")
                }
                let {error: v, errorUpdatedAt: w, status: b} = m;
                r = m.data;
                let E = !1;
                if (void 0 !== t.placeholderData && void 0 === r && "pending" === b) {
                    let e;
                    a?.isPlaceholderData && t.placeholderData === c?.placeholderData ? (e = a.data,
                    E = !0) : e = "function" == typeof t.placeholderData ? t.placeholderData(this.#M?.state.data, this.#M) : t.placeholderData,
                    void 0 !== e && (b = "success",
                    r = (0,
                    l.replaceData)(a?.data, e, t),
                    y = !0)
                }
                if (t.select && void 0 !== r && !E)
                    if (a && r === u?.data && t.select === this.#O)
                        r = this.#R;
                    else
                        try {
                            this.#O = t.select,
                            r = t.select(r),
                            r = (0,
                            l.replaceData)(a?.data, r, t),
                            this.#R = r,
                            this.#S = null
                        } catch (e) {
                            this.#S = e
                        }
                this.#S && (v = this.#S,
                r = this.#R,
                w = Date.now(),
                b = "error");
                let I = "fetching" === m.fetchStatus
                  , _ = "pending" === b
                  , T = "error" === b
                  , S = _ && I
                  , C = void 0 !== r
                  , x = {
                    status: b,
                    fetchStatus: m.fetchStatus,
                    isPending: _,
                    isSuccess: "success" === b,
                    isError: T,
                    isInitialLoading: S,
                    isLoading: S,
                    data: r,
                    dataUpdatedAt: m.dataUpdatedAt,
                    error: v,
                    errorUpdatedAt: w,
                    failureCount: m.fetchFailureCount,
                    failureReason: m.fetchFailureReason,
                    errorUpdateCount: m.errorUpdateCount,
                    isFetched: m.dataUpdateCount > 0 || m.errorUpdateCount > 0,
                    isFetchedAfterMount: m.dataUpdateCount > p.dataUpdateCount || m.errorUpdateCount > p.errorUpdateCount,
                    isFetching: I,
                    isRefetching: I && !_,
                    isLoadingError: T && !C,
                    isPaused: "paused" === m.fetchStatus,
                    isPlaceholderData: y,
                    isRefetchError: T && C,
                    isStale: f(e, t),
                    refetch: this.refetch,
                    promise: this.#C
                };
                if (this.options.experimental_prefetchInRender) {
                    let t = e => {
                        "error" === x.status ? e.reject(x.error) : void 0 !== x.data && e.resolve(x.data)
                    }
                      , r = () => {
                        t(this.#C = x.promise = (0,
                        o.pendingThenable)())
                    }
                      , i = this.#C;
                    switch (i.status) {
                    case "pending":
                        e.queryHash === n.queryHash && t(i);
                        break;
                    case "fulfilled":
                        ("error" === x.status || x.data !== i.value) && r();
                        break;
                    case "rejected":
                        ("error" !== x.status || x.error !== i.reason) && r()
                    }
                }
                return x
            }
            updateResult() {
                let e = this.#D
                  , t = this.createResult(this.#x, this.options);
                this.#k = this.#x.state,
                this.#N = this.options,
                void 0 !== this.#k.data && (this.#M = this.#x),
                (0,
                l.shallowEqualObjects)(t, e) || (this.#D = t,
                this.#G({
                    listeners: ( () => {
                        if (!e)
                            return !0;
                        let {notifyOnChangeProps: t} = this.options
                          , r = "function" == typeof t ? t() : t;
                        if ("all" === r || !r && !this.#B.size)
                            return !0;
                        let n = new Set(r ?? this.#B);
                        return this.options.throwOnError && n.add("error"),
                        Object.keys(this.#D).some(t => this.#D[t] !== e[t] && n.has(t))
                    }
                    )()
                }))
            }
            #z() {
                let e = this.#l.getQueryCache().build(this.#l, this.options);
                if (e === this.#x)
                    return;
                let t = this.#x;
                this.#x = e,
                this.#A = e.state,
                this.hasListeners() && (t?.removeObserver(this),
                e.addObserver(this))
            }
            onQueryUpdate() {
                this.updateResult(),
                this.hasListeners() && this.#U()
            }
            #G(e) {
                i.notifyManager.batch( () => {
                    e.listeners && this.listeners.forEach(e => {
                        e(this.#D)
                    }
                    ),
                    this.#l.getQueryCache().notify({
                        query: this.#x,
                        type: "observerResultsUpdated"
                    })
                }
                )
            }
        }
        ;
        function h(e, t) {
            return !1 !== (0,
            l.resolveEnabled)(t.enabled, e) && void 0 === e.state.data && ("error" !== e.state.status || !1 !== t.retryOnMount) || void 0 !== e.state.data && c(e, t, t.refetchOnMount)
        }
        function c(e, t, r) {
            if (!1 !== (0,
            l.resolveEnabled)(t.enabled, e)) {
                let n = "function" == typeof r ? r(e) : r;
                return "always" === n || !1 !== n && f(e, t)
            }
            return !1
        }
        function d(e, t, r, n) {
            return (e !== t || !1 === (0,
            l.resolveEnabled)(n.enabled, e)) && (!r.suspense || "error" !== e.state.status) && f(e, r)
        }
        function f(e, t) {
            return !1 !== (0,
            l.resolveEnabled)(t.enabled, e) && e.isStaleByTime((0,
            l.resolveStaleTime)(t.staleTime, e))
        }
    }
    ,
    17230: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            InfiniteQueryObserver: () => s
        });
        var n = e.i(89582)
          , i = e.i(91323)
          , s = class extends n.QueryObserver {
            constructor(e, t) {
                super(e, t)
            }
            bindMethods() {
                super.bindMethods(),
                this.fetchNextPage = this.fetchNextPage.bind(this),
                this.fetchPreviousPage = this.fetchPreviousPage.bind(this)
            }
            setOptions(e) {
                super.setOptions({
                    ...e,
                    behavior: (0,
                    i.infiniteQueryBehavior)()
                })
            }
            getOptimisticResult(e) {
                return e.behavior = (0,
                i.infiniteQueryBehavior)(),
                super.getOptimisticResult(e)
            }
            fetchNextPage(e) {
                return this.fetch({
                    ...e,
                    meta: {
                        fetchMore: {
                            direction: "forward"
                        }
                    }
                })
            }
            fetchPreviousPage(e) {
                return this.fetch({
                    ...e,
                    meta: {
                        fetchMore: {
                            direction: "backward"
                        }
                    }
                })
            }
            createResult(e, t) {
                let {state: r} = e
                  , n = super.createResult(e, t)
                  , {isFetching: s, isRefetching: a, isError: o, isRefetchError: l} = n
                  , u = r.fetchMeta?.fetchMore?.direction
                  , h = o && "forward" === u
                  , c = s && "forward" === u
                  , d = o && "backward" === u
                  , f = s && "backward" === u;
                return {
                    ...n,
                    fetchNextPage: this.fetchNextPage,
                    fetchPreviousPage: this.fetchPreviousPage,
                    hasNextPage: (0,
                    i.hasNextPage)(t, r.data),
                    hasPreviousPage: (0,
                    i.hasPreviousPage)(t, r.data),
                    isFetchNextPageError: h,
                    isFetchingNextPage: c,
                    isFetchPreviousPageError: d,
                    isFetchingPreviousPage: f,
                    isRefetchError: l && !h && !d,
                    isRefetching: a && !c && !f
                }
            }
        }
    }
    ,
    88256: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            QueryErrorResetBoundary: () => l,
            useQueryErrorResetBoundary: () => o
        });
        var n = e.i(38653)
          , i = e.i(31636);
        function s() {
            let e = !1;
            return {
                clearReset: () => {
                    e = !1
                }
                ,
                reset: () => {
                    e = !0
                }
                ,
                isReset: () => e
            }
        }
        var a = (0,
        n.createContext)(s())
          , o = () => (0,
        n.useContext)(a)
          , l = ({children: e}) => {
            let[t] = (0,
            n.useState)( () => s());
            return (0,
            i.jsx)(a.Provider, {
                value: t,
                children: "function" == typeof e ? e(t) : e
            })
        }
    }
    ,
    2137: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            ensurePreventErrorBoundaryRetry: () => s,
            getHasError: () => o,
            useClearResetErrorBoundary: () => a
        });
        var n = e.i(38653)
          , i = e.i(45897)
          , s = (e, t) => {
            (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && !t.isReset() && (e.retryOnMount = !1)
        }
          , a = e => {
            (0,
            n.useEffect)( () => {
                e.clearReset()
            }
            , [e])
        }
          , o = ({result: e, errorResetBoundary: t, throwOnError: r, query: n, suspense: s}) => e.isError && !t.isReset() && !e.isFetching && n && (s && void 0 === e.data || (0,
        i.shouldThrowError)(r, [e.error, n]))
    }
    ,
    13096: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            IsRestoringProvider: () => a,
            useIsRestoring: () => s
        });
        var n = e.i(38653)
          , i = (0,
        n.createContext)(!1)
          , s = () => (0,
        n.useContext)(i)
          , a = i.Provider
    }
    ,
    72104: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            defaultThrowOnError: () => n,
            ensureSuspenseTimers: () => i,
            fetchOptimistic: () => o,
            shouldSuspend: () => a,
            willFetch: () => s
        });
        var n = (e, t) => void 0 === t.state.data
          , i = e => {
            let t = e.staleTime;
            e.suspense && (e.staleTime = "function" == typeof t ? (...e) => Math.max(t(...e), 1e3) : Math.max(t ?? 1e3, 1e3),
            "number" == typeof e.gcTime && (e.gcTime = Math.max(e.gcTime, 1e3)))
        }
          , s = (e, t) => e.isLoading && e.isFetching && !t
          , a = (e, t) => e?.suspense && t.isPending
          , o = (e, t, r) => t.fetchOptimistic(e).catch( () => {
            r.clearReset()
        }
        )
    }
    ,
    81893: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            useBaseQuery: () => c
        }),
        e.i(22271);
        var n = e.i(38653)
          , i = e.i(45897)
          , s = e.i(80431)
          , a = e.i(28662)
          , o = e.i(88256)
          , l = e.i(2137)
          , u = e.i(13096)
          , h = e.i(72104);
        function c(e, t, r) {
            let c = (0,
            a.useQueryClient)(r)
              , d = (0,
            u.useIsRestoring)()
              , f = (0,
            o.useQueryErrorResetBoundary)()
              , p = c.defaultQueryOptions(e);
            c.getDefaultOptions().queries?._experimental_beforeQuery?.(p),
            p._optimisticResults = d ? "isRestoring" : "optimistic",
            (0,
            h.ensureSuspenseTimers)(p),
            (0,
            l.ensurePreventErrorBoundaryRetry)(p, f),
            (0,
            l.useClearResetErrorBoundary)(f);
            let g = !c.getQueryCache().get(p.queryHash)
              , [m] = (0,
            n.useState)( () => new t(c,p))
              , y = m.getOptimisticResult(p)
              , v = !d && !1 !== e.subscribed;
            if ((0,
            n.useSyncExternalStore)((0,
            n.useCallback)(e => {
                let t = v ? m.subscribe(s.notifyManager.batchCalls(e)) : i.noop;
                return m.updateResult(),
                t
            }
            , [m, v]), () => m.getCurrentResult(), () => m.getCurrentResult()),
            (0,
            n.useEffect)( () => {
                m.setOptions(p)
            }
            , [p, m]),
            (0,
            h.shouldSuspend)(p, y))
                throw (0,
                h.fetchOptimistic)(p, m, f);
            if ((0,
            l.getHasError)({
                result: y,
                errorResetBoundary: f,
                throwOnError: p.throwOnError,
                query: c.getQueryCache().get(p.queryHash),
                suspense: p.suspense
            }))
                throw y.error;
            if (c.getDefaultOptions().queries?._experimental_afterQuery?.(p, y),
            p.experimental_prefetchInRender && !i.isServer && (0,
            h.willFetch)(y, d)) {
                let e = g ? (0,
                h.fetchOptimistic)(p, m, f) : c.getQueryCache().get(p.queryHash)?.promise;
                e?.catch(i.noop).finally( () => {
                    m.updateResult()
                }
                )
            }
            return p.notifyOnChangeProps ? y : m.trackResult(y)
        }
    }
    ,
    13674: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            useInfiniteQuery: () => s
        });
        var n = e.i(17230)
          , i = e.i(81893);
        function s(e, t) {
            return (0,
            i.useBaseQuery)(e, n.InfiniteQueryObserver, t)
        }
    }
    ,
    45643: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            useQuery: () => s
        });
        var n = e.i(89582)
          , i = e.i(81893);
        function s(e, t) {
            return (0,
            i.useBaseQuery)(e, n.QueryObserver, t)
        }
    }
    ,
    72711: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        function n(e) {
            return e
        }
        function i(e) {
            return e.state.isPaused
        }
        function s(e) {
            return "success" === e.state.status
        }
        function a(e) {
            return !0
        }
        function o(e, t={}) {
            let r = t.shouldDehydrateMutation ?? e.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? i
              , l = e.getMutationCache().getAll().flatMap(e => r(e) ? [{
                mutationKey: e.options.mutationKey,
                state: e.state,
                ...e.options.scope && {
                    scope: e.options.scope
                },
                ...e.meta && {
                    meta: e.meta
                }
            }] : [])
              , u = t.shouldDehydrateQuery ?? e.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? s
              , h = t.shouldRedactErrors ?? e.getDefaultOptions().dehydrate?.shouldRedactErrors ?? a
              , c = t.serializeData ?? e.getDefaultOptions().dehydrate?.serializeData ?? n;
            return {
                mutations: l,
                queries: e.getQueryCache().getAll().flatMap(e => u(e) ? [{
                    state: {
                        ...e.state,
                        ...void 0 !== e.state.data && {
                            data: c(e.state.data)
                        }
                    },
                    queryKey: e.queryKey,
                    queryHash: e.queryHash,
                    ..."pending" === e.state.status && {
                        promise: e.promise?.then(c).catch(e => h(e) ? Promise.reject(Error("redacted")) : Promise.reject(e))
                    },
                    ...e.meta && {
                        meta: e.meta
                    }
                }] : [])
            }
        }
        function l(e, t, r) {
            if ("object" != typeof t || null === t)
                return;
            let i = e.getMutationCache()
              , s = e.getQueryCache()
              , a = r?.defaultOptions?.deserializeData ?? e.getDefaultOptions().hydrate?.deserializeData ?? n
              , o = t.mutations || []
              , l = t.queries || [];
            o.forEach( ({state: t, ...n}) => {
                i.build(e, {
                    ...e.getDefaultOptions().hydrate?.mutations,
                    ...r?.defaultOptions?.mutations,
                    ...n
                }, t)
            }
            ),
            l.forEach( ({queryKey: t, state: n, queryHash: i, meta: o, promise: l}) => {
                let u = s.get(i)
                  , h = void 0 === n.data ? n.data : a(n.data);
                if (u) {
                    if (u.state.dataUpdatedAt < n.dataUpdatedAt) {
                        let {fetchStatus: e, ...t} = n;
                        u.setState({
                            ...t,
                            data: h
                        })
                    }
                } else
                    u = s.build(e, {
                        ...e.getDefaultOptions().hydrate?.queries,
                        ...r?.defaultOptions?.queries,
                        queryKey: t,
                        queryHash: i,
                        meta: o
                    }, {
                        ...n,
                        data: h,
                        fetchStatus: "idle"
                    });
                if (l) {
                    let e = Promise.resolve(l).then(a);
                    u.fetch(void 0, {
                        initialPromise: e
                    })
                }
            }
            )
        }
        e.s({
            defaultShouldDehydrateMutation: () => i,
            defaultShouldDehydrateQuery: () => s,
            dehydrate: () => o,
            hydrate: () => l
        }),
        e.i(22271)
    }
    ,
    39747: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            persistQueryClient: () => u,
            persistQueryClientRestore: () => a,
            persistQueryClientSave: () => o,
            persistQueryClientSubscribe: () => l
        }),
        e.i(22271);
        var n = e.i(72711)
          , i = ["added", "removed", "updated"];
        function s(e) {
            return i.includes(e)
        }
        async function a({queryClient: e, persister: t, maxAge: r=864e5, buster: i="", hydrateOptions: s}) {
            try {
                let a = await t.restoreClient();
                if (a)
                    if (!a.timestamp)
                        return t.removeClient();
                    else {
                        let o = Date.now() - a.timestamp > r
                          , l = a.buster !== i;
                        if (o || l)
                            return t.removeClient();
                        (0,
                        n.hydrate)(e, a.clientState, s)
                    }
            } catch (e) {
                throw await t.removeClient(),
                e
            }
        }
        async function o({queryClient: e, persister: t, buster: r="", dehydrateOptions: i}) {
            let s = {
                buster: r,
                timestamp: Date.now(),
                clientState: (0,
                n.dehydrate)(e, i)
            };
            await t.persistClient(s)
        }
        function l(e) {
            let t = e.queryClient.getQueryCache().subscribe(t => {
                s(t.type) && o(e)
            }
            )
              , r = e.queryClient.getMutationCache().subscribe(t => {
                s(t.type) && o(e)
            }
            );
            return () => {
                t(),
                r()
            }
        }
        function u(e) {
            let t, r = !1;
            return [ () => {
                r = !0,
                t?.()
            }
            , a(e).then( () => {
                r || (t = l(e))
            }
            )]
        }
    }
    ,
    4546: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                getDefaultsFromPostinstall: () => t
            });
            let t = () => void 0
        }
    }
    ,
    81015: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                CONSTANTS: () => r,
                DecodeBase64StringError: () => ee,
                Deferred: () => ed,
                ErrorFactory: () => em,
                FirebaseError: () => eg,
                MAX_VALUE_MILLIS: () => eA,
                RANDOM_FACTOR: () => eD,
                Sha1: () => e_,
                areCookiesEnabled: () => x,
                assert: () => W,
                assertionError: () => J,
                async: () => U,
                base64: () => Z,
                base64Decode: () => en,
                base64Encode: () => et,
                base64urlEncodeWithoutPadding: () => er,
                calculateBackoffMillis: () => $,
                contains: () => k,
                createMockUserToken: () => h,
                createSubscribe: () => V,
                decode: () => ev,
                deepCopy: () => s,
                deepEqual: () => function e(t, r) {
                    if (t === r)
                        return !0;
                    let n = Object.keys(t)
                      , i = Object.keys(r);
                    for (let s of n) {
                        if (!i.includes(s))
                            return !1;
                        let n = t[s]
                          , a = r[s];
                        if (M(n) && M(a)) {
                            if (!e(n, a))
                                return !1
                        } else if (n !== a)
                            return !1
                    }
                    for (let e of i)
                        if (!n.includes(e))
                            return !1;
                    return !0
                }
                ,
                deepExtend: () => a,
                errorPrefix: () => j,
                extractQuerystring: () => B,
                getDefaultAppConfig: () => eh,
                getDefaultEmulatorHost: () => el,
                getDefaultEmulatorHostnameAndPort: () => eu,
                getDefaults: () => eo,
                getExperimentalSetting: () => ec,
                getGlobal: () => o,
                getModularInstance: () => H,
                getUA: () => d,
                isAdmin: () => eI,
                isBrowser: () => g,
                isBrowserExtension: () => v,
                isCloudWorkstation: () => l,
                isCloudflareWorker: () => y,
                isElectron: () => b,
                isEmpty: () => O,
                isIE: () => E,
                isIndexedDBAvailable: () => S,
                isMobileCordova: () => f,
                isNode: () => p,
                isNodeSdk: () => _,
                isReactNative: () => w,
                isSafari: () => T,
                isUWP: () => I,
                isValidFormat: () => eE,
                isValidTimestamp: () => ew,
                isWebWorker: () => m,
                issuedAtTime: () => eb,
                jsonEval: () => A,
                map: () => R,
                ordinal: () => G,
                pingServer: () => u,
                promiseWithTimeout: () => P,
                querystring: () => L,
                querystringDecode: () => F,
                safeGet: () => N,
                stringLength: () => ex,
                stringToByteArray: () => eC,
                stringify: () => D,
                updateEmulatorBanner: () => c,
                validateArgCount: () => eS,
                validateCallback: () => Q,
                validateContextObject: () => K,
                validateIndexedDBOpenable: () => C,
                validateNamespace: () => z
            });
            var n = e.i(22271)
              , i = e.i(4546);
            let r = {
                NODE_CLIENT: !1,
                NODE_ADMIN: !1,
                SDK_VERSION: "${JSCORE_VERSION}"
            }
              , W = function(e, t) {
                if (!e)
                    throw J(t)
            }
              , J = function(e) {
                return Error("Firebase Database (" + r.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + e)
            }
              , Y = function(e) {
                let t = []
                  , r = 0;
                for (let n = 0; n < e.length; n++) {
                    let i = e.charCodeAt(n);
                    i < 128 ? t[r++] = i : (i < 2048 ? t[r++] = i >> 6 | 192 : ((64512 & i) == 55296 && n + 1 < e.length && (64512 & e.charCodeAt(n + 1)) == 56320 ? (i = 65536 + ((1023 & i) << 10) + (1023 & e.charCodeAt(++n)),
                    t[r++] = i >> 18 | 240,
                    t[r++] = i >> 12 & 63 | 128) : t[r++] = i >> 12 | 224,
                    t[r++] = i >> 6 & 63 | 128),
                    t[r++] = 63 & i | 128)
                }
                return t
            }
              , X = function(e) {
                let t = []
                  , r = 0
                  , n = 0;
                for (; r < e.length; ) {
                    let i = e[r++];
                    if (i < 128)
                        t[n++] = String.fromCharCode(i);
                    else if (i > 191 && i < 224) {
                        let s = e[r++];
                        t[n++] = String.fromCharCode((31 & i) << 6 | 63 & s)
                    } else if (i > 239 && i < 365) {
                        let s = e[r++]
                          , a = ((7 & i) << 18 | (63 & s) << 12 | (63 & e[r++]) << 6 | 63 & e[r++]) - 65536;
                        t[n++] = String.fromCharCode(55296 + (a >> 10)),
                        t[n++] = String.fromCharCode(56320 + (1023 & a))
                    } else {
                        let s = e[r++]
                          , a = e[r++];
                        t[n++] = String.fromCharCode((15 & i) << 12 | (63 & s) << 6 | 63 & a)
                    }
                }
                return t.join("")
            }
              , Z = {
                byteToCharMap_: null,
                charToByteMap_: null,
                byteToCharMapWebSafe_: null,
                charToByteMapWebSafe_: null,
                ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                get ENCODED_VALS() {
                    return this.ENCODED_VALS_BASE + "+/="
                },
                get ENCODED_VALS_WEBSAFE() {
                    return this.ENCODED_VALS_BASE + "-_."
                },
                HAS_NATIVE_SUPPORT: "function" == typeof atob,
                encodeByteArray(e, t) {
                    if (!Array.isArray(e))
                        throw Error("encodeByteArray takes an array as a parameter");
                    this.init_();
                    let r = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_
                      , n = [];
                    for (let t = 0; t < e.length; t += 3) {
                        let i = e[t]
                          , s = t + 1 < e.length
                          , a = s ? e[t + 1] : 0
                          , o = t + 2 < e.length
                          , l = o ? e[t + 2] : 0
                          , u = i >> 2
                          , h = (3 & i) << 4 | a >> 4
                          , c = (15 & a) << 2 | l >> 6
                          , d = 63 & l;
                        !o && (d = 64,
                        s || (c = 64)),
                        n.push(r[u], r[h], r[c], r[d])
                    }
                    return n.join("")
                },
                encodeString(e, t) {
                    return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(Y(e), t)
                },
                decodeString(e, t) {
                    return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : X(this.decodeStringToByteArray(e, t))
                },
                decodeStringToByteArray(e, t) {
                    this.init_();
                    let r = t ? this.charToByteMapWebSafe_ : this.charToByteMap_
                      , n = [];
                    for (let t = 0; t < e.length; ) {
                        let i = r[e.charAt(t++)]
                          , s = t < e.length ? r[e.charAt(t)] : 0
                          , a = ++t < e.length ? r[e.charAt(t)] : 64
                          , o = ++t < e.length ? r[e.charAt(t)] : 64;
                        if (++t,
                        null == i || null == s || null == a || null == o)
                            throw new ee;
                        let l = i << 2 | s >> 4;
                        if (n.push(l),
                        64 !== a) {
                            let e = s << 4 & 240 | a >> 2;
                            if (n.push(e),
                            64 !== o) {
                                let e = a << 6 & 192 | o;
                                n.push(e)
                            }
                        }
                    }
                    return n
                },
                init_() {
                    if (!this.byteToCharMap_) {
                        this.byteToCharMap_ = {},
                        this.charToByteMap_ = {},
                        this.byteToCharMapWebSafe_ = {},
                        this.charToByteMapWebSafe_ = {};
                        for (let e = 0; e < this.ENCODED_VALS.length; e++)
                            this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e),
                            this.charToByteMap_[this.byteToCharMap_[e]] = e,
                            this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e),
                            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e,
                            e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e,
                            this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e)
                    }
                }
            };
            class ee extends Error {
                constructor() {
                    super(...arguments),
                    this.name = "DecodeBase64StringError"
                }
            }
            let et = function(e) {
                let t = Y(e);
                return Z.encodeByteArray(t, !0)
            }
              , er = function(e) {
                return et(e).replace(/\./g, "")
            }
              , en = function(e) {
                try {
                    return Z.decodeString(e, !0)
                } catch (e) {
                    console.error("base64Decode failed: ", e)
                }
                return null
            };
            function s(e) {
                return a(void 0, e)
            }
            function a(e, t) {
                if (!(t instanceof Object))
                    return t;
                switch (t.constructor) {
                case Date:
                    return new Date(t.getTime());
                case Object:
                    void 0 === e && (e = {});
                    break;
                case Array:
                    e = [];
                    break;
                default:
                    return t
                }
                for (let r in t)
                    t.hasOwnProperty(r) && "__proto__" !== r && (e[r] = a(e[r], t[r]));
                return e
            }
            function o() {
                if ("undefined" != typeof self)
                    return self;
                if ("undefined" != typeof window)
                    return window;
                if (void 0 !== t)
                    return t;
                throw Error("Unable to locate global object.")
            }
            let ei = () => o().__FIREBASE_DEFAULTS__
              , es = () => {
                if (void 0 === n.default || void 0 === n.default.env)
                    return;
                let e = n.default.env.__FIREBASE_DEFAULTS__;
                if (e)
                    return JSON.parse(e)
            }
              , ea = () => {
                let e;
                if ("undefined" == typeof document)
                    return;
                try {
                    e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
                } catch (e) {
                    return
                }
                let t = e && en(e[1]);
                return t && JSON.parse(t)
            }
              , eo = () => {
                try {
                    return (0,
                    i.getDefaultsFromPostinstall)() || ei() || es() || ea()
                } catch (e) {
                    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
                    return
                }
            }
              , el = e => {
                var t, r;
                return null == (r = null == (t = eo()) ? void 0 : t.emulatorHosts) ? void 0 : r[e]
            }
              , eu = e => {
                let t = el(e);
                if (!t)
                    return;
                let r = t.lastIndexOf(":");
                if (r <= 0 || r + 1 === t.length)
                    throw Error(`Invalid host ${t} with no separate hostname and port!`);
                let n = parseInt(t.substring(r + 1), 10);
                return "[" === t[0] ? [t.substring(1, r - 1), n] : [t.substring(0, r), n]
            }
              , eh = () => {
                var e;
                return null == (e = eo()) ? void 0 : e.config
            }
              , ec = e => {
                var t;
                return null == (t = eo()) ? void 0 : t[`_${e}`]
            }
            ;
            class ed {
                constructor() {
                    this.reject = () => {}
                    ,
                    this.resolve = () => {}
                    ,
                    this.promise = new Promise( (e, t) => {
                        this.resolve = e,
                        this.reject = t
                    }
                    )
                }
                wrapCallback(e) {
                    return (t, r) => {
                        t ? this.reject(t) : this.resolve(r),
                        "function" == typeof e && (this.promise.catch( () => {}
                        ),
                        1 === e.length ? e(t) : e(t, r))
                    }
                }
            }
            function l(e) {
                return e.endsWith(".cloudworkstations.dev")
            }
            async function u(e) {
                return (await fetch(e, {
                    credentials: "include"
                })).ok
            }
            function h(e, t) {
                if (e.uid)
                    throw Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
                let r = t || "demo-project"
                  , n = e.iat || 0
                  , i = e.sub || e.user_id;
                if (!i)
                    throw Error("mockUserToken must contain 'sub' or 'user_id' field!");
                let s = Object.assign({
                    iss: `https://securetoken.google.com/${r}`,
                    aud: r,
                    iat: n,
                    exp: n + 3600,
                    auth_time: n,
                    sub: i,
                    user_id: i,
                    firebase: {
                        sign_in_provider: "custom",
                        identities: {}
                    }
                }, e);
                return [er(JSON.stringify({
                    alg: "none",
                    type: "JWT"
                })), er(JSON.stringify(s)), ""].join(".")
            }
            let ef = {}
              , ep = !1;
            function c(e, t) {
                if ("undefined" == typeof window || "undefined" == typeof document || !l(window.location.host) || ef[e] === t || ef[e] || ep)
                    return;
                function r(e) {
                    return `__firebase__banner__${e}`
                }
                ef[e] = t;
                let n = "__firebase__banner"
                  , i = function() {
                    let e = {
                        prod: [],
                        emulator: []
                    };
                    for (let t of Object.keys(ef))
                        ef[t] ? e.emulator.push(t) : e.prod.push(t);
                    return e
                }().prod.length > 0;
                function s() {
                    let e, t, s = (e = document.getElementById(n),
                    t = !1,
                    e || ((e = document.createElement("div")).setAttribute("id", n),
                    t = !0),
                    {
                        created: t,
                        element: e
                    }), a = r("text"), o = document.getElementById(a) || document.createElement("span"), l = r("learnmore"), u = document.getElementById(l) || document.createElement("a"), h = r("preprendIcon"), c = document.getElementById(h) || document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    if (s.created) {
                        let e = s.element;
                        e.style.display = "flex",
                        e.style.background = "#7faaf0",
                        e.style.position = "fixed",
                        e.style.bottom = "5px",
                        e.style.left = "5px",
                        e.style.padding = ".5em",
                        e.style.borderRadius = "5px",
                        e.style.alignItems = "center",
                        u.setAttribute("id", l),
                        u.innerText = "Learn more",
                        u.href = "https://firebase.google.com/docs/studio/preview-apps#preview-backend",
                        u.setAttribute("target", "__blank"),
                        u.style.paddingLeft = "5px",
                        u.style.textDecoration = "underline";
                        let t = function() {
                            let e = document.createElement("span");
                            return e.style.cursor = "pointer",
                            e.style.marginLeft = "16px",
                            e.style.fontSize = "24px",
                            e.innerHTML = " &times;",
                            e.onclick = () => {
                                ep = !0;
                                let e = document.getElementById(n);
                                e && e.remove()
                            }
                            ,
                            e
                        }();
                        c.setAttribute("width", "24"),
                        c.setAttribute("id", h),
                        c.setAttribute("height", "24"),
                        c.setAttribute("viewBox", "0 0 24 24"),
                        c.setAttribute("fill", "none"),
                        c.style.marginLeft = "-6px",
                        e.append(c, o, u, t),
                        document.body.appendChild(e)
                    }
                    i ? (o.innerText = "Preview backend disconnected.",
                    c.innerHTML = `<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`) : (c.innerHTML = `<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`,
                    o.innerText = "Preview backend running in this workspace."),
                    o.setAttribute("id", a)
                }
                "loading" === document.readyState ? window.addEventListener("DOMContentLoaded", s) : s()
            }
            function d() {
                return "undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : ""
            }
            function f() {
                return "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(d())
            }
            function p() {
                var e;
                let r = null == (e = eo()) ? void 0 : e.forceEnvironment;
                if ("node" === r)
                    return !0;
                if ("browser" === r)
                    return !1;
                try {
                    return "[object process]" === Object.prototype.toString.call(t.process)
                } catch (e) {
                    return !1
                }
            }
            function g() {
                return "undefined" != typeof window || m()
            }
            function m() {
                return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope
            }
            function y() {
                return "undefined" != typeof navigator && "Cloudflare-Workers" === navigator.userAgent
            }
            function v() {
                let e = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0;
                return "object" == typeof e && void 0 !== e.id
            }
            function w() {
                return "object" == typeof navigator && "ReactNative" === navigator.product
            }
            function b() {
                return d().indexOf("Electron/") >= 0
            }
            function E() {
                let e = d();
                return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0
            }
            function I() {
                return d().indexOf("MSAppHost/") >= 0
            }
            function _() {
                return !0 === r.NODE_CLIENT || !0 === r.NODE_ADMIN
            }
            function T() {
                return !p() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
            }
            function S() {
                try {
                    return "object" == typeof indexedDB
                } catch (e) {
                    return !1
                }
            }
            function C() {
                return new Promise( (e, t) => {
                    try {
                        let r = !0
                          , n = "validate-browser-context-for-indexeddb-analytics-module"
                          , i = self.indexedDB.open(n);
                        i.onsuccess = () => {
                            i.result.close(),
                            r || self.indexedDB.deleteDatabase(n),
                            e(!0)
                        }
                        ,
                        i.onupgradeneeded = () => {
                            r = !1
                        }
                        ,
                        i.onerror = () => {
                            var e;
                            t((null == (e = i.error) ? void 0 : e.message) || "")
                        }
                    } catch (e) {
                        t(e)
                    }
                }
                )
            }
            function x() {
                return "undefined" != typeof navigator && !!navigator.cookieEnabled
            }
            class eg extends Error {
                constructor(e, t, r) {
                    super(t),
                    this.code = e,
                    this.customData = r,
                    this.name = "FirebaseError",
                    Object.setPrototypeOf(this, eg.prototype),
                    Error.captureStackTrace && Error.captureStackTrace(this, em.prototype.create)
                }
            }
            class em {
                constructor(e, t, r) {
                    this.service = e,
                    this.serviceName = t,
                    this.errors = r
                }
                create(e, ...t) {
                    var r, n;
                    let i = t[0] || {}
                      , s = `${this.service}/${e}`
                      , a = this.errors[e]
                      , o = a ? (r = a,
                    n = i,
                    r.replace(ey, (e, t) => {
                        let r = n[t];
                        return null != r ? String(r) : `<${t}?>`
                    }
                    )) : "Error"
                      , l = `${this.serviceName}: ${o} (${s}).`;
                    return new eg(s,l,i)
                }
            }
            let ey = /\{\$([^}]+)}/g;
            function A(e) {
                return JSON.parse(e)
            }
            function D(e) {
                return JSON.stringify(e)
            }
            let ev = function(e) {
                let t = {}
                  , r = {}
                  , n = {}
                  , i = "";
                try {
                    let s = e.split(".");
                    t = A(en(s[0]) || ""),
                    r = A(en(s[1]) || ""),
                    i = s[2],
                    n = r.d || {},
                    delete r.d
                } catch (e) {}
                return {
                    header: t,
                    claims: r,
                    data: n,
                    signature: i
                }
            }
              , ew = function(e) {
                let t = ev(e).claims
                  , r = Math.floor(new Date().getTime() / 1e3)
                  , n = 0
                  , i = 0;
                return "object" == typeof t && (t.hasOwnProperty("nbf") ? n = t.nbf : t.hasOwnProperty("iat") && (n = t.iat),
                i = t.hasOwnProperty("exp") ? t.exp : n + 86400),
                !!r && !!n && !!i && r >= n && r <= i
            }
              , eb = function(e) {
                let t = ev(e).claims;
                return "object" == typeof t && t.hasOwnProperty("iat") ? t.iat : null
            }
              , eE = function(e) {
                let t = ev(e).claims;
                return !!t && "object" == typeof t && t.hasOwnProperty("iat")
            }
              , eI = function(e) {
                let t = ev(e).claims;
                return "object" == typeof t && !0 === t.admin
            };
            function k(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }
            function N(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0
            }
            function O(e) {
                for (let t in e)
                    if (Object.prototype.hasOwnProperty.call(e, t))
                        return !1;
                return !0
            }
            function R(e, t, r) {
                let n = {};
                for (let i in e)
                    Object.prototype.hasOwnProperty.call(e, i) && (n[i] = t.call(r, e[i], i, e));
                return n
            }
            function M(e) {
                return null !== e && "object" == typeof e
            }
            function P(e, t=2e3) {
                let r = new ed;
                return setTimeout( () => r.reject("timeout!"), t),
                e.then(r.resolve, r.reject),
                r.promise
            }
            function L(e) {
                let t = [];
                for (let[r,n] of Object.entries(e))
                    Array.isArray(n) ? n.forEach(e => {
                        t.push(encodeURIComponent(r) + "=" + encodeURIComponent(e))
                    }
                    ) : t.push(encodeURIComponent(r) + "=" + encodeURIComponent(n));
                return t.length ? "&" + t.join("&") : ""
            }
            function F(e) {
                let t = {};
                return e.replace(/^\?/, "").split("&").forEach(e => {
                    if (e) {
                        let[r,n] = e.split("=");
                        t[decodeURIComponent(r)] = decodeURIComponent(n)
                    }
                }
                ),
                t
            }
            function B(e) {
                let t = e.indexOf("?");
                if (!t)
                    return "";
                let r = e.indexOf("#", t);
                return e.substring(t, r > 0 ? r : void 0)
            }
            class e_ {
                constructor() {
                    this.chain_ = [],
                    this.buf_ = [],
                    this.W_ = [],
                    this.pad_ = [],
                    this.inbuf_ = 0,
                    this.total_ = 0,
                    this.blockSize = 64,
                    this.pad_[0] = 128;
                    for (let e = 1; e < this.blockSize; ++e)
                        this.pad_[e] = 0;
                    this.reset()
                }
                reset() {
                    this.chain_[0] = 0x67452301,
                    this.chain_[1] = 0xefcdab89,
                    this.chain_[2] = 0x98badcfe,
                    this.chain_[3] = 0x10325476,
                    this.chain_[4] = 0xc3d2e1f0,
                    this.inbuf_ = 0,
                    this.total_ = 0
                }
                compress_(e, t) {
                    let r, n;
                    t || (t = 0);
                    let i = this.W_;
                    if ("string" == typeof e)
                        for (let r = 0; r < 16; r++)
                            i[r] = e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | e.charCodeAt(t + 3),
                            t += 4;
                    else
                        for (let r = 0; r < 16; r++)
                            i[r] = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3],
                            t += 4;
                    for (let e = 16; e < 80; e++) {
                        let t = i[e - 3] ^ i[e - 8] ^ i[e - 14] ^ i[e - 16];
                        i[e] = t << 1 | t >>> 31
                    }
                    let s = this.chain_[0]
                      , a = this.chain_[1]
                      , o = this.chain_[2]
                      , l = this.chain_[3]
                      , u = this.chain_[4];
                    for (let e = 0; e < 80; e++) {
                        e < 40 ? e < 20 ? (r = l ^ a & (o ^ l),
                        n = 0x5a827999) : (r = a ^ o ^ l,
                        n = 0x6ed9eba1) : e < 60 ? (r = a & o | l & (a | o),
                        n = 0x8f1bbcdc) : (r = a ^ o ^ l,
                        n = 0xca62c1d6);
                        let t = (s << 5 | s >>> 27) + r + u + n + i[e] | 0;
                        u = l,
                        l = o,
                        o = a << 30 | a >>> 2,
                        a = s,
                        s = t
                    }
                    this.chain_[0] = this.chain_[0] + s | 0,
                    this.chain_[1] = this.chain_[1] + a | 0,
                    this.chain_[2] = this.chain_[2] + o | 0,
                    this.chain_[3] = this.chain_[3] + l | 0,
                    this.chain_[4] = this.chain_[4] + u | 0
                }
                update(e, t) {
                    if (null == e)
                        return;
                    void 0 === t && (t = e.length);
                    let r = t - this.blockSize
                      , n = 0
                      , i = this.buf_
                      , s = this.inbuf_;
                    for (; n < t; ) {
                        if (0 === s)
                            for (; n <= r; )
                                this.compress_(e, n),
                                n += this.blockSize;
                        if ("string" == typeof e) {
                            for (; n < t; )
                                if (i[s] = e.charCodeAt(n),
                                ++s,
                                ++n,
                                s === this.blockSize) {
                                    this.compress_(i),
                                    s = 0;
                                    break
                                }
                        } else
                            for (; n < t; )
                                if (i[s] = e[n],
                                ++s,
                                ++n,
                                s === this.blockSize) {
                                    this.compress_(i),
                                    s = 0;
                                    break
                                }
                    }
                    this.inbuf_ = s,
                    this.total_ += t
                }
                digest() {
                    let e = []
                      , t = 8 * this.total_;
                    this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
                    for (let e = this.blockSize - 1; e >= 56; e--)
                        this.buf_[e] = 255 & t,
                        t /= 256;
                    this.compress_(this.buf_);
                    let r = 0;
                    for (let t = 0; t < 5; t++)
                        for (let n = 24; n >= 0; n -= 8)
                            e[r] = this.chain_[t] >> n & 255,
                            ++r;
                    return e
                }
            }
            function V(e, t) {
                let r = new eT(e,t);
                return r.subscribe.bind(r)
            }
            class eT {
                constructor(e, t) {
                    this.observers = [],
                    this.unsubscribes = [],
                    this.observerCount = 0,
                    this.task = Promise.resolve(),
                    this.finalized = !1,
                    this.onNoObservers = t,
                    this.task.then( () => {
                        e(this)
                    }
                    ).catch(e => {
                        this.error(e)
                    }
                    )
                }
                next(e) {
                    this.forEachObserver(t => {
                        t.next(e)
                    }
                    )
                }
                error(e) {
                    this.forEachObserver(t => {
                        t.error(e)
                    }
                    ),
                    this.close(e)
                }
                complete() {
                    this.forEachObserver(e => {
                        e.complete()
                    }
                    ),
                    this.close()
                }
                subscribe(e, t, r) {
                    let n;
                    if (void 0 === e && void 0 === t && void 0 === r)
                        throw Error("Missing Observer.");
                    void 0 === (n = !function(e, t) {
                        if ("object" != typeof e || null === e)
                            return !1;
                        for (let r of t)
                            if (r in e && "function" == typeof e[r])
                                return !0;
                        return !1
                    }(e, ["next", "error", "complete"]) ? {
                        next: e,
                        error: t,
                        complete: r
                    } : e).next && (n.next = q),
                    void 0 === n.error && (n.error = q),
                    void 0 === n.complete && (n.complete = q);
                    let i = this.unsubscribeOne.bind(this, this.observers.length);
                    return this.finalized && this.task.then( () => {
                        try {
                            this.finalError ? n.error(this.finalError) : n.complete()
                        } catch (e) {}
                    }
                    ),
                    this.observers.push(n),
                    i
                }
                unsubscribeOne(e) {
                    void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e],
                    this.observerCount -= 1,
                    0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this))
                }
                forEachObserver(e) {
                    if (!this.finalized)
                        for (let t = 0; t < this.observers.length; t++)
                            this.sendOne(t, e)
                }
                sendOne(e, t) {
                    this.task.then( () => {
                        if (void 0 !== this.observers && void 0 !== this.observers[e])
                            try {
                                t(this.observers[e])
                            } catch (e) {
                                "undefined" != typeof console && console.error && console.error(e)
                            }
                    }
                    )
                }
                close(e) {
                    this.finalized || (this.finalized = !0,
                    void 0 !== e && (this.finalError = e),
                    this.task.then( () => {
                        this.observers = void 0,
                        this.onNoObservers = void 0
                    }
                    ))
                }
            }
            function U(e, t) {
                return (...r) => {
                    Promise.resolve(!0).then( () => {
                        e(...r)
                    }
                    ).catch(e => {
                        t && t(e)
                    }
                    )
                }
            }
            function q() {}
            let eS = function(e, t, r, n) {
                let i;
                if (n < t ? i = "at least " + t : n > r && (i = 0 === r ? "none" : "no more than " + r),
                i)
                    throw Error(e + " failed: Was called with " + n + (1 === n ? " argument." : " arguments.") + " Expects " + i + ".")
            };
            function j(e, t) {
                return `${e} failed: ${t} argument `
            }
            function z(e, t, r) {
                if ((!r || t) && "string" != typeof t)
                    throw Error(j(e, "namespace") + "must be a valid firebase namespace.")
            }
            function Q(e, t, r, n) {
                if ((!n || r) && "function" != typeof r)
                    throw Error(j(e, t) + "must be a valid function.")
            }
            function K(e, t, r, n) {
                if ((!n || r) && ("object" != typeof r || null === r))
                    throw Error(j(e, t) + "must be a valid context object.")
            }
            let eC = function(e) {
                let t = []
                  , r = 0;
                for (let n = 0; n < e.length; n++) {
                    let i = e.charCodeAt(n);
                    if (i >= 55296 && i <= 56319) {
                        let t = i - 55296;
                        W(++n < e.length, "Surrogate pair missing trail surrogate."),
                        i = 65536 + (t << 10) + (e.charCodeAt(n) - 56320)
                    }
                    i < 128 ? t[r++] = i : (i < 2048 ? t[r++] = i >> 6 | 192 : (i < 65536 ? t[r++] = i >> 12 | 224 : (t[r++] = i >> 18 | 240,
                    t[r++] = i >> 12 & 63 | 128),
                    t[r++] = i >> 6 & 63 | 128),
                    t[r++] = 63 & i | 128)
                }
                return t
            }
              , ex = function(e) {
                let t = 0;
                for (let r = 0; r < e.length; r++) {
                    let n = e.charCodeAt(r);
                    n < 128 ? t++ : n < 2048 ? t += 2 : n >= 55296 && n <= 56319 ? (t += 4,
                    r++) : t += 3
                }
                return t
            }
              , eA = 144e5
              , eD = .5;
            function $(e, t=1e3, r=2) {
                let n = t * Math.pow(r, e)
                  , i = Math.round(eD * n * (Math.random() - .5) * 2);
                return Math.min(eA, n + i)
            }
            function G(e) {
                return Number.isFinite(e) ? e + function(e) {
                    let t = (e = Math.abs(e)) % 100;
                    if (t >= 10 && t <= 20)
                        return "th";
                    let r = e % 10;
                    return 1 === r ? "st" : 2 === r ? "nd" : 3 === r ? "rd" : "th"
                }(e) : `${e}`
            }
            function H(e) {
                return e && e._delegate ? e._delegate : e
            }
        }
    }
    ,
    42289: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                Component: () => t,
                ComponentContainer: () => s,
                Provider: () => i
            });
            var n = e.i(81015);
            class t {
                constructor(e, t, r) {
                    this.name = e,
                    this.instanceFactory = t,
                    this.type = r,
                    this.multipleInstances = !1,
                    this.serviceProps = {},
                    this.instantiationMode = "LAZY",
                    this.onInstanceCreated = null
                }
                setInstantiationMode(e) {
                    return this.instantiationMode = e,
                    this
                }
                setMultipleInstances(e) {
                    return this.multipleInstances = e,
                    this
                }
                setServiceProps(e) {
                    return this.serviceProps = e,
                    this
                }
                setInstanceCreatedCallback(e) {
                    return this.onInstanceCreated = e,
                    this
                }
            }
            let r = "[DEFAULT]";
            class i {
                constructor(e, t) {
                    this.name = e,
                    this.container = t,
                    this.component = null,
                    this.instances = new Map,
                    this.instancesDeferred = new Map,
                    this.instancesOptions = new Map,
                    this.onInitCallbacks = new Map
                }
                get(e) {
                    let t = this.normalizeInstanceIdentifier(e);
                    if (!this.instancesDeferred.has(t)) {
                        let e = new n.Deferred;
                        if (this.instancesDeferred.set(t, e),
                        this.isInitialized(t) || this.shouldAutoInitialize())
                            try {
                                let r = this.getOrInitializeService({
                                    instanceIdentifier: t
                                });
                                r && e.resolve(r)
                            } catch (e) {}
                    }
                    return this.instancesDeferred.get(t).promise
                }
                getImmediate(e) {
                    var t;
                    let r = this.normalizeInstanceIdentifier(null == e ? void 0 : e.identifier)
                      , n = null != (t = null == e ? void 0 : e.optional) && t;
                    if (this.isInitialized(r) || this.shouldAutoInitialize())
                        try {
                            return this.getOrInitializeService({
                                instanceIdentifier: r
                            })
                        } catch (e) {
                            if (n)
                                return null;
                            throw e
                        }
                    if (n)
                        return null;
                    throw Error(`Service ${this.name} is not available`)
                }
                getComponent() {
                    return this.component
                }
                setComponent(e) {
                    if (e.name !== this.name)
                        throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
                    if (this.component)
                        throw Error(`Component for ${this.name} has already been provided`);
                    if (this.component = e,
                    this.shouldAutoInitialize()) {
                        if ("EAGER" === e.instantiationMode)
                            try {
                                this.getOrInitializeService({
                                    instanceIdentifier: r
                                })
                            } catch (e) {}
                        for (let[e,t] of this.instancesDeferred.entries()) {
                            let r = this.normalizeInstanceIdentifier(e);
                            try {
                                let e = this.getOrInitializeService({
                                    instanceIdentifier: r
                                });
                                t.resolve(e)
                            } catch (e) {}
                        }
                    }
                }
                clearInstance(e=r) {
                    this.instancesDeferred.delete(e),
                    this.instancesOptions.delete(e),
                    this.instances.delete(e)
                }
                async delete() {
                    let e = Array.from(this.instances.values());
                    await Promise.all([...e.filter(e => "INTERNAL"in e).map(e => e.INTERNAL.delete()), ...e.filter(e => "_delete"in e).map(e => e._delete())])
                }
                isComponentSet() {
                    return null != this.component
                }
                isInitialized(e=r) {
                    return this.instances.has(e)
                }
                getOptions(e=r) {
                    return this.instancesOptions.get(e) || {}
                }
                initialize(e={}) {
                    let {options: t={}} = e
                      , r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
                    if (this.isInitialized(r))
                        throw Error(`${this.name}(${r}) has already been initialized`);
                    if (!this.isComponentSet())
                        throw Error(`Component ${this.name} has not been registered yet`);
                    let n = this.getOrInitializeService({
                        instanceIdentifier: r,
                        options: t
                    });
                    for (let[e,t] of this.instancesDeferred.entries())
                        r === this.normalizeInstanceIdentifier(e) && t.resolve(n);
                    return n
                }
                onInit(e, t) {
                    var r;
                    let n = this.normalizeInstanceIdentifier(t)
                      , i = null != (r = this.onInitCallbacks.get(n)) ? r : new Set;
                    i.add(e),
                    this.onInitCallbacks.set(n, i);
                    let s = this.instances.get(n);
                    return s && e(s, n),
                    () => {
                        i.delete(e)
                    }
                }
                invokeOnInitCallbacks(e, t) {
                    let r = this.onInitCallbacks.get(t);
                    if (r)
                        for (let n of r)
                            try {
                                n(e, t)
                            } catch (e) {}
                }
                getOrInitializeService({instanceIdentifier: e, options: t={}}) {
                    var n;
                    let i = this.instances.get(e);
                    if (!i && this.component && (i = this.component.instanceFactory(this.container, {
                        instanceIdentifier: (n = e) === r ? void 0 : n,
                        options: t
                    }),
                    this.instances.set(e, i),
                    this.instancesOptions.set(e, t),
                    this.invokeOnInitCallbacks(i, e),
                    this.component.onInstanceCreated))
                        try {
                            this.component.onInstanceCreated(this.container, e, i)
                        } catch (e) {}
                    return i || null
                }
                normalizeInstanceIdentifier(e=r) {
                    return this.component ? this.component.multipleInstances ? e : r : e
                }
                shouldAutoInitialize() {
                    return !!this.component && "EXPLICIT" !== this.component.instantiationMode
                }
            }
            class s {
                constructor(e) {
                    this.name = e,
                    this.providers = new Map
                }
                addComponent(e) {
                    let t = this.getProvider(e.name);
                    if (t.isComponentSet())
                        throw Error(`Component ${e.name} has already been registered with ${this.name}`);
                    t.setComponent(e)
                }
                addOrOverwriteComponent(e) {
                    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name),
                    this.addComponent(e)
                }
                getProvider(e) {
                    if (this.providers.has(e))
                        return this.providers.get(e);
                    let t = new i(e,this);
                    return this.providers.set(e, t),
                    t
                }
                getProviders() {
                    return Array.from(this.providers.values())
                }
            }
        }
    }
    ,
    94083: e => {
        "use strict";
        var t, {g: r, __dirname: n} = e;
        {
            e.s({
                LogLevel: () => t,
                Logger: () => u,
                setLogLevel: () => i,
                setUserLogHandler: () => s
            });
            let r = [];
            !function(e) {
                e[e.DEBUG = 0] = "DEBUG",
                e[e.VERBOSE = 1] = "VERBOSE",
                e[e.INFO = 2] = "INFO",
                e[e.WARN = 3] = "WARN",
                e[e.ERROR = 4] = "ERROR",
                e[e.SILENT = 5] = "SILENT"
            }(t || (t = {}));
            let n = {
                debug: t.DEBUG,
                verbose: t.VERBOSE,
                info: t.INFO,
                warn: t.WARN,
                error: t.ERROR,
                silent: t.SILENT
            }
              , a = t.INFO
              , o = {
                [t.DEBUG]: "log",
                [t.VERBOSE]: "log",
                [t.INFO]: "info",
                [t.WARN]: "warn",
                [t.ERROR]: "error"
            }
              , l = (e, t, ...r) => {
                if (t < e.logLevel)
                    return;
                let n = new Date().toISOString()
                  , i = o[t];
                if (i)
                    console[i](`[${n}]  ${e.name}:`, ...r);
                else
                    throw Error(`Attempted to log a message with an invalid logType (value: ${t})`)
            }
            ;
            class u {
                constructor(e) {
                    this.name = e,
                    this._logLevel = a,
                    this._logHandler = l,
                    this._userLogHandler = null,
                    r.push(this)
                }
                get logLevel() {
                    return this._logLevel
                }
                set logLevel(e) {
                    if (!(e in t))
                        throw TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
                    this._logLevel = e
                }
                setLogLevel(e) {
                    this._logLevel = "string" == typeof e ? n[e] : e
                }
                get logHandler() {
                    return this._logHandler
                }
                set logHandler(e) {
                    if ("function" != typeof e)
                        throw TypeError("Value assigned to `logHandler` must be a function");
                    this._logHandler = e
                }
                get userLogHandler() {
                    return this._userLogHandler
                }
                set userLogHandler(e) {
                    this._userLogHandler = e
                }
                debug(...e) {
                    this._userLogHandler && this._userLogHandler(this, t.DEBUG, ...e),
                    this._logHandler(this, t.DEBUG, ...e)
                }
                log(...e) {
                    this._userLogHandler && this._userLogHandler(this, t.VERBOSE, ...e),
                    this._logHandler(this, t.VERBOSE, ...e)
                }
                info(...e) {
                    this._userLogHandler && this._userLogHandler(this, t.INFO, ...e),
                    this._logHandler(this, t.INFO, ...e)
                }
                warn(...e) {
                    this._userLogHandler && this._userLogHandler(this, t.WARN, ...e),
                    this._logHandler(this, t.WARN, ...e)
                }
                error(...e) {
                    this._userLogHandler && this._userLogHandler(this, t.ERROR, ...e),
                    this._logHandler(this, t.ERROR, ...e)
                }
            }
            function i(e) {
                r.forEach(t => {
                    t.setLogLevel(e)
                }
                )
            }
            function s(e, i) {
                for (let s of r) {
                    let r = null;
                    i && i.level && (r = n[i.level]),
                    null === e ? s.userLogHandler = null : s.userLogHandler = (n, i, ...s) => {
                        let a = s.map(e => {
                            if (null == e)
                                return null;
                            if ("string" == typeof e)
                                return e;
                            if ("number" == typeof e || "boolean" == typeof e)
                                return e.toString();
                            if (e instanceof Error)
                                return e.message;
                            try {
                                return JSON.stringify(e)
                            } catch (e) {
                                return null
                            }
                        }
                        ).filter(e => e).join(" ");
                        i >= (null != r ? r : n.logLevel) && e({
                            level: t[i].toLowerCase(),
                            message: a,
                            args: s,
                            type: n.name
                        })
                    }
                }
            }
        }
    }
    ,
    48226: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            let t, r;
            e.s({
                a: () => h,
                i: () => s,
                r: () => n,
                u: () => d,
                w: () => i
            });
            let s = (e, t) => t.some(t => e instanceof t)
              , a = new WeakMap
              , o = new WeakMap
              , l = new WeakMap
              , u = new WeakMap
              , h = new WeakMap
              , c = {
                get(e, t, r) {
                    if (e instanceof IDBTransaction) {
                        if ("done" === t)
                            return o.get(e);
                        if ("objectStoreNames" === t)
                            return e.objectStoreNames || l.get(e);
                        if ("store" === t)
                            return r.objectStoreNames[1] ? void 0 : r.objectStore(r.objectStoreNames[0])
                    }
                    return i(e[t])
                },
                set: (e, t, r) => (e[t] = r,
                !0),
                has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e
            };
            function n(e) {
                c = e(c)
            }
            function i(e) {
                if (e instanceof IDBRequest) {
                    let t = new Promise( (t, r) => {
                        let n = () => {
                            e.removeEventListener("success", s),
                            e.removeEventListener("error", a)
                        }
                          , s = () => {
                            t(i(e.result)),
                            n()
                        }
                          , a = () => {
                            r(e.error),
                            n()
                        }
                        ;
                        e.addEventListener("success", s),
                        e.addEventListener("error", a)
                    }
                    );
                    return t.then(t => {
                        t instanceof IDBCursor && a.set(t, e)
                    }
                    ).catch( () => {}
                    ),
                    h.set(t, e),
                    t
                }
                if (u.has(e))
                    return u.get(e);
                let n = function(e) {
                    if ("function" == typeof e)
                        return e !== IDBDatabase.prototype.transaction || "objectStoreNames"in IDBTransaction.prototype ? (r || (r = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function(...t) {
                            return e.apply(d(this), t),
                            i(a.get(this))
                        }
                        : function(...t) {
                            return i(e.apply(d(this), t))
                        }
                        : function(t, ...r) {
                            let n = e.call(d(this), t, ...r);
                            return l.set(n, t.sort ? t.sort() : [t]),
                            i(n)
                        }
                        ;
                    return (e instanceof IDBTransaction && function(e) {
                        if (o.has(e))
                            return;
                        let t = new Promise( (t, r) => {
                            let n = () => {
                                e.removeEventListener("complete", i),
                                e.removeEventListener("error", s),
                                e.removeEventListener("abort", s)
                            }
                              , i = () => {
                                t(),
                                n()
                            }
                              , s = () => {
                                r(e.error || new DOMException("AbortError","AbortError")),
                                n()
                            }
                            ;
                            e.addEventListener("complete", i),
                            e.addEventListener("error", s),
                            e.addEventListener("abort", s)
                        }
                        );
                        o.set(e, t)
                    }(e),
                    s(e, t || (t = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]))) ? new Proxy(e,c) : e
                }(e);
                return n !== e && (u.set(e, n),
                h.set(n, e)),
                n
            }
            let d = e => h.get(e)
        }
    }
    ,
    50739: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                deleteDB: () => s,
                openDB: () => i
            });
            var n = e.i(48226);
            function i(e, t, {blocked: r, upgrade: s, blocking: a, terminated: o}={}) {
                let l = indexedDB.open(e, t)
                  , u = (0,
                n.w)(l);
                return s && l.addEventListener("upgradeneeded", e => {
                    s((0,
                    n.w)(l.result), e.oldVersion, e.newVersion, (0,
                    n.w)(l.transaction), e)
                }
                ),
                r && l.addEventListener("blocked", e => r(e.oldVersion, e.newVersion, e)),
                u.then(e => {
                    o && e.addEventListener("close", () => o()),
                    a && e.addEventListener("versionchange", e => a(e.oldVersion, e.newVersion, e))
                }
                ).catch( () => {}
                ),
                u
            }
            function s(e, {blocked: t}={}) {
                let r = indexedDB.deleteDatabase(e);
                return t && r.addEventListener("blocked", e => t(e.oldVersion, e)),
                (0,
                n.w)(r).then( () => void 0)
            }
            let t = ["get", "getKey", "getAll", "getAllKeys", "count"]
              , r = ["put", "add", "delete", "clear"]
              , o = new Map;
            function a(e, n) {
                if (!(e instanceof IDBDatabase && !(n in e) && "string" == typeof n))
                    return;
                if (o.get(n))
                    return o.get(n);
                let i = n.replace(/FromIndex$/, "")
                  , s = n !== i
                  , a = r.includes(i);
                if (!(i in (s ? IDBIndex : IDBObjectStore).prototype) || !(a || t.includes(i)))
                    return;
                let l = async function(e, ...t) {
                    let r = this.transaction(e, a ? "readwrite" : "readonly")
                      , n = r.store;
                    return s && (n = n.index(t.shift())),
                    (await Promise.all([n[i](...t), a && r.done]))[0]
                };
                return o.set(n, l),
                l
            }
            (0,
            n.r)(e => ({
                ...e,
                get: (t, r, n) => a(t, r) || e.get(t, r, n),
                has: (t, r) => !!a(t, r) || e.has(t, r)
            }))
        }
    }
    ,
    13580: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({}),
        e.i(48226),
        e.i(50739)
    }
    ,
    94334: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                SDK_VERSION: () => U,
                _DEFAULT_ENTRY_NAME: () => O,
                _addComponent: () => o,
                _addOrOverwriteComponent: () => l,
                _apps: () => M,
                _clearComponents: () => p,
                _components: () => L,
                _getProvider: () => h,
                _isFirebaseApp: () => d,
                _isFirebaseServerApp: () => f,
                _registerComponent: () => u,
                _removeServiceInstance: () => c,
                _serverApps: () => P,
                deleteApp: () => b,
                getApp: () => v,
                getApps: () => w,
                initializeApp: () => m,
                initializeServerApp: () => y,
                onLog: () => I,
                registerVersion: () => E,
                setLogLevel: () => _
            });
            var n = e.i(42289)
              , i = e.i(94083)
              , s = e.i(81015);
            e.i(13580);
            var a = e.i(50739);
            class t {
                constructor(e) {
                    this.container = e
                }
                getPlatformInfoString() {
                    return this.container.getProviders().map(e => {
                        if (!function(e) {
                            let t = e.getComponent();
                            return (null == t ? void 0 : t.type) === "VERSION"
                        }(e))
                            return null;
                        {
                            let t = e.getImmediate();
                            return `${t.library}/${t.version}`
                        }
                    }
                    ).filter(e => e).join(" ")
                }
            }
            let r = "@firebase/app"
              , k = "0.12.3"
              , N = new i.Logger("@firebase/app")
              , O = "[DEFAULT]"
              , R = {
                [r]: "fire-core",
                "@firebase/app-compat": "fire-core-compat",
                "@firebase/analytics": "fire-analytics",
                "@firebase/analytics-compat": "fire-analytics-compat",
                "@firebase/app-check": "fire-app-check",
                "@firebase/app-check-compat": "fire-app-check-compat",
                "@firebase/auth": "fire-auth",
                "@firebase/auth-compat": "fire-auth-compat",
                "@firebase/database": "fire-rtdb",
                "@firebase/data-connect": "fire-data-connect",
                "@firebase/database-compat": "fire-rtdb-compat",
                "@firebase/functions": "fire-fn",
                "@firebase/functions-compat": "fire-fn-compat",
                "@firebase/installations": "fire-iid",
                "@firebase/installations-compat": "fire-iid-compat",
                "@firebase/messaging": "fire-fcm",
                "@firebase/messaging-compat": "fire-fcm-compat",
                "@firebase/performance": "fire-perf",
                "@firebase/performance-compat": "fire-perf-compat",
                "@firebase/remote-config": "fire-rc",
                "@firebase/remote-config-compat": "fire-rc-compat",
                "@firebase/storage": "fire-gcs",
                "@firebase/storage-compat": "fire-gcs-compat",
                "@firebase/firestore": "fire-fst",
                "@firebase/firestore-compat": "fire-fst-compat",
                "@firebase/vertexai": "fire-vertex",
                "fire-js": "fire-js",
                firebase: "fire-js-all"
            }
              , M = new Map
              , P = new Map
              , L = new Map;
            function o(e, t) {
                try {
                    e.container.addComponent(t)
                } catch (r) {
                    N.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, r)
                }
            }
            function l(e, t) {
                e.container.addOrOverwriteComponent(t)
            }
            function u(e) {
                let t = e.name;
                if (L.has(t))
                    return N.debug(`There were multiple attempts to register component ${t}.`),
                    !1;
                for (let r of (L.set(t, e),
                M.values()))
                    o(r, e);
                for (let t of P.values())
                    o(t, e);
                return !0
            }
            function h(e, t) {
                let r = e.container.getProvider("heartbeat").getImmediate({
                    optional: !0
                });
                return r && r.triggerHeartbeat(),
                e.container.getProvider(t)
            }
            function c(e, t, r=O) {
                h(e, t).clearInstance(r)
            }
            function d(e) {
                return void 0 !== e.options
            }
            function f(e) {
                return null != e && void 0 !== e.settings
            }
            function p() {
                L.clear()
            }
            let F = new s.ErrorFactory("app","Firebase",{
                "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
                "bad-app-name": "Illegal App name: '{$appName}'",
                "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
                "app-deleted": "Firebase App named '{$appName}' already deleted",
                "server-app-deleted": "Firebase Server App has been deleted",
                "no-options": "Need to provide options, when not being deployed to hosting via source.",
                "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
                "invalid-log-argument": "First argument to `onLog` must be null or a function.",
                "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
                "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
                "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
                "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
                "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
                "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
            });
            class B {
                constructor(e, t, r) {
                    this._isDeleted = !1,
                    this._options = Object.assign({}, e),
                    this._config = Object.assign({}, t),
                    this._name = t.name,
                    this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled,
                    this._container = r,
                    this.container.addComponent(new n.Component("app", () => this,"PUBLIC"))
                }
                get automaticDataCollectionEnabled() {
                    return this.checkDestroyed(),
                    this._automaticDataCollectionEnabled
                }
                set automaticDataCollectionEnabled(e) {
                    this.checkDestroyed(),
                    this._automaticDataCollectionEnabled = e
                }
                get name() {
                    return this.checkDestroyed(),
                    this._name
                }
                get options() {
                    return this.checkDestroyed(),
                    this._options
                }
                get config() {
                    return this.checkDestroyed(),
                    this._config
                }
                get container() {
                    return this._container
                }
                get isDeleted() {
                    return this._isDeleted
                }
                set isDeleted(e) {
                    this._isDeleted = e
                }
                checkDestroyed() {
                    if (this.isDeleted)
                        throw F.create("app-deleted", {
                            appName: this._name
                        })
                }
            }
            function g(e, t) {
                let r = (0,
                s.base64Decode)(e.split(".")[1]);
                if (null === r)
                    return void console.error(`FirebaseServerApp ${t} is invalid: second part could not be parsed.`);
                if (void 0 === JSON.parse(r).exp)
                    return void console.error(`FirebaseServerApp ${t} is invalid: expiration claim could not be parsed`);
                let n = 1e3 * JSON.parse(r).exp;
                n - new Date().getTime() <= 0 && console.error(`FirebaseServerApp ${t} is invalid: the token has expired.`)
            }
            class V extends B {
                constructor(e, t, n, i) {
                    let s = void 0 !== t.automaticDataCollectionEnabled && t.automaticDataCollectionEnabled
                      , a = {
                        name: n,
                        automaticDataCollectionEnabled: s
                    };
                    void 0 !== e.apiKey ? super(e, a, i) : super(e.options, a, i),
                    this._serverConfig = Object.assign({
                        automaticDataCollectionEnabled: s
                    }, t),
                    this._serverConfig.authIdToken && g(this._serverConfig.authIdToken, "authIdToken"),
                    this._serverConfig.appCheckToken && g(this._serverConfig.appCheckToken, "appCheckToken"),
                    this._finalizationRegistry = null,
                    "undefined" != typeof FinalizationRegistry && (this._finalizationRegistry = new FinalizationRegistry( () => {
                        this.automaticCleanup()
                    }
                    )),
                    this._refCount = 0,
                    this.incRefCount(this._serverConfig.releaseOnDeref),
                    this._serverConfig.releaseOnDeref = void 0,
                    t.releaseOnDeref = void 0,
                    E(r, k, "serverapp")
                }
                toJSON() {}
                get refCount() {
                    return this._refCount
                }
                incRefCount(e) {
                    this.isDeleted || (this._refCount++,
                    void 0 !== e && null !== this._finalizationRegistry && this._finalizationRegistry.register(e, this))
                }
                decRefCount() {
                    return this.isDeleted ? 0 : --this._refCount
                }
                automaticCleanup() {
                    b(this)
                }
                get settings() {
                    return this.checkDestroyed(),
                    this._serverConfig
                }
                checkDestroyed() {
                    if (this.isDeleted)
                        throw F.create("server-app-deleted")
                }
            }
            let U = "11.7.3";
            function m(e, t={}) {
                let r = e;
                "object" != typeof t && (t = {
                    name: t
                });
                let i = Object.assign({
                    name: O,
                    automaticDataCollectionEnabled: !1
                }, t)
                  , a = i.name;
                if ("string" != typeof a || !a)
                    throw F.create("bad-app-name", {
                        appName: String(a)
                    });
                if (r || (r = (0,
                s.getDefaultAppConfig)()),
                !r)
                    throw F.create("no-options");
                let o = M.get(a);
                if (o)
                    if ((0,
                    s.deepEqual)(r, o.options) && (0,
                    s.deepEqual)(i, o.config))
                        return o;
                    else
                        throw F.create("duplicate-app", {
                            appName: a
                        });
                let l = new n.ComponentContainer(a);
                for (let e of L.values())
                    l.addComponent(e);
                let u = new B(r,i,l);
                return M.set(a, u),
                u
            }
            function y(e, t) {
                let r;
                if ((0,
                s.isBrowser)() && !(0,
                s.isWebWorker)())
                    throw F.create("invalid-server-app-environment");
                void 0 === t.automaticDataCollectionEnabled && (t.automaticDataCollectionEnabled = !1),
                r = d(e) ? e.options : e;
                let i = Object.assign(Object.assign({}, t), r);
                if (void 0 !== i.releaseOnDeref && delete i.releaseOnDeref,
                void 0 !== t.releaseOnDeref && "undefined" == typeof FinalizationRegistry)
                    throw F.create("finalization-registry-not-supported", {});
                let a = "" + [...JSON.stringify(i)].reduce( (e, t) => Math.imul(31, e) + t.charCodeAt(0) | 0, 0)
                  , o = P.get(a);
                if (o)
                    return o.incRefCount(t.releaseOnDeref),
                    o;
                let l = new n.ComponentContainer(a);
                for (let e of L.values())
                    l.addComponent(e);
                let u = new V(r,t,a,l);
                return P.set(a, u),
                u
            }
            function v(e=O) {
                let t = M.get(e);
                if (!t && e === O && (0,
                s.getDefaultAppConfig)())
                    return m();
                if (!t)
                    throw F.create("no-app", {
                        appName: e
                    });
                return t
            }
            function w() {
                return Array.from(M.values())
            }
            async function b(e) {
                let t = !1
                  , r = e.name;
                M.has(r) ? (t = !0,
                M.delete(r)) : P.has(r) && 0 >= e.decRefCount() && (P.delete(r),
                t = !0),
                t && (await Promise.all(e.container.getProviders().map(e => e.delete())),
                e.isDeleted = !0)
            }
            function E(e, t, r) {
                var i;
                let s = null != (i = R[e]) ? i : e;
                r && (s += `-${r}`);
                let a = s.match(/\s|\//)
                  , o = t.match(/\s|\//);
                if (a || o) {
                    let e = [`Unable to register library "${s}" with version "${t}":`];
                    a && e.push(`library name "${s}" contains illegal characters (whitespace or "/")`),
                    a && o && e.push("and"),
                    o && e.push(`version name "${t}" contains illegal characters (whitespace or "/")`),
                    N.warn(e.join(" "));
                    return
                }
                u(new n.Component(`${s}-version`, () => ({
                    library: s,
                    version: t
                }),"VERSION"))
            }
            function I(e, t) {
                if (null !== e && "function" != typeof e)
                    throw F.create("invalid-log-argument");
                (0,
                i.setUserLogHandler)(e, t)
            }
            function _(e) {
                (0,
                i.setLogLevel)(e)
            }
            let q = "firebase-heartbeat-store"
              , j = null;
            function T() {
                return j || (j = (0,
                a.openDB)("firebase-heartbeat-database", 1, {
                    upgrade: (e, t) => {
                        if (0 === t)
                            try {
                                e.createObjectStore(q)
                            } catch (e) {
                                console.warn(e)
                            }
                    }
                }).catch(e => {
                    throw F.create("idb-open", {
                        originalErrorMessage: e.message
                    })
                }
                )),
                j
            }
            async function S(e) {
                try {
                    let t = (await T()).transaction(q)
                      , r = await t.objectStore(q).get(x(e));
                    return await t.done,
                    r
                } catch (e) {
                    if (e instanceof s.FirebaseError)
                        N.warn(e.message);
                    else {
                        let t = F.create("idb-get", {
                            originalErrorMessage: null == e ? void 0 : e.message
                        });
                        N.warn(t.message)
                    }
                }
            }
            async function C(e, t) {
                try {
                    let r = (await T()).transaction(q, "readwrite")
                      , n = r.objectStore(q);
                    await n.put(t, x(e)),
                    await r.done
                } catch (e) {
                    if (e instanceof s.FirebaseError)
                        N.warn(e.message);
                    else {
                        let t = F.create("idb-set", {
                            originalErrorMessage: null == e ? void 0 : e.message
                        });
                        N.warn(t.message)
                    }
                }
            }
            function x(e) {
                return `${e.name}!${e.options.appId}`
            }
            class z {
                constructor(e) {
                    this.container = e,
                    this._heartbeatsCache = null;
                    let t = this.container.getProvider("app").getImmediate();
                    this._storage = new Q(t),
                    this._heartbeatsCachePromise = this._storage.read().then(e => (this._heartbeatsCache = e,
                    e))
                }
                async triggerHeartbeat() {
                    var e, t;
                    try {
                        let r = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString()
                          , n = A();
                        if ((null == (e = this._heartbeatsCache) ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise,
                        (null == (t = this._heartbeatsCache) ? void 0 : t.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === n || this._heartbeatsCache.heartbeats.some(e => e.date === n))
                            return;
                        if (this._heartbeatsCache.heartbeats.push({
                            date: n,
                            agent: r
                        }),
                        this._heartbeatsCache.heartbeats.length > 30) {
                            let e = function(e) {
                                if (0 === e.length)
                                    return -1;
                                let t = 0
                                  , r = e[0].date;
                                for (let n = 1; n < e.length; n++)
                                    e[n].date < r && (r = e[n].date,
                                    t = n);
                                return t
                            }(this._heartbeatsCache.heartbeats);
                            this._heartbeatsCache.heartbeats.splice(e, 1)
                        }
                        return this._storage.overwrite(this._heartbeatsCache)
                    } catch (e) {
                        N.warn(e)
                    }
                }
                async getHeartbeatsHeader() {
                    var e;
                    try {
                        if (null === this._heartbeatsCache && await this._heartbeatsCachePromise,
                        (null == (e = this._heartbeatsCache) ? void 0 : e.heartbeats) == null || 0 === this._heartbeatsCache.heartbeats.length)
                            return "";
                        let t = A()
                          , {heartbeatsToSend: r, unsentEntries: n} = function(e, t=1024) {
                            let r = []
                              , n = e.slice();
                            for (let i of e) {
                                let e = r.find(e => e.agent === i.agent);
                                if (e) {
                                    if (e.dates.push(i.date),
                                    D(r) > t) {
                                        e.dates.pop();
                                        break
                                    }
                                } else if (r.push({
                                    agent: i.agent,
                                    dates: [i.date]
                                }),
                                D(r) > t) {
                                    r.pop();
                                    break
                                }
                                n = n.slice(1)
                            }
                            return {
                                heartbeatsToSend: r,
                                unsentEntries: n
                            }
                        }(this._heartbeatsCache.heartbeats)
                          , i = (0,
                        s.base64urlEncodeWithoutPadding)(JSON.stringify({
                            version: 2,
                            heartbeats: r
                        }));
                        return this._heartbeatsCache.lastSentHeartbeatDate = t,
                        n.length > 0 ? (this._heartbeatsCache.heartbeats = n,
                        await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [],
                        this._storage.overwrite(this._heartbeatsCache)),
                        i
                    } catch (e) {
                        return N.warn(e),
                        ""
                    }
                }
            }
            function A() {
                return new Date().toISOString().substring(0, 10)
            }
            class Q {
                constructor(e) {
                    this.app = e,
                    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
                }
                async runIndexedDBEnvironmentCheck() {
                    return !!(0,
                    s.isIndexedDBAvailable)() && (0,
                    s.validateIndexedDBOpenable)().then( () => !0).catch( () => !1)
                }
                async read() {
                    if (!await this._canUseIndexedDBPromise)
                        return {
                            heartbeats: []
                        };
                    {
                        let e = await S(this.app);
                        return (null == e ? void 0 : e.heartbeats) ? e : {
                            heartbeats: []
                        }
                    }
                }
                async overwrite(e) {
                    var t;
                    if (await this._canUseIndexedDBPromise) {
                        let r = await this.read();
                        return C(this.app, {
                            lastSentHeartbeatDate: null != (t = e.lastSentHeartbeatDate) ? t : r.lastSentHeartbeatDate,
                            heartbeats: e.heartbeats
                        })
                    }
                }
                async add(e) {
                    var t;
                    if (await this._canUseIndexedDBPromise) {
                        let r = await this.read();
                        return C(this.app, {
                            lastSentHeartbeatDate: null != (t = e.lastSentHeartbeatDate) ? t : r.lastSentHeartbeatDate,
                            heartbeats: [...r.heartbeats, ...e.heartbeats]
                        })
                    }
                }
            }
            function D(e) {
                return (0,
                s.base64urlEncodeWithoutPadding)(JSON.stringify({
                    version: 2,
                    heartbeats: e
                })).length
            }
            u(new n.Component("platform-logger",e => new t(e),"PRIVATE")),
            u(new n.Component("heartbeat",e => new z(e),"PRIVATE")),
            E(r, k, ""),
            E(r, k, "esm2017"),
            E("fire-js", "")
        }
    }
    ,
    33661: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({}),
        e.i(42289),
        e.i(94083),
        e.i(81015),
        e.i(13580),
        e.i(94334)
    }
    ,
    14667: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({}),
        e.i(33661),
        (0,
        e.i(94334).registerVersion)("firebase", "11.7.3", "app")
    }
    ,
    62728: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({}),
        e.i(33661),
        e.i(14667)
    }
    ,
    9562: function(e) {
        var {g: t, __dirname: r, m: n, e: i} = e
          , s = {
            675: function(e, t) {
                "use strict";
                t.byteLength = function(e) {
                    var t = l(e)
                      , r = t[0]
                      , n = t[1];
                    return (r + n) * 3 / 4 - n
                }
                ,
                t.toByteArray = function(e) {
                    var t, r, s = l(e), a = s[0], o = s[1], u = new i((a + o) * 3 / 4 - o), h = 0, c = o > 0 ? a - 4 : a;
                    for (r = 0; r < c; r += 4)
                        t = n[e.charCodeAt(r)] << 18 | n[e.charCodeAt(r + 1)] << 12 | n[e.charCodeAt(r + 2)] << 6 | n[e.charCodeAt(r + 3)],
                        u[h++] = t >> 16 & 255,
                        u[h++] = t >> 8 & 255,
                        u[h++] = 255 & t;
                    return 2 === o && (t = n[e.charCodeAt(r)] << 2 | n[e.charCodeAt(r + 1)] >> 4,
                    u[h++] = 255 & t),
                    1 === o && (t = n[e.charCodeAt(r)] << 10 | n[e.charCodeAt(r + 1)] << 4 | n[e.charCodeAt(r + 2)] >> 2,
                    u[h++] = t >> 8 & 255,
                    u[h++] = 255 & t),
                    u
                }
                ,
                t.fromByteArray = function(e) {
                    for (var t, n = e.length, i = n % 3, s = [], a = 0, o = n - i; a < o; a += 16383)
                        s.push(function(e, t, n) {
                            for (var i, s = [], a = t; a < n; a += 3)
                                i = (e[a] << 16 & 0xff0000) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]),
                                s.push(r[i >> 18 & 63] + r[i >> 12 & 63] + r[i >> 6 & 63] + r[63 & i]);
                            return s.join("")
                        }(e, a, a + 16383 > o ? o : a + 16383));
                    return 1 === i ? s.push(r[(t = e[n - 1]) >> 2] + r[t << 4 & 63] + "==") : 2 === i && s.push(r[(t = (e[n - 2] << 8) + e[n - 1]) >> 10] + r[t >> 4 & 63] + r[t << 2 & 63] + "="),
                    s.join("")
                }
                ;
                for (var r = [], n = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, o = s.length; a < o; ++a)
                    r[a] = s[a],
                    n[s.charCodeAt(a)] = a;
                function l(e) {
                    var t = e.length;
                    if (t % 4 > 0)
                        throw Error("Invalid string. Length must be a multiple of 4");
                    var r = e.indexOf("=");
                    -1 === r && (r = t);
                    var n = r === t ? 0 : 4 - r % 4;
                    return [r, n]
                }
                n[45] = 62,
                n[95] = 63
            },
            72: function(e, t, r) {
                "use strict";
                var n = r(675)
                  , i = r(783)
                  , s = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
                function a(e) {
                    if (e > 0x7fffffff)
                        throw RangeError('The value "' + e + '" is invalid for option "size"');
                    var t = new Uint8Array(e);
                    return Object.setPrototypeOf(t, o.prototype),
                    t
                }
                function o(e, t, r) {
                    if ("number" == typeof e) {
                        if ("string" == typeof t)
                            throw TypeError('The "string" argument must be of type string. Received type number');
                        return h(e)
                    }
                    return l(e, t, r)
                }
                function l(e, t, r) {
                    if ("string" == typeof e) {
                        var n = e
                          , i = t;
                        if (("string" != typeof i || "" === i) && (i = "utf8"),
                        !o.isEncoding(i))
                            throw TypeError("Unknown encoding: " + i);
                        var s = 0 | f(n, i)
                          , l = a(s)
                          , u = l.write(n, i);
                        return u !== s && (l = l.slice(0, u)),
                        l
                    }
                    if (ArrayBuffer.isView(e))
                        return c(e);
                    if (null == e)
                        throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                    if (D(e, ArrayBuffer) || e && D(e.buffer, ArrayBuffer) || "undefined" != typeof SharedArrayBuffer && (D(e, SharedArrayBuffer) || e && D(e.buffer, SharedArrayBuffer)))
                        return function(e, t, r) {
                            var n;
                            if (t < 0 || e.byteLength < t)
                                throw RangeError('"offset" is outside of buffer bounds');
                            if (e.byteLength < t + (r || 0))
                                throw RangeError('"length" is outside of buffer bounds');
                            return Object.setPrototypeOf(n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e,t) : new Uint8Array(e,t,r), o.prototype),
                            n
                        }(e, t, r);
                    if ("number" == typeof e)
                        throw TypeError('The "value" argument must not be of type number. Received type number');
                    var h = e.valueOf && e.valueOf();
                    if (null != h && h !== e)
                        return o.from(h, t, r);
                    var p = function(e) {
                        if (o.isBuffer(e)) {
                            var t = 0 | d(e.length)
                              , r = a(t);
                            return 0 === r.length || e.copy(r, 0, 0, t),
                            r
                        }
                        return void 0 !== e.length ? "number" != typeof e.length || function(e) {
                            return e != e
                        }(e.length) ? a(0) : c(e) : "Buffer" === e.type && Array.isArray(e.data) ? c(e.data) : void 0
                    }(e);
                    if (p)
                        return p;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive])
                        return o.from(e[Symbol.toPrimitive]("string"), t, r);
                    throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
                }
                function u(e) {
                    if ("number" != typeof e)
                        throw TypeError('"size" argument must be of type number');
                    if (e < 0)
                        throw RangeError('The value "' + e + '" is invalid for option "size"')
                }
                function h(e) {
                    return u(e),
                    a(e < 0 ? 0 : 0 | d(e))
                }
                function c(e) {
                    for (var t = e.length < 0 ? 0 : 0 | d(e.length), r = a(t), n = 0; n < t; n += 1)
                        r[n] = 255 & e[n];
                    return r
                }
                t.Buffer = o,
                t.SlowBuffer = function(e) {
                    return +e != e && (e = 0),
                    o.alloc(+e)
                }
                ,
                t.INSPECT_MAX_BYTES = 50,
                t.kMaxLength = 0x7fffffff,
                o.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        var e = new Uint8Array(1)
                          , t = {
                            foo: function() {
                                return 42
                            }
                        };
                        return Object.setPrototypeOf(t, Uint8Array.prototype),
                        Object.setPrototypeOf(e, t),
                        42 === e.foo()
                    } catch (e) {
                        return !1
                    }
                }(),
                o.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
                Object.defineProperty(o.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (o.isBuffer(this))
                            return this.buffer
                    }
                }),
                Object.defineProperty(o.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (o.isBuffer(this))
                            return this.byteOffset
                    }
                }),
                o.poolSize = 8192,
                o.from = function(e, t, r) {
                    return l(e, t, r)
                }
                ,
                Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
                Object.setPrototypeOf(o, Uint8Array),
                o.alloc = function(e, t, r) {
                    return (u(e),
                    e <= 0) ? a(e) : void 0 !== t ? "string" == typeof r ? a(e).fill(t, r) : a(e).fill(t) : a(e)
                }
                ,
                o.allocUnsafe = function(e) {
                    return h(e)
                }
                ,
                o.allocUnsafeSlow = function(e) {
                    return h(e)
                }
                ;
                function d(e) {
                    if (e >= 0x7fffffff)
                        throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes");
                    return 0 | e
                }
                function f(e, t) {
                    if (o.isBuffer(e))
                        return e.length;
                    if (ArrayBuffer.isView(e) || D(e, ArrayBuffer))
                        return e.byteLength;
                    if ("string" != typeof e)
                        throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                    var r = e.length
                      , n = arguments.length > 2 && !0 === arguments[2];
                    if (!n && 0 === r)
                        return 0;
                    for (var i = !1; ; )
                        switch (t) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return r;
                        case "utf8":
                        case "utf-8":
                            return S(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * r;
                        case "hex":
                            return r >>> 1;
                        case "base64":
                            return x(e).length;
                        default:
                            if (i)
                                return n ? -1 : S(e).length;
                            t = ("" + t).toLowerCase(),
                            i = !0
                        }
                }
                function p(e, t, r) {
                    var i, s, a, o = !1;
                    if ((void 0 === t || t < 0) && (t = 0),
                    t > this.length || ((void 0 === r || r > this.length) && (r = this.length),
                    r <= 0 || (r >>>= 0) <= (t >>>= 0)))
                        return "";
                    for (e || (e = "utf8"); ; )
                        switch (e) {
                        case "hex":
                            return function(e, t, r) {
                                var n = e.length;
                                (!t || t < 0) && (t = 0),
                                (!r || r < 0 || r > n) && (r = n);
                                for (var i = "", s = t; s < r; ++s)
                                    i += k[e[s]];
                                return i
                            }(this, t, r);
                        case "utf8":
                        case "utf-8":
                            return v(this, t, r);
                        case "ascii":
                            return function(e, t, r) {
                                var n = "";
                                r = Math.min(e.length, r);
                                for (var i = t; i < r; ++i)
                                    n += String.fromCharCode(127 & e[i]);
                                return n
                            }(this, t, r);
                        case "latin1":
                        case "binary":
                            return function(e, t, r) {
                                var n = "";
                                r = Math.min(e.length, r);
                                for (var i = t; i < r; ++i)
                                    n += String.fromCharCode(e[i]);
                                return n
                            }(this, t, r);
                        case "base64":
                            return i = this,
                            s = t,
                            a = r,
                            0 === s && a === i.length ? n.fromByteArray(i) : n.fromByteArray(i.slice(s, a));
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return function(e, t, r) {
                                for (var n = e.slice(t, r), i = "", s = 0; s < n.length; s += 2)
                                    i += String.fromCharCode(n[s] + 256 * n[s + 1]);
                                return i
                            }(this, t, r);
                        default:
                            if (o)
                                throw TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase(),
                            o = !0
                        }
                }
                function g(e, t, r) {
                    var n = e[t];
                    e[t] = e[r],
                    e[r] = n
                }
                function m(e, t, r, n, i) {
                    var s;
                    if (0 === e.length)
                        return -1;
                    if ("string" == typeof r ? (n = r,
                    r = 0) : r > 0x7fffffff ? r = 0x7fffffff : r < -0x80000000 && (r = -0x80000000),
                    (s = r *= 1) != s && (r = i ? 0 : e.length - 1),
                    r < 0 && (r = e.length + r),
                    r >= e.length)
                        if (i)
                            return -1;
                        else
                            r = e.length - 1;
                    else if (r < 0)
                        if (!i)
                            return -1;
                        else
                            r = 0;
                    if ("string" == typeof t && (t = o.from(t, n)),
                    o.isBuffer(t))
                        return 0 === t.length ? -1 : y(e, t, r, n, i);
                    if ("number" == typeof t) {
                        if (t &= 255,
                        "function" == typeof Uint8Array.prototype.indexOf)
                            if (i)
                                return Uint8Array.prototype.indexOf.call(e, t, r);
                            else
                                return Uint8Array.prototype.lastIndexOf.call(e, t, r);
                        return y(e, [t], r, n, i)
                    }
                    throw TypeError("val must be string, number or Buffer")
                }
                function y(e, t, r, n, i) {
                    var s, a = 1, o = e.length, l = t.length;
                    if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                        if (e.length < 2 || t.length < 2)
                            return -1;
                        a = 2,
                        o /= 2,
                        l /= 2,
                        r /= 2
                    }
                    function u(e, t) {
                        return 1 === a ? e[t] : e.readUInt16BE(t * a)
                    }
                    if (i) {
                        var h = -1;
                        for (s = r; s < o; s++)
                            if (u(e, s) === u(t, -1 === h ? 0 : s - h)) {
                                if (-1 === h && (h = s),
                                s - h + 1 === l)
                                    return h * a
                            } else
                                -1 !== h && (s -= s - h),
                                h = -1
                    } else
                        for (r + l > o && (r = o - l),
                        s = r; s >= 0; s--) {
                            for (var c = !0, d = 0; d < l; d++)
                                if (u(e, s + d) !== u(t, d)) {
                                    c = !1;
                                    break
                                }
                            if (c)
                                return s
                        }
                    return -1
                }
                o.isBuffer = function(e) {
                    return null != e && !0 === e._isBuffer && e !== o.prototype
                }
                ,
                o.compare = function(e, t) {
                    if (D(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
                    D(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
                    !o.isBuffer(e) || !o.isBuffer(t))
                        throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (e === t)
                        return 0;
                    for (var r = e.length, n = t.length, i = 0, s = Math.min(r, n); i < s; ++i)
                        if (e[i] !== t[i]) {
                            r = e[i],
                            n = t[i];
                            break
                        }
                    return r < n ? -1 : +(n < r)
                }
                ,
                o.isEncoding = function(e) {
                    switch (String(e).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                    }
                }
                ,
                o.concat = function(e, t) {
                    if (!Array.isArray(e))
                        throw TypeError('"list" argument must be an Array of Buffers');
                    if (0 === e.length)
                        return o.alloc(0);
                    if (void 0 === t)
                        for (r = 0,
                        t = 0; r < e.length; ++r)
                            t += e[r].length;
                    var r, n = o.allocUnsafe(t), i = 0;
                    for (r = 0; r < e.length; ++r) {
                        var s = e[r];
                        if (D(s, Uint8Array) && (s = o.from(s)),
                        !o.isBuffer(s))
                            throw TypeError('"list" argument must be an Array of Buffers');
                        s.copy(n, i),
                        i += s.length
                    }
                    return n
                }
                ,
                o.byteLength = f,
                o.prototype._isBuffer = !0,
                o.prototype.swap16 = function() {
                    var e = this.length;
                    if (e % 2 != 0)
                        throw RangeError("Buffer size must be a multiple of 16-bits");
                    for (var t = 0; t < e; t += 2)
                        g(this, t, t + 1);
                    return this
                }
                ,
                o.prototype.swap32 = function() {
                    var e = this.length;
                    if (e % 4 != 0)
                        throw RangeError("Buffer size must be a multiple of 32-bits");
                    for (var t = 0; t < e; t += 4)
                        g(this, t, t + 3),
                        g(this, t + 1, t + 2);
                    return this
                }
                ,
                o.prototype.swap64 = function() {
                    var e = this.length;
                    if (e % 8 != 0)
                        throw RangeError("Buffer size must be a multiple of 64-bits");
                    for (var t = 0; t < e; t += 8)
                        g(this, t, t + 7),
                        g(this, t + 1, t + 6),
                        g(this, t + 2, t + 5),
                        g(this, t + 3, t + 4);
                    return this
                }
                ,
                o.prototype.toString = function() {
                    var e = this.length;
                    return 0 === e ? "" : 0 == arguments.length ? v(this, 0, e) : p.apply(this, arguments)
                }
                ,
                o.prototype.toLocaleString = o.prototype.toString,
                o.prototype.equals = function(e) {
                    if (!o.isBuffer(e))
                        throw TypeError("Argument must be a Buffer");
                    return this === e || 0 === o.compare(this, e)
                }
                ,
                o.prototype.inspect = function() {
                    var e = ""
                      , r = t.INSPECT_MAX_BYTES;
                    return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(),
                    this.length > r && (e += " ... "),
                    "<Buffer " + e + ">"
                }
                ,
                s && (o.prototype[s] = o.prototype.inspect),
                o.prototype.compare = function(e, t, r, n, i) {
                    if (D(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
                    !o.isBuffer(e))
                        throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                    if (void 0 === t && (t = 0),
                    void 0 === r && (r = e ? e.length : 0),
                    void 0 === n && (n = 0),
                    void 0 === i && (i = this.length),
                    t < 0 || r > e.length || n < 0 || i > this.length)
                        throw RangeError("out of range index");
                    if (n >= i && t >= r)
                        return 0;
                    if (n >= i)
                        return -1;
                    if (t >= r)
                        return 1;
                    if (t >>>= 0,
                    r >>>= 0,
                    n >>>= 0,
                    i >>>= 0,
                    this === e)
                        return 0;
                    for (var s = i - n, a = r - t, l = Math.min(s, a), u = this.slice(n, i), h = e.slice(t, r), c = 0; c < l; ++c)
                        if (u[c] !== h[c]) {
                            s = u[c],
                            a = h[c];
                            break
                        }
                    return s < a ? -1 : +(a < s)
                }
                ,
                o.prototype.includes = function(e, t, r) {
                    return -1 !== this.indexOf(e, t, r)
                }
                ,
                o.prototype.indexOf = function(e, t, r) {
                    return m(this, e, t, r, !0)
                }
                ,
                o.prototype.lastIndexOf = function(e, t, r) {
                    return m(this, e, t, r, !1)
                }
                ;
                function v(e, t, r) {
                    r = Math.min(e.length, r);
                    for (var n = [], i = t; i < r; ) {
                        var s, a, o, l, u = e[i], h = null, c = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
                        if (i + c <= r)
                            switch (c) {
                            case 1:
                                u < 128 && (h = u);
                                break;
                            case 2:
                                (192 & (s = e[i + 1])) == 128 && (l = (31 & u) << 6 | 63 & s) > 127 && (h = l);
                                break;
                            case 3:
                                s = e[i + 1],
                                a = e[i + 2],
                                (192 & s) == 128 && (192 & a) == 128 && (l = (15 & u) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (l < 55296 || l > 57343) && (h = l);
                                break;
                            case 4:
                                s = e[i + 1],
                                a = e[i + 2],
                                o = e[i + 3],
                                (192 & s) == 128 && (192 & a) == 128 && (192 & o) == 128 && (l = (15 & u) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) > 65535 && l < 1114112 && (h = l)
                            }
                        null === h ? (h = 65533,
                        c = 1) : h > 65535 && (h -= 65536,
                        n.push(h >>> 10 & 1023 | 55296),
                        h = 56320 | 1023 & h),
                        n.push(h),
                        i += c
                    }
                    var d = n
                      , f = d.length;
                    if (f <= 4096)
                        return String.fromCharCode.apply(String, d);
                    for (var p = "", g = 0; g < f; )
                        p += String.fromCharCode.apply(String, d.slice(g, g += 4096));
                    return p
                }
                function w(e, t, r) {
                    if (e % 1 != 0 || e < 0)
                        throw RangeError("offset is not uint");
                    if (e + t > r)
                        throw RangeError("Trying to access beyond buffer length")
                }
                function b(e, t, r, n, i, s) {
                    if (!o.isBuffer(e))
                        throw TypeError('"buffer" argument must be a Buffer instance');
                    if (t > i || t < s)
                        throw RangeError('"value" argument is out of bounds');
                    if (r + n > e.length)
                        throw RangeError("Index out of range")
                }
                function E(e, t, r, n, i, s) {
                    if (r + n > e.length || r < 0)
                        throw RangeError("Index out of range")
                }
                function I(e, t, r, n, s) {
                    return t *= 1,
                    r >>>= 0,
                    s || E(e, t, r, 4, 34028234663852886e22, -34028234663852886e22),
                    i.write(e, t, r, n, 23, 4),
                    r + 4
                }
                function _(e, t, r, n, s) {
                    return t *= 1,
                    r >>>= 0,
                    s || E(e, t, r, 8, 17976931348623157e292, -17976931348623157e292),
                    i.write(e, t, r, n, 52, 8),
                    r + 8
                }
                o.prototype.write = function(e, t, r, n) {
                    if (void 0 === t)
                        n = "utf8",
                        r = this.length,
                        t = 0;
                    else if (void 0 === r && "string" == typeof t)
                        n = t,
                        r = this.length,
                        t = 0;
                    else if (isFinite(t))
                        t >>>= 0,
                        isFinite(r) ? (r >>>= 0,
                        void 0 === n && (n = "utf8")) : (n = r,
                        r = void 0);
                    else
                        throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    var i, s, a, o, l, u, h, c, d = this.length - t;
                    if ((void 0 === r || r > d) && (r = d),
                    e.length > 0 && (r < 0 || t < 0) || t > this.length)
                        throw RangeError("Attempt to write outside buffer bounds");
                    n || (n = "utf8");
                    for (var f = !1; ; )
                        switch (n) {
                        case "hex":
                            return function(e, t, r, n) {
                                r = Number(r) || 0;
                                var i = e.length - r;
                                n ? (n = Number(n)) > i && (n = i) : n = i;
                                var s = t.length;
                                n > s / 2 && (n = s / 2);
                                for (var a = 0; a < n; ++a) {
                                    var o, l = parseInt(t.substr(2 * a, 2), 16);
                                    if ((o = l) != o)
                                        break;
                                    e[r + a] = l
                                }
                                return a
                            }(this, e, t, r);
                        case "utf8":
                        case "utf-8":
                            return i = t,
                            s = r,
                            A(S(e, this.length - i), this, i, s);
                        case "ascii":
                            return a = t,
                            o = r,
                            A(C(e), this, a, o);
                        case "latin1":
                        case "binary":
                            return function(e, t, r, n) {
                                return A(C(t), e, r, n)
                            }(this, e, t, r);
                        case "base64":
                            return l = t,
                            u = r,
                            A(x(e), this, l, u);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return h = t,
                            c = r,
                            A(function(e, t) {
                                for (var r, n, i = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)
                                    n = (r = e.charCodeAt(s)) >> 8,
                                    i.push(r % 256),
                                    i.push(n);
                                return i
                            }(e, this.length - h), this, h, c);
                        default:
                            if (f)
                                throw TypeError("Unknown encoding: " + n);
                            n = ("" + n).toLowerCase(),
                            f = !0
                        }
                }
                ,
                o.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                }
                ,
                o.prototype.slice = function(e, t) {
                    var r = this.length;
                    e = ~~e,
                    t = void 0 === t ? r : ~~t,
                    e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
                    t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
                    t < e && (t = e);
                    var n = this.subarray(e, t);
                    return Object.setPrototypeOf(n, o.prototype),
                    n
                }
                ,
                o.prototype.readUIntLE = function(e, t, r) {
                    e >>>= 0,
                    t >>>= 0,
                    r || w(e, t, this.length);
                    for (var n = this[e], i = 1, s = 0; ++s < t && (i *= 256); )
                        n += this[e + s] * i;
                    return n
                }
                ,
                o.prototype.readUIntBE = function(e, t, r) {
                    e >>>= 0,
                    t >>>= 0,
                    r || w(e, t, this.length);
                    for (var n = this[e + --t], i = 1; t > 0 && (i *= 256); )
                        n += this[e + --t] * i;
                    return n
                }
                ,
                o.prototype.readUInt8 = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 1, this.length),
                    this[e]
                }
                ,
                o.prototype.readUInt16LE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 2, this.length),
                    this[e] | this[e + 1] << 8
                }
                ,
                o.prototype.readUInt16BE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 2, this.length),
                    this[e] << 8 | this[e + 1]
                }
                ,
                o.prototype.readUInt32LE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 4, this.length),
                    (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 0x1000000 * this[e + 3]
                }
                ,
                o.prototype.readUInt32BE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 4, this.length),
                    0x1000000 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
                }
                ,
                o.prototype.readIntLE = function(e, t, r) {
                    e >>>= 0,
                    t >>>= 0,
                    r || w(e, t, this.length);
                    for (var n = this[e], i = 1, s = 0; ++s < t && (i *= 256); )
                        n += this[e + s] * i;
                    return n >= (i *= 128) && (n -= Math.pow(2, 8 * t)),
                    n
                }
                ,
                o.prototype.readIntBE = function(e, t, r) {
                    e >>>= 0,
                    t >>>= 0,
                    r || w(e, t, this.length);
                    for (var n = t, i = 1, s = this[e + --n]; n > 0 && (i *= 256); )
                        s += this[e + --n] * i;
                    return s >= (i *= 128) && (s -= Math.pow(2, 8 * t)),
                    s
                }
                ,
                o.prototype.readInt8 = function(e, t) {
                    return (e >>>= 0,
                    t || w(e, 1, this.length),
                    128 & this[e]) ? -((255 - this[e] + 1) * 1) : this[e]
                }
                ,
                o.prototype.readInt16LE = function(e, t) {
                    e >>>= 0,
                    t || w(e, 2, this.length);
                    var r = this[e] | this[e + 1] << 8;
                    return 32768 & r ? 0xffff0000 | r : r
                }
                ,
                o.prototype.readInt16BE = function(e, t) {
                    e >>>= 0,
                    t || w(e, 2, this.length);
                    var r = this[e + 1] | this[e] << 8;
                    return 32768 & r ? 0xffff0000 | r : r
                }
                ,
                o.prototype.readInt32LE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 4, this.length),
                    this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
                }
                ,
                o.prototype.readInt32BE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 4, this.length),
                    this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
                }
                ,
                o.prototype.readFloatLE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 4, this.length),
                    i.read(this, e, !0, 23, 4)
                }
                ,
                o.prototype.readFloatBE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 4, this.length),
                    i.read(this, e, !1, 23, 4)
                }
                ,
                o.prototype.readDoubleLE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 8, this.length),
                    i.read(this, e, !0, 52, 8)
                }
                ,
                o.prototype.readDoubleBE = function(e, t) {
                    return e >>>= 0,
                    t || w(e, 8, this.length),
                    i.read(this, e, !1, 52, 8)
                }
                ,
                o.prototype.writeUIntLE = function(e, t, r, n) {
                    if (e *= 1,
                    t >>>= 0,
                    r >>>= 0,
                    !n) {
                        var i = Math.pow(2, 8 * r) - 1;
                        b(this, e, t, r, i, 0)
                    }
                    var s = 1
                      , a = 0;
                    for (this[t] = 255 & e; ++a < r && (s *= 256); )
                        this[t + a] = e / s & 255;
                    return t + r
                }
                ,
                o.prototype.writeUIntBE = function(e, t, r, n) {
                    if (e *= 1,
                    t >>>= 0,
                    r >>>= 0,
                    !n) {
                        var i = Math.pow(2, 8 * r) - 1;
                        b(this, e, t, r, i, 0)
                    }
                    var s = r - 1
                      , a = 1;
                    for (this[t + s] = 255 & e; --s >= 0 && (a *= 256); )
                        this[t + s] = e / a & 255;
                    return t + r
                }
                ,
                o.prototype.writeUInt8 = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 1, 255, 0),
                    this[t] = 255 & e,
                    t + 1
                }
                ,
                o.prototype.writeUInt16LE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 2, 65535, 0),
                    this[t] = 255 & e,
                    this[t + 1] = e >>> 8,
                    t + 2
                }
                ,
                o.prototype.writeUInt16BE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 2, 65535, 0),
                    this[t] = e >>> 8,
                    this[t + 1] = 255 & e,
                    t + 2
                }
                ,
                o.prototype.writeUInt32LE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 4, 0xffffffff, 0),
                    this[t + 3] = e >>> 24,
                    this[t + 2] = e >>> 16,
                    this[t + 1] = e >>> 8,
                    this[t] = 255 & e,
                    t + 4
                }
                ,
                o.prototype.writeUInt32BE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 4, 0xffffffff, 0),
                    this[t] = e >>> 24,
                    this[t + 1] = e >>> 16,
                    this[t + 2] = e >>> 8,
                    this[t + 3] = 255 & e,
                    t + 4
                }
                ,
                o.prototype.writeIntLE = function(e, t, r, n) {
                    if (e *= 1,
                    t >>>= 0,
                    !n) {
                        var i = Math.pow(2, 8 * r - 1);
                        b(this, e, t, r, i - 1, -i)
                    }
                    var s = 0
                      , a = 1
                      , o = 0;
                    for (this[t] = 255 & e; ++s < r && (a *= 256); )
                        e < 0 && 0 === o && 0 !== this[t + s - 1] && (o = 1),
                        this[t + s] = (e / a | 0) - o & 255;
                    return t + r
                }
                ,
                o.prototype.writeIntBE = function(e, t, r, n) {
                    if (e *= 1,
                    t >>>= 0,
                    !n) {
                        var i = Math.pow(2, 8 * r - 1);
                        b(this, e, t, r, i - 1, -i)
                    }
                    var s = r - 1
                      , a = 1
                      , o = 0;
                    for (this[t + s] = 255 & e; --s >= 0 && (a *= 256); )
                        e < 0 && 0 === o && 0 !== this[t + s + 1] && (o = 1),
                        this[t + s] = (e / a | 0) - o & 255;
                    return t + r
                }
                ,
                o.prototype.writeInt8 = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 1, 127, -128),
                    e < 0 && (e = 255 + e + 1),
                    this[t] = 255 & e,
                    t + 1
                }
                ,
                o.prototype.writeInt16LE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 2, 32767, -32768),
                    this[t] = 255 & e,
                    this[t + 1] = e >>> 8,
                    t + 2
                }
                ,
                o.prototype.writeInt16BE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 2, 32767, -32768),
                    this[t] = e >>> 8,
                    this[t + 1] = 255 & e,
                    t + 2
                }
                ,
                o.prototype.writeInt32LE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 4, 0x7fffffff, -0x80000000),
                    this[t] = 255 & e,
                    this[t + 1] = e >>> 8,
                    this[t + 2] = e >>> 16,
                    this[t + 3] = e >>> 24,
                    t + 4
                }
                ,
                o.prototype.writeInt32BE = function(e, t, r) {
                    return e *= 1,
                    t >>>= 0,
                    r || b(this, e, t, 4, 0x7fffffff, -0x80000000),
                    e < 0 && (e = 0xffffffff + e + 1),
                    this[t] = e >>> 24,
                    this[t + 1] = e >>> 16,
                    this[t + 2] = e >>> 8,
                    this[t + 3] = 255 & e,
                    t + 4
                }
                ,
                o.prototype.writeFloatLE = function(e, t, r) {
                    return I(this, e, t, !0, r)
                }
                ,
                o.prototype.writeFloatBE = function(e, t, r) {
                    return I(this, e, t, !1, r)
                }
                ,
                o.prototype.writeDoubleLE = function(e, t, r) {
                    return _(this, e, t, !0, r)
                }
                ,
                o.prototype.writeDoubleBE = function(e, t, r) {
                    return _(this, e, t, !1, r)
                }
                ,
                o.prototype.copy = function(e, t, r, n) {
                    if (!o.isBuffer(e))
                        throw TypeError("argument should be a Buffer");
                    if (r || (r = 0),
                    n || 0 === n || (n = this.length),
                    t >= e.length && (t = e.length),
                    t || (t = 0),
                    n > 0 && n < r && (n = r),
                    n === r || 0 === e.length || 0 === this.length)
                        return 0;
                    if (t < 0)
                        throw RangeError("targetStart out of bounds");
                    if (r < 0 || r >= this.length)
                        throw RangeError("Index out of range");
                    if (n < 0)
                        throw RangeError("sourceEnd out of bounds");
                    n > this.length && (n = this.length),
                    e.length - t < n - r && (n = e.length - t + r);
                    var i = n - r;
                    if (this === e && "function" == typeof Uint8Array.prototype.copyWithin)
                        this.copyWithin(t, r, n);
                    else if (this === e && r < t && t < n)
                        for (var s = i - 1; s >= 0; --s)
                            e[s + t] = this[s + r];
                    else
                        Uint8Array.prototype.set.call(e, this.subarray(r, n), t);
                    return i
                }
                ,
                o.prototype.fill = function(e, t, r, n) {
                    if ("string" == typeof e) {
                        if ("string" == typeof t ? (n = t,
                        t = 0,
                        r = this.length) : "string" == typeof r && (n = r,
                        r = this.length),
                        void 0 !== n && "string" != typeof n)
                            throw TypeError("encoding must be a string");
                        if ("string" == typeof n && !o.isEncoding(n))
                            throw TypeError("Unknown encoding: " + n);
                        if (1 === e.length) {
                            var i, s = e.charCodeAt(0);
                            ("utf8" === n && s < 128 || "latin1" === n) && (e = s)
                        }
                    } else
                        "number" == typeof e ? e &= 255 : "boolean" == typeof e && (e = Number(e));
                    if (t < 0 || this.length < t || this.length < r)
                        throw RangeError("Out of range index");
                    if (r <= t)
                        return this;
                    if (t >>>= 0,
                    r = void 0 === r ? this.length : r >>> 0,
                    e || (e = 0),
                    "number" == typeof e)
                        for (i = t; i < r; ++i)
                            this[i] = e;
                    else {
                        var a = o.isBuffer(e) ? e : o.from(e, n)
                          , l = a.length;
                        if (0 === l)
                            throw TypeError('The value "' + e + '" is invalid for argument "value"');
                        for (i = 0; i < r - t; ++i)
                            this[i + t] = a[i % l]
                    }
                    return this
                }
                ;
                var T = /[^+/0-9A-Za-z-_]/g;
                function S(e, t) {
                    t = t || 1 / 0;
                    for (var r, n = e.length, i = null, s = [], a = 0; a < n; ++a) {
                        if ((r = e.charCodeAt(a)) > 55295 && r < 57344) {
                            if (!i) {
                                if (r > 56319 || a + 1 === n) {
                                    (t -= 3) > -1 && s.push(239, 191, 189);
                                    continue
                                }
                                i = r;
                                continue
                            }
                            if (r < 56320) {
                                (t -= 3) > -1 && s.push(239, 191, 189),
                                i = r;
                                continue
                            }
                            r = (i - 55296 << 10 | r - 56320) + 65536
                        } else
                            i && (t -= 3) > -1 && s.push(239, 191, 189);
                        if (i = null,
                        r < 128) {
                            if ((t -= 1) < 0)
                                break;
                            s.push(r)
                        } else if (r < 2048) {
                            if ((t -= 2) < 0)
                                break;
                            s.push(r >> 6 | 192, 63 & r | 128)
                        } else if (r < 65536) {
                            if ((t -= 3) < 0)
                                break;
                            s.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
                        } else if (r < 1114112) {
                            if ((t -= 4) < 0)
                                break;
                            s.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
                        } else
                            throw Error("Invalid code point")
                    }
                    return s
                }
                function C(e) {
                    for (var t = [], r = 0; r < e.length; ++r)
                        t.push(255 & e.charCodeAt(r));
                    return t
                }
                function x(e) {
                    return n.toByteArray(function(e) {
                        if ((e = (e = e.split("=")[0]).trim().replace(T, "")).length < 2)
                            return "";
                        for (; e.length % 4 != 0; )
                            e += "=";
                        return e
                    }(e))
                }
                function A(e, t, r, n) {
                    for (var i = 0; i < n && !(i + r >= t.length) && !(i >= e.length); ++i)
                        t[i + r] = e[i];
                    return i
                }
                function D(e, t) {
                    return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
                }
                var k = function() {
                    for (var e = "0123456789abcdef", t = Array(256), r = 0; r < 16; ++r)
                        for (var n = 16 * r, i = 0; i < 16; ++i)
                            t[n + i] = e[r] + e[i];
                    return t
                }()
            },
            783: function(e, t) {
                t.read = function(e, t, r, n, i) {
                    var s, a, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, h = -7, c = r ? i - 1 : 0, d = r ? -1 : 1, f = e[t + c];
                    for (c += d,
                    s = f & (1 << -h) - 1,
                    f >>= -h,
                    h += o; h > 0; s = 256 * s + e[t + c],
                    c += d,
                    h -= 8)
                        ;
                    for (a = s & (1 << -h) - 1,
                    s >>= -h,
                    h += n; h > 0; a = 256 * a + e[t + c],
                    c += d,
                    h -= 8)
                        ;
                    if (0 === s)
                        s = 1 - u;
                    else {
                        if (s === l)
                            return a ? NaN : 1 / 0 * (f ? -1 : 1);
                        a += Math.pow(2, n),
                        s -= u
                    }
                    return (f ? -1 : 1) * a * Math.pow(2, s - n)
                }
                ,
                t.write = function(e, t, r, n, i, s) {
                    var a, o, l, u = 8 * s - i - 1, h = (1 << u) - 1, c = h >> 1, d = 5960464477539062e-23 * (23 === i), f = n ? 0 : s - 1, p = n ? 1 : -1, g = +(t < 0 || 0 === t && 1 / t < 0);
                    for (isNaN(t = Math.abs(t)) || t === 1 / 0 ? (o = +!!isNaN(t),
                    a = h) : (a = Math.floor(Math.log(t) / Math.LN2),
                    t * (l = Math.pow(2, -a)) < 1 && (a--,
                    l *= 2),
                    a + c >= 1 ? t += d / l : t += d * Math.pow(2, 1 - c),
                    t * l >= 2 && (a++,
                    l /= 2),
                    a + c >= h ? (o = 0,
                    a = h) : a + c >= 1 ? (o = (t * l - 1) * Math.pow(2, i),
                    a += c) : (o = t * Math.pow(2, c - 1) * Math.pow(2, i),
                    a = 0)); i >= 8; e[r + f] = 255 & o,
                    f += p,
                    o /= 256,
                    i -= 8)
                        ;
                    for (a = a << i | o,
                    u += i; u > 0; e[r + f] = 255 & a,
                    f += p,
                    a /= 256,
                    u -= 8)
                        ;
                    e[r + f - p] |= 128 * g
                }
            }
        }
          , a = {};
        function o(e) {
            var t = a[e];
            if (void 0 !== t)
                return t.exports;
            var r = a[e] = {
                exports: {}
            }
              , n = !0;
            try {
                s[e](r, r.exports, o),
                n = !1
            } finally {
                n && delete a[e]
            }
            return r.exports
        }
        o.ab = r + "/",
        n.exports = o(72)
    },
    27218: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            Integer: () => n,
            Md5: () => i,
            default: () => a
        });
        var n, i, s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {}, a = {};
        (function() {
            function e() {
                this.blockSize = -1,
                this.blockSize = 64,
                this.g = [, , , , ],
                this.B = Array(this.blockSize),
                this.o = this.h = 0,
                this.s()
            }
            var t = function() {
                this.blockSize = -1
            };
            function r() {}
            function s(e, t, r) {
                r || (r = 0);
                var n = Array(16);
                if ("string" == typeof t)
                    for (var i = 0; 16 > i; ++i)
                        n[i] = t.charCodeAt(r++) | t.charCodeAt(r++) << 8 | t.charCodeAt(r++) << 16 | t.charCodeAt(r++) << 24;
                else
                    for (i = 0; 16 > i; ++i)
                        n[i] = t[r++] | t[r++] << 8 | t[r++] << 16 | t[r++] << 24;
                t = e.g[0],
                r = e.g[1],
                i = e.g[2];
                var s = e.g[3]
                  , a = t + (s ^ r & (i ^ s)) + n[0] + 0xd76aa478 | 0;
                a = s + (i ^ (t = r + (a << 7 | a >>> 25)) & (r ^ i)) + n[1] + 0xe8c7b756 | 0,
                a = i + (r ^ (s = t + (a << 12 | a >>> 20)) & (t ^ r)) + n[2] + 0x242070db | 0,
                a = r + (t ^ (i = s + (a << 17 | a >>> 15)) & (s ^ t)) + n[3] + 0xc1bdceee | 0,
                a = t + (s ^ (r = i + (a << 22 | a >>> 10)) & (i ^ s)) + n[4] + 0xf57c0faf | 0,
                a = s + (i ^ (t = r + (a << 7 | a >>> 25)) & (r ^ i)) + n[5] + 0x4787c62a | 0,
                a = i + (r ^ (s = t + (a << 12 | a >>> 20)) & (t ^ r)) + n[6] + 0xa8304613 | 0,
                a = r + (t ^ (i = s + (a << 17 | a >>> 15)) & (s ^ t)) + n[7] + 0xfd469501 | 0,
                a = t + (s ^ (r = i + (a << 22 | a >>> 10)) & (i ^ s)) + n[8] + 0x698098d8 | 0,
                a = s + (i ^ (t = r + (a << 7 | a >>> 25)) & (r ^ i)) + n[9] + 0x8b44f7af | 0,
                a = i + (r ^ (s = t + (a << 12 | a >>> 20)) & (t ^ r)) + n[10] + 0xffff5bb1 | 0,
                a = r + (t ^ (i = s + (a << 17 | a >>> 15)) & (s ^ t)) + n[11] + 0x895cd7be | 0,
                a = t + (s ^ (r = i + (a << 22 | a >>> 10)) & (i ^ s)) + n[12] + 0x6b901122 | 0,
                a = s + (i ^ (t = r + (a << 7 | a >>> 25)) & (r ^ i)) + n[13] + 0xfd987193 | 0,
                a = i + (r ^ (s = t + (a << 12 | a >>> 20)) & (t ^ r)) + n[14] + 0xa679438e | 0,
                a = r + (t ^ (i = s + (a << 17 | a >>> 15)) & (s ^ t)) + n[15] + 0x49b40821 | 0,
                r = i + (a << 22 | a >>> 10),
                a = t + (i ^ s & (r ^ i)) + n[1] + 0xf61e2562 | 0,
                t = r + (a << 5 | a >>> 27),
                a = s + (r ^ i & (t ^ r)) + n[6] + 0xc040b340 | 0,
                s = t + (a << 9 | a >>> 23),
                a = i + (t ^ r & (s ^ t)) + n[11] + 0x265e5a51 | 0,
                i = s + (a << 14 | a >>> 18),
                a = r + (s ^ t & (i ^ s)) + n[0] + 0xe9b6c7aa | 0,
                r = i + (a << 20 | a >>> 12),
                a = t + (i ^ s & (r ^ i)) + n[5] + 0xd62f105d | 0,
                t = r + (a << 5 | a >>> 27),
                a = s + (r ^ i & (t ^ r)) + n[10] + 0x2441453 | 0,
                s = t + (a << 9 | a >>> 23),
                a = i + (t ^ r & (s ^ t)) + n[15] + 0xd8a1e681 | 0,
                i = s + (a << 14 | a >>> 18),
                a = r + (s ^ t & (i ^ s)) + n[4] + 0xe7d3fbc8 | 0,
                r = i + (a << 20 | a >>> 12),
                a = t + (i ^ s & (r ^ i)) + n[9] + 0x21e1cde6 | 0,
                t = r + (a << 5 | a >>> 27),
                a = s + (r ^ i & (t ^ r)) + n[14] + 0xc33707d6 | 0,
                s = t + (a << 9 | a >>> 23),
                a = i + (t ^ r & (s ^ t)) + n[3] + 0xf4d50d87 | 0,
                i = s + (a << 14 | a >>> 18),
                a = r + (s ^ t & (i ^ s)) + n[8] + 0x455a14ed | 0,
                r = i + (a << 20 | a >>> 12),
                a = t + (i ^ s & (r ^ i)) + n[13] + 0xa9e3e905 | 0,
                t = r + (a << 5 | a >>> 27),
                a = s + (r ^ i & (t ^ r)) + n[2] + 0xfcefa3f8 | 0,
                s = t + (a << 9 | a >>> 23),
                a = i + (t ^ r & (s ^ t)) + n[7] + 0x676f02d9 | 0,
                i = s + (a << 14 | a >>> 18),
                a = r + (s ^ t & (i ^ s)) + n[12] + 0x8d2a4c8a | 0,
                a = t + ((r = i + (a << 20 | a >>> 12)) ^ i ^ s) + n[5] + 0xfffa3942 | 0,
                a = s + ((t = r + (a << 4 | a >>> 28)) ^ r ^ i) + n[8] + 0x8771f681 | 0,
                a = i + ((s = t + (a << 11 | a >>> 21)) ^ t ^ r) + n[11] + 0x6d9d6122 | 0,
                a = r + ((i = s + (a << 16 | a >>> 16)) ^ s ^ t) + n[14] + 0xfde5380c | 0,
                a = t + ((r = i + (a << 23 | a >>> 9)) ^ i ^ s) + n[1] + 0xa4beea44 | 0,
                a = s + ((t = r + (a << 4 | a >>> 28)) ^ r ^ i) + n[4] + 0x4bdecfa9 | 0,
                a = i + ((s = t + (a << 11 | a >>> 21)) ^ t ^ r) + n[7] + 0xf6bb4b60 | 0,
                a = r + ((i = s + (a << 16 | a >>> 16)) ^ s ^ t) + n[10] + 0xbebfbc70 | 0,
                a = t + ((r = i + (a << 23 | a >>> 9)) ^ i ^ s) + n[13] + 0x289b7ec6 | 0,
                a = s + ((t = r + (a << 4 | a >>> 28)) ^ r ^ i) + n[0] + 0xeaa127fa | 0,
                a = i + ((s = t + (a << 11 | a >>> 21)) ^ t ^ r) + n[3] + 0xd4ef3085 | 0,
                a = r + ((i = s + (a << 16 | a >>> 16)) ^ s ^ t) + n[6] + 0x4881d05 | 0,
                a = t + ((r = i + (a << 23 | a >>> 9)) ^ i ^ s) + n[9] + 0xd9d4d039 | 0,
                a = s + ((t = r + (a << 4 | a >>> 28)) ^ r ^ i) + n[12] + 0xe6db99e5 | 0,
                a = i + ((s = t + (a << 11 | a >>> 21)) ^ t ^ r) + n[15] + 0x1fa27cf8 | 0,
                a = r + ((i = s + (a << 16 | a >>> 16)) ^ s ^ t) + n[2] + 0xc4ac5665 | 0,
                r = i + (a << 23 | a >>> 9),
                a = t + (i ^ (r | ~s)) + n[0] + 0xf4292244 | 0,
                t = r + (a << 6 | a >>> 26),
                a = s + (r ^ (t | ~i)) + n[7] + 0x432aff97 | 0,
                s = t + (a << 10 | a >>> 22),
                a = i + (t ^ (s | ~r)) + n[14] + 0xab9423a7 | 0,
                i = s + (a << 15 | a >>> 17),
                a = r + (s ^ (i | ~t)) + n[5] + 0xfc93a039 | 0,
                r = i + (a << 21 | a >>> 11),
                a = t + (i ^ (r | ~s)) + n[12] + 0x655b59c3 | 0,
                t = r + (a << 6 | a >>> 26),
                a = s + (r ^ (t | ~i)) + n[3] + 0x8f0ccc92 | 0,
                s = t + (a << 10 | a >>> 22),
                a = i + (t ^ (s | ~r)) + n[10] + 0xffeff47d | 0,
                i = s + (a << 15 | a >>> 17),
                a = r + (s ^ (i | ~t)) + n[1] + 0x85845dd1 | 0,
                r = i + (a << 21 | a >>> 11),
                a = t + (i ^ (r | ~s)) + n[8] + 0x6fa87e4f | 0,
                t = r + (a << 6 | a >>> 26),
                a = s + (r ^ (t | ~i)) + n[15] + 0xfe2ce6e0 | 0,
                s = t + (a << 10 | a >>> 22),
                a = i + (t ^ (s | ~r)) + n[6] + 0xa3014314 | 0,
                i = s + (a << 15 | a >>> 17),
                a = r + (s ^ (i | ~t)) + n[13] + 0x4e0811a1 | 0,
                r = i + (a << 21 | a >>> 11),
                a = t + (i ^ (r | ~s)) + n[4] + 0xf7537e82 | 0,
                t = r + (a << 6 | a >>> 26),
                a = s + (r ^ (t | ~i)) + n[11] + 0xbd3af235 | 0,
                s = t + (a << 10 | a >>> 22),
                a = i + (t ^ (s | ~r)) + n[2] + 0x2ad7d2bb | 0,
                i = s + (a << 15 | a >>> 17),
                a = r + (s ^ (i | ~t)) + n[9] + 0xeb86d391 | 0,
                e.g[0] = e.g[0] + t | 0,
                e.g[1] = e.g[1] + (i + (a << 21 | a >>> 11)) | 0,
                e.g[2] = e.g[2] + i | 0,
                e.g[3] = e.g[3] + s | 0
            }
            function o(e, t) {
                this.h = t;
                for (var r = [], n = !0, i = e.length - 1; 0 <= i; i--) {
                    var s = 0 | e[i];
                    n && s == t || (r[i] = s,
                    n = !1)
                }
                this.g = r
            }
            r.prototype = t.prototype,
            e.D = t.prototype,
            e.prototype = new r,
            e.prototype.constructor = e,
            e.C = function(e, r, n) {
                for (var i = Array(arguments.length - 2), s = 2; s < arguments.length; s++)
                    i[s - 2] = arguments[s];
                return t.prototype[r].apply(e, i)
            }
            ,
            e.prototype.s = function() {
                this.g[0] = 0x67452301,
                this.g[1] = 0xefcdab89,
                this.g[2] = 0x98badcfe,
                this.g[3] = 0x10325476,
                this.o = this.h = 0
            }
            ,
            e.prototype.u = function(e, t) {
                void 0 === t && (t = e.length);
                for (var r = t - this.blockSize, n = this.B, i = this.h, a = 0; a < t; ) {
                    if (0 == i)
                        for (; a <= r; )
                            s(this, e, a),
                            a += this.blockSize;
                    if ("string" == typeof e) {
                        for (; a < t; )
                            if (n[i++] = e.charCodeAt(a++),
                            i == this.blockSize) {
                                s(this, n),
                                i = 0;
                                break
                            }
                    } else
                        for (; a < t; )
                            if (n[i++] = e[a++],
                            i == this.blockSize) {
                                s(this, n),
                                i = 0;
                                break
                            }
                }
                this.h = i,
                this.o += t
            }
            ,
            e.prototype.v = function() {
                var e = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
                e[0] = 128;
                for (var t = 1; t < e.length - 8; ++t)
                    e[t] = 0;
                var r = 8 * this.o;
                for (t = e.length - 8; t < e.length; ++t)
                    e[t] = 255 & r,
                    r /= 256;
                for (this.u(e),
                e = Array(16),
                t = r = 0; 4 > t; ++t)
                    for (var n = 0; 32 > n; n += 8)
                        e[r++] = this.g[t] >>> n & 255;
                return e
            }
            ;
            var l, u = {};
            function h(e) {
                var t;
                return -128 <= e && 128 > e ? (t = function(e) {
                    return new o([0 | e],0 > e ? -1 : 0)
                }
                ,
                Object.prototype.hasOwnProperty.call(u, e) ? u[e] : u[e] = t(e)) : new o([0 | e],0 > e ? -1 : 0)
            }
            function c(e) {
                if (isNaN(e) || !isFinite(e))
                    return d;
                if (0 > e)
                    return y(c(-e));
                for (var t = [], r = 1, n = 0; e >= r; n++)
                    t[n] = e / r | 0,
                    r *= 0x100000000;
                return new o(t,0)
            }
            var d = h(0)
              , f = h(1)
              , p = h(0x1000000);
            function g(e) {
                if (0 != e.h)
                    return !1;
                for (var t = 0; t < e.g.length; t++)
                    if (0 != e.g[t])
                        return !1;
                return !0
            }
            function m(e) {
                return -1 == e.h
            }
            function y(e) {
                for (var t = e.g.length, r = [], n = 0; n < t; n++)
                    r[n] = ~e.g[n];
                return new o(r,~e.h).add(f)
            }
            function v(e, t) {
                return e.add(y(t))
            }
            function w(e, t) {
                for (; (65535 & e[t]) != e[t]; )
                    e[t + 1] += e[t] >>> 16,
                    e[t] &= 65535,
                    t++
            }
            function b(e, t) {
                this.g = e,
                this.h = t
            }
            function E(e, t) {
                if (g(t))
                    throw Error("division by zero");
                if (g(e))
                    return new b(d,d);
                if (m(e))
                    return t = E(y(e), t),
                    new b(y(t.g),y(t.h));
                if (m(t))
                    return t = E(e, y(t)),
                    new b(y(t.g),t.h);
                if (30 < e.g.length) {
                    if (m(e) || m(t))
                        throw Error("slowDivide_ only works with positive integers.");
                    for (var r = f, n = t; 0 >= n.l(e); )
                        r = I(r),
                        n = I(n);
                    var i = _(r, 1)
                      , s = _(n, 1);
                    for (n = _(n, 2),
                    r = _(r, 2); !g(n); ) {
                        var a = s.add(n);
                        0 >= a.l(e) && (i = i.add(r),
                        s = a),
                        n = _(n, 1),
                        r = _(r, 1)
                    }
                    return t = v(e, i.j(t)),
                    new b(i,t)
                }
                for (i = d; 0 <= e.l(t); ) {
                    for (n = 48 >= (n = Math.ceil(Math.log(r = Math.max(1, Math.floor(e.m() / t.m()))) / Math.LN2)) ? 1 : Math.pow(2, n - 48),
                    a = (s = c(r)).j(t); m(a) || 0 < a.l(e); )
                        r -= n,
                        a = (s = c(r)).j(t);
                    g(s) && (s = f),
                    i = i.add(s),
                    e = v(e, a)
                }
                return new b(i,e)
            }
            function I(e) {
                for (var t = e.g.length + 1, r = [], n = 0; n < t; n++)
                    r[n] = e.i(n) << 1 | e.i(n - 1) >>> 31;
                return new o(r,e.h)
            }
            function _(e, t) {
                var r = t >> 5;
                t %= 32;
                for (var n = e.g.length - r, i = [], s = 0; s < n; s++)
                    i[s] = 0 < t ? e.i(s + r) >>> t | e.i(s + r + 1) << 32 - t : e.i(s + r);
                return new o(i,e.h)
            }
            (l = o.prototype).m = function() {
                if (m(this))
                    return -y(this).m();
                for (var e = 0, t = 1, r = 0; r < this.g.length; r++) {
                    var n = this.i(r);
                    e += (0 <= n ? n : 0x100000000 + n) * t,
                    t *= 0x100000000
                }
                return e
            }
            ,
            l.toString = function(e) {
                if (2 > (e = e || 10) || 36 < e)
                    throw Error("radix out of range: " + e);
                if (g(this))
                    return "0";
                if (m(this))
                    return "-" + y(this).toString(e);
                for (var t = c(Math.pow(e, 6)), r = this, n = ""; ; ) {
                    var i = E(r, t).g
                      , s = ((0 < (r = v(r, i.j(t))).g.length ? r.g[0] : r.h) >>> 0).toString(e);
                    if (g(r = i))
                        return s + n;
                    for (; 6 > s.length; )
                        s = "0" + s;
                    n = s + n
                }
            }
            ,
            l.i = function(e) {
                return 0 > e ? 0 : e < this.g.length ? this.g[e] : this.h
            }
            ,
            l.l = function(e) {
                return m(e = v(this, e)) ? -1 : +!g(e)
            }
            ,
            l.abs = function() {
                return m(this) ? y(this) : this
            }
            ,
            l.add = function(e) {
                for (var t = Math.max(this.g.length, e.g.length), r = [], n = 0, i = 0; i <= t; i++) {
                    var s = n + (65535 & this.i(i)) + (65535 & e.i(i))
                      , a = (s >>> 16) + (this.i(i) >>> 16) + (e.i(i) >>> 16);
                    n = a >>> 16,
                    s &= 65535,
                    a &= 65535,
                    r[i] = a << 16 | s
                }
                return new o(r,-0x80000000 & r[r.length - 1] ? -1 : 0)
            }
            ,
            l.j = function(e) {
                if (g(this) || g(e))
                    return d;
                if (m(this))
                    return m(e) ? y(this).j(y(e)) : y(y(this).j(e));
                if (m(e))
                    return y(this.j(y(e)));
                if (0 > this.l(p) && 0 > e.l(p))
                    return c(this.m() * e.m());
                for (var t = this.g.length + e.g.length, r = [], n = 0; n < 2 * t; n++)
                    r[n] = 0;
                for (n = 0; n < this.g.length; n++)
                    for (var i = 0; i < e.g.length; i++) {
                        var s = this.i(n) >>> 16
                          , a = 65535 & this.i(n)
                          , l = e.i(i) >>> 16
                          , u = 65535 & e.i(i);
                        r[2 * n + 2 * i] += a * u,
                        w(r, 2 * n + 2 * i),
                        r[2 * n + 2 * i + 1] += s * u,
                        w(r, 2 * n + 2 * i + 1),
                        r[2 * n + 2 * i + 1] += a * l,
                        w(r, 2 * n + 2 * i + 1),
                        r[2 * n + 2 * i + 2] += s * l,
                        w(r, 2 * n + 2 * i + 2)
                    }
                for (n = 0; n < t; n++)
                    r[n] = r[2 * n + 1] << 16 | r[2 * n];
                for (n = t; n < 2 * t; n++)
                    r[n] = 0;
                return new o(r,0)
            }
            ,
            l.A = function(e) {
                return E(this, e).h
            }
            ,
            l.and = function(e) {
                for (var t = Math.max(this.g.length, e.g.length), r = [], n = 0; n < t; n++)
                    r[n] = this.i(n) & e.i(n);
                return new o(r,this.h & e.h)
            }
            ,
            l.or = function(e) {
                for (var t = Math.max(this.g.length, e.g.length), r = [], n = 0; n < t; n++)
                    r[n] = this.i(n) | e.i(n);
                return new o(r,this.h | e.h)
            }
            ,
            l.xor = function(e) {
                for (var t = Math.max(this.g.length, e.g.length), r = [], n = 0; n < t; n++)
                    r[n] = this.i(n) ^ e.i(n);
                return new o(r,this.h ^ e.h)
            }
            ,
            e.prototype.digest = e.prototype.v,
            e.prototype.reset = e.prototype.s,
            e.prototype.update = e.prototype.u,
            i = a.Md5 = e,
            o.prototype.add = o.prototype.add,
            o.prototype.multiply = o.prototype.j,
            o.prototype.modulo = o.prototype.A,
            o.prototype.compare = o.prototype.l,
            o.prototype.toNumber = o.prototype.m,
            o.prototype.toString = o.prototype.toString,
            o.prototype.getBits = o.prototype.i,
            o.fromNumber = c,
            o.fromString = function e(t, r) {
                if (0 == t.length)
                    throw Error("number format error: empty string");
                if (2 > (r = r || 10) || 36 < r)
                    throw Error("radix out of range: " + r);
                if ("-" == t.charAt(0))
                    return y(e(t.substring(1), r));
                if (0 <= t.indexOf("-"))
                    throw Error('number format error: interior "-" character');
                for (var n = c(Math.pow(r, 8)), i = d, s = 0; s < t.length; s += 8) {
                    var a = Math.min(8, t.length - s)
                      , o = parseInt(t.substring(s, s + a), r);
                    8 > a ? (a = c(Math.pow(r, a)),
                    i = i.j(a).add(c(o))) : i = (i = i.j(n)).add(c(o))
                }
                return i
            }
            ,
            n = a.Integer = o
        }
        ).apply(void 0 !== s ? s : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
    ,
    20466: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({
            ErrorCode: () => o,
            Event: () => u,
            EventType: () => a,
            FetchXmlHttpFactory: () => i,
            Stat: () => l,
            WebChannel: () => s,
            XhrIo: () => n,
            createWebChannelTransport: () => c,
            default: () => f,
            getStatEventTarget: () => h
        });
        var n, i, s, a, o, l, u, h, c, d = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {}, f = {};
        (function() {
            var e, t, r, p = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e, t, r) {
                return e == Array.prototype || e == Object.prototype || (e[t] = r.value),
                e
            }
            , g = function(e) {
                e = ["object" == typeof globalThis && globalThis, e, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof d && d];
                for (var t = 0; t < e.length; ++t) {
                    var r = e[t];
                    if (r && r.Math == Math)
                        return r
                }
                throw Error("Cannot find global object")
            }(this);
            !function(e, t) {
                if (t)
                    e: {
                        var r = g;
                        e = e.split(".");
                        for (var n = 0; n < e.length - 1; n++) {
                            var i = e[n];
                            if (!(i in r))
                                break e;
                            r = r[i]
                        }
                        (t = t(n = r[e = e[e.length - 1]])) != n && null != t && p(r, e, {
                            configurable: !0,
                            writable: !0,
                            value: t
                        })
                    }
            }("Array.prototype.values", function(e) {
                return e || function() {
                    var e, t, r, n, i;
                    return e = this,
                    t = function(e, t) {
                        return t
                    }
                    ,
                    e instanceof String && (e += ""),
                    r = 0,
                    n = !1,
                    (i = {
                        next: function() {
                            if (!n && r < e.length) {
                                var i = r++;
                                return {
                                    value: t(i, e[i]),
                                    done: !1
                                }
                            }
                            return n = !0,
                            {
                                done: !0,
                                value: void 0
                            }
                        }
                    })[Symbol.iterator] = function() {
                        return i
                    }
                    ,
                    i
                }
            });
            var m = m || {}
              , y = this || self;
            function v(e) {
                var t = typeof e;
                return "array" == (t = "object" != t ? t : e ? Array.isArray(e) ? "array" : t : "null") || "object" == t && "number" == typeof e.length
            }
            function w(e) {
                var t = typeof e;
                return "object" == t && null != e || "function" == t
            }
            function b(e, t, r) {
                return e.call.apply(e.bind, arguments)
            }
            function E(e, t, r) {
                if (!e)
                    throw Error();
                if (2 < arguments.length) {
                    var n = Array.prototype.slice.call(arguments, 2);
                    return function() {
                        var r = Array.prototype.slice.call(arguments);
                        return Array.prototype.unshift.apply(r, n),
                        e.apply(t, r)
                    }
                }
                return function() {
                    return e.apply(t, arguments)
                }
            }
            function I(e, t, r) {
                return (I = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? b : E).apply(null, arguments)
            }
            function _(e, t) {
                var r = Array.prototype.slice.call(arguments, 1);
                return function() {
                    var t = r.slice();
                    return t.push.apply(t, arguments),
                    e.apply(this, t)
                }
            }
            function T(e, t) {
                function r() {}
                r.prototype = t.prototype,
                e.aa = t.prototype,
                e.prototype = new r,
                e.prototype.constructor = e,
                e.Qb = function(e, r, n) {
                    for (var i = Array(arguments.length - 2), s = 2; s < arguments.length; s++)
                        i[s - 2] = arguments[s];
                    return t.prototype[r].apply(e, i)
                }
            }
            function S(e) {
                let t = e.length;
                if (0 < t) {
                    let r = Array(t);
                    for (let n = 0; n < t; n++)
                        r[n] = e[n];
                    return r
                }
                return []
            }
            function C(e, t) {
                for (let t = 1; t < arguments.length; t++) {
                    let r = arguments[t];
                    if (v(r)) {
                        let t = e.length || 0
                          , n = r.length || 0;
                        e.length = t + n;
                        for (let i = 0; i < n; i++)
                            e[t + i] = r[i]
                    } else
                        e.push(r)
                }
            }
            function x(e) {
                return /^[\s\xa0]*$/.test(e)
            }
            function A() {
                var e = y.navigator;
                return e && (e = e.userAgent) ? e : ""
            }
            function D(e) {
                return D[" "](e),
                e
            }
            D[" "] = function() {}
            ;
            var k = -1 != A().indexOf("Gecko") && (-1 == A().toLowerCase().indexOf("webkit") || -1 != A().indexOf("Edge")) && -1 == A().indexOf("Trident") && -1 == A().indexOf("MSIE") && -1 == A().indexOf("Edge");
            function N(e, t, r) {
                for (let n in e)
                    t.call(r, e[n], n, e)
            }
            function O(e) {
                let t = {};
                for (let r in e)
                    t[r] = e[r];
                return t
            }
            let R = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
            function M(e, t) {
                let r, n;
                for (let t = 1; t < arguments.length; t++) {
                    for (r in n = arguments[t])
                        e[r] = n[r];
                    for (let t = 0; t < R.length; t++)
                        r = R[t],
                        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
            }
            var P = new class {
                constructor(e, t) {
                    this.i = e,
                    this.j = t,
                    this.h = 0,
                    this.g = null
                }
                get() {
                    let e;
                    return 0 < this.h ? (this.h--,
                    e = this.g,
                    this.g = e.next,
                    e.next = null) : e = this.i(),
                    e
                }
            }
            ( () => new L,e => e.reset());
            class L {
                constructor() {
                    this.next = this.g = this.h = null
                }
                set(e, t) {
                    this.h = e,
                    this.g = t,
                    this.next = null
                }
                reset() {
                    this.next = this.g = this.h = null
                }
            }
            let F, B = !1, V = new class {
                constructor() {
                    this.h = this.g = null
                }
                add(e, t) {
                    let r = P.get();
                    r.set(e, t),
                    this.h ? this.h.next = r : this.g = r,
                    this.h = r
                }
            }
            , U = () => {
                let e = y.Promise.resolve(void 0);
                F = () => {
                    e.then(q)
                }
            }
            ;
            var q = () => {
                let e;
                for (var t; e = null,
                V.g && (e = V.g,
                V.g = V.g.next,
                V.g || (V.h = null),
                e.next = null),
                t = e; ) {
                    try {
                        t.h.call(t.g)
                    } catch (e) {
                        !function(e) {
                            y.setTimeout( () => {
                                throw e
                            }
                            , 0)
                        }(e)
                    }
                    P.j(t),
                    100 > P.h && (P.h++,
                    t.next = P.g,
                    P.g = t)
                }
                B = !1
            }
            ;
            function j() {
                this.s = this.s,
                this.C = this.C
            }
            function z(e, t) {
                this.type = e,
                this.g = this.target = t,
                this.defaultPrevented = !1
            }
            j.prototype.s = !1,
            j.prototype.ma = function() {
                this.s || (this.s = !0,
                this.N())
            }
            ,
            j.prototype.N = function() {
                if (this.C)
                    for (; this.C.length; )
                        this.C.shift()()
            }
            ,
            z.prototype.h = function() {
                this.defaultPrevented = !0
            }
            ;
            var Q = function() {
                if (!y.addEventListener || !Object.defineProperty)
                    return !1;
                var e = !1
                  , t = Object.defineProperty({}, "passive", {
                    get: function() {
                        e = !0
                    }
                });
                try {
                    let e = () => {}
                    ;
                    y.addEventListener("test", e, t),
                    y.removeEventListener("test", e, t)
                } catch (e) {}
                return e
            }();
            function K(e, t) {
                if (z.call(this, e ? e.type : ""),
                this.relatedTarget = this.g = this.target = null,
                this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0,
                this.key = "",
                this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1,
                this.state = null,
                this.pointerId = 0,
                this.pointerType = "",
                this.i = null,
                e) {
                    var r = this.type = e.type
                      , n = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null;
                    if (this.target = e.target || e.srcElement,
                    this.g = t,
                    t = e.relatedTarget) {
                        if (k) {
                            e: {
                                try {
                                    D(t.nodeName);
                                    var i = !0;
                                    break e
                                } catch (e) {}
                                i = !1
                            }
                            i || (t = null)
                        }
                    } else
                        "mouseover" == r ? t = e.fromElement : "mouseout" == r && (t = e.toElement);
                    this.relatedTarget = t,
                    n ? (this.clientX = void 0 !== n.clientX ? n.clientX : n.pageX,
                    this.clientY = void 0 !== n.clientY ? n.clientY : n.pageY,
                    this.screenX = n.screenX || 0,
                    this.screenY = n.screenY || 0) : (this.clientX = void 0 !== e.clientX ? e.clientX : e.pageX,
                    this.clientY = void 0 !== e.clientY ? e.clientY : e.pageY,
                    this.screenX = e.screenX || 0,
                    this.screenY = e.screenY || 0),
                    this.button = e.button,
                    this.key = e.key || "",
                    this.ctrlKey = e.ctrlKey,
                    this.altKey = e.altKey,
                    this.shiftKey = e.shiftKey,
                    this.metaKey = e.metaKey,
                    this.pointerId = e.pointerId || 0,
                    this.pointerType = "string" == typeof e.pointerType ? e.pointerType : $[e.pointerType] || "",
                    this.state = e.state,
                    this.i = e,
                    e.defaultPrevented && K.aa.h.call(this)
                }
            }
            T(K, z);
            var $ = {
                2: "touch",
                3: "pen",
                4: "mouse"
            };
            K.prototype.h = function() {
                K.aa.h.call(this);
                var e = this.i;
                e.preventDefault ? e.preventDefault() : e.returnValue = !1
            }
            ;
            var G = "closure_listenable_" + (1e6 * Math.random() | 0)
              , H = 0;
            function W(e, t, r, n, i) {
                this.listener = e,
                this.proxy = null,
                this.src = t,
                this.type = r,
                this.capture = !!n,
                this.ha = i,
                this.key = ++H,
                this.da = this.fa = !1
            }
            function J(e) {
                e.da = !0,
                e.listener = null,
                e.proxy = null,
                e.src = null,
                e.ha = null
            }
            function Y(e) {
                this.src = e,
                this.g = {},
                this.h = 0
            }
            function X(e, t) {
                var r = t.type;
                if (r in e.g) {
                    var n, i = e.g[r], s = Array.prototype.indexOf.call(i, t, void 0);
                    (n = 0 <= s) && Array.prototype.splice.call(i, s, 1),
                    n && (J(t),
                    0 == e.g[r].length && (delete e.g[r],
                    e.h--))
                }
            }
            function Z(e, t, r, n) {
                for (var i = 0; i < e.length; ++i) {
                    var s = e[i];
                    if (!s.da && s.listener == t && !!r == s.capture && s.ha == n)
                        return i
                }
                return -1
            }
            Y.prototype.add = function(e, t, r, n, i) {
                var s = e.toString();
                (e = this.g[s]) || (e = this.g[s] = [],
                this.h++);
                var a = Z(e, t, n, i);
                return -1 < a ? (t = e[a],
                r || (t.fa = !1)) : ((t = new W(t,this.src,s,!!n,i)).fa = r,
                e.push(t)),
                t
            }
            ;
            var ee = "closure_lm_" + (1e6 * Math.random() | 0)
              , et = {};
            function er(e, t, r, n, i, s) {
                if (!t)
                    throw Error("Invalid event type");
                var a = w(i) ? !!i.capture : !!i
                  , o = ea(e);
                if (o || (e[ee] = o = new Y(e)),
                (r = o.add(t, r, n, a, s)).proxy)
                    return r;
                if (n = function e(t) {
                    return es.call(e.src, e.listener, t)
                }
                ,
                r.proxy = n,
                n.src = e,
                n.listener = r,
                e.addEventListener)
                    Q || (i = a),
                    void 0 === i && (i = !1),
                    e.addEventListener(t.toString(), n, i);
                else if (e.attachEvent)
                    e.attachEvent(ei(t.toString()), n);
                else if (e.addListener && e.removeListener)
                    e.addListener(n);
                else
                    throw Error("addEventListener and attachEvent are unavailable.");
                return r
            }
            function en(e) {
                if ("number" != typeof e && e && !e.da) {
                    var t = e.src;
                    if (t && t[G])
                        X(t.i, e);
                    else {
                        var r = e.type
                          , n = e.proxy;
                        t.removeEventListener ? t.removeEventListener(r, n, e.capture) : t.detachEvent ? t.detachEvent(ei(r), n) : t.addListener && t.removeListener && t.removeListener(n),
                        (r = ea(t)) ? (X(r, e),
                        0 == r.h && (r.src = null,
                        t[ee] = null)) : J(e)
                    }
                }
            }
            function ei(e) {
                return e in et ? et[e] : et[e] = "on" + e
            }
            function es(e, t) {
                if (e.da)
                    e = !0;
                else {
                    t = new K(t,this);
                    var r = e.listener
                      , n = e.ha || e.src;
                    e.fa && en(e),
                    e = r.call(n, t)
                }
                return e
            }
            function ea(e) {
                return (e = e[ee])instanceof Y ? e : null
            }
            var eo = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
            function el(e) {
                return "function" == typeof e ? e : (e[eo] || (e[eo] = function(t) {
                    return e.handleEvent(t)
                }
                ),
                e[eo])
            }
            function eu() {
                j.call(this),
                this.i = new Y(this),
                this.M = this,
                this.F = null
            }
            function eh(e, t) {
                var r, n = e.F;
                if (n)
                    for (r = []; n; n = n.F)
                        r.push(n);
                if (e = e.M,
                n = t.type || t,
                "string" == typeof t)
                    t = new z(t,e);
                else if (t instanceof z)
                    t.target = t.target || e;
                else {
                    var i = t;
                    M(t = new z(n,e), i)
                }
                if (i = !0,
                r)
                    for (var s = r.length - 1; 0 <= s; s--) {
                        var a = t.g = r[s];
                        i = ec(a, n, !0, t) && i
                    }
                if (i = ec(a = t.g = e, n, !0, t) && i,
                i = ec(a, n, !1, t) && i,
                r)
                    for (s = 0; s < r.length; s++)
                        i = ec(a = t.g = r[s], n, !1, t) && i
            }
            function ec(e, t, r, n) {
                if (!(t = e.i.g[String(t)]))
                    return !0;
                t = t.concat();
                for (var i = !0, s = 0; s < t.length; ++s) {
                    var a = t[s];
                    if (a && !a.da && a.capture == r) {
                        var o = a.listener
                          , l = a.ha || a.src;
                        a.fa && X(e.i, a),
                        i = !1 !== o.call(l, n) && i
                    }
                }
                return i && !n.defaultPrevented
            }
            function ed(e, t, r) {
                if ("function" == typeof e)
                    r && (e = I(e, r));
                else if (e && "function" == typeof e.handleEvent)
                    e = I(e.handleEvent, e);
                else
                    throw Error("Invalid listener argument");
                return 0x7fffffff < Number(t) ? -1 : y.setTimeout(e, t || 0)
            }
            T(eu, j),
            eu.prototype[G] = !0,
            eu.prototype.removeEventListener = function(e, t, r, n) {
                !function e(t, r, n, i, s) {
                    if (Array.isArray(r))
                        for (var a = 0; a < r.length; a++)
                            e(t, r[a], n, i, s);
                    else
                        (i = w(i) ? !!i.capture : !!i,
                        n = el(n),
                        t && t[G]) ? (t = t.i,
                        (r = String(r).toString())in t.g && -1 < (n = Z(a = t.g[r], n, i, s)) && (J(a[n]),
                        Array.prototype.splice.call(a, n, 1),
                        0 == a.length && (delete t.g[r],
                        t.h--))) : t && (t = ea(t)) && (r = t.g[r.toString()],
                        t = -1,
                        r && (t = Z(r, n, i, s)),
                        (n = -1 < t ? r[t] : null) && en(n))
                }(this, e, t, r, n)
            }
            ,
            eu.prototype.N = function() {
                if (eu.aa.N.call(this),
                this.i) {
                    var e, t = this.i;
                    for (e in t.g) {
                        for (var r = t.g[e], n = 0; n < r.length; n++)
                            J(r[n]);
                        delete t.g[e],
                        t.h--
                    }
                }
                this.F = null
            }
            ,
            eu.prototype.K = function(e, t, r, n) {
                return this.i.add(String(e), t, !1, r, n)
            }
            ,
            eu.prototype.L = function(e, t, r, n) {
                return this.i.add(String(e), t, !0, r, n)
            }
            ;
            class ef extends j {
                constructor(e, t) {
                    super(),
                    this.m = e,
                    this.l = t,
                    this.h = null,
                    this.i = !1,
                    this.g = null
                }
                j(e) {
                    this.h = arguments,
                    this.g ? this.i = !0 : function e(t) {
                        t.g = ed( () => {
                            t.g = null,
                            t.i && (t.i = !1,
                            e(t))
                        }
                        , t.l);
                        let r = t.h;
                        t.h = null,
                        t.m.apply(null, r)
                    }(this)
                }
                N() {
                    super.N(),
                    this.g && (y.clearTimeout(this.g),
                    this.g = null,
                    this.i = !1,
                    this.h = null)
                }
            }
            function ep(e) {
                j.call(this),
                this.h = e,
                this.g = {}
            }
            T(ep, j);
            var eg = [];
            function em(e) {
                N(e.g, function(e, t) {
                    this.g.hasOwnProperty(t) && en(e)
                }, e),
                e.g = {}
            }
            ep.prototype.N = function() {
                ep.aa.N.call(this),
                em(this)
            }
            ,
            ep.prototype.handleEvent = function() {
                throw Error("EventHandler.handleEvent not implemented")
            }
            ;
            var ey = y.JSON.stringify
              , ev = y.JSON.parse
              , ew = class {
                stringify(e) {
                    return y.JSON.stringify(e, void 0)
                }
                parse(e) {
                    return y.JSON.parse(e, void 0)
                }
            }
            ;
            function eb() {}
            function eE(e) {
                return e.h || (e.h = e.i())
            }
            function eI() {}
            eb.prototype.h = null;
            var e_ = {
                OPEN: "a",
                kb: "b",
                Ja: "c",
                wb: "d"
            };
            function eT() {
                z.call(this, "d")
            }
            function eS() {
                z.call(this, "c")
            }
            T(eT, z),
            T(eS, z);
            var eC = {}
              , ex = null;
            function eA() {
                return ex = ex || new eu
            }
            function eD(e) {
                z.call(this, eC.La, e)
            }
            function ek(e) {
                let t = eA();
                eh(t, new eD(t))
            }
            function eN(e, t) {
                z.call(this, eC.STAT_EVENT, e),
                this.stat = t
            }
            function eO(e) {
                let t = eA();
                eh(t, new eN(t,e))
            }
            function eR(e, t) {
                z.call(this, eC.Ma, e),
                this.size = t
            }
            function eM(e, t) {
                if ("function" != typeof e)
                    throw Error("Fn must not be null and must be a function");
                return y.setTimeout(function() {
                    e()
                }, t)
            }
            function eP() {
                this.g = !0
            }
            function eL(e, t, r, n) {
                e.info(function() {
                    return "XMLHTTP TEXT (" + t + "): " + function(e, t) {
                        if (!e.g)
                            return t;
                        if (!t)
                            return null;
                        try {
                            var r = JSON.parse(t);
                            if (r) {
                                for (e = 0; e < r.length; e++)
                                    if (Array.isArray(r[e])) {
                                        var n = r[e];
                                        if (!(2 > n.length)) {
                                            var i = n[1];
                                            if (Array.isArray(i) && !(1 > i.length)) {
                                                var s = i[0];
                                                if ("noop" != s && "stop" != s && "close" != s)
                                                    for (var a = 1; a < i.length; a++)
                                                        i[a] = ""
                                            }
                                        }
                                    }
                            }
                            return ey(r)
                        } catch (e) {
                            return t
                        }
                    }(e, r) + (n ? " " + n : "")
                })
            }
            eC.La = "serverreachability",
            T(eD, z),
            eC.STAT_EVENT = "statevent",
            T(eN, z),
            eC.Ma = "timingevent",
            T(eR, z),
            eP.prototype.xa = function() {
                this.g = !1
            }
            ,
            eP.prototype.info = function() {}
            ;
            var eF = {
                NO_ERROR: 0,
                gb: 1,
                tb: 2,
                sb: 3,
                nb: 4,
                rb: 5,
                ub: 6,
                Ia: 7,
                TIMEOUT: 8,
                xb: 9
            }
              , eB = {
                lb: "complete",
                Hb: "success",
                Ja: "error",
                Ia: "abort",
                zb: "ready",
                Ab: "readystatechange",
                TIMEOUT: "timeout",
                vb: "incrementaldata",
                yb: "progress",
                ob: "downloadprogress",
                Pb: "uploadprogress"
            };
            function eV() {}
            function eU(e, t, r, n) {
                this.j = e,
                this.i = t,
                this.l = r,
                this.R = n || 1,
                this.U = new ep(this),
                this.I = 45e3,
                this.H = null,
                this.o = !1,
                this.m = this.A = this.v = this.L = this.F = this.S = this.B = null,
                this.D = [],
                this.g = null,
                this.C = 0,
                this.s = this.u = null,
                this.X = -1,
                this.J = !1,
                this.O = 0,
                this.M = null,
                this.W = this.K = this.T = this.P = !1,
                this.h = new eq
            }
            function eq() {
                this.i = null,
                this.g = "",
                this.h = !1
            }
            T(eV, eb),
            eV.prototype.g = function() {
                return new XMLHttpRequest
            }
            ,
            eV.prototype.i = function() {
                return {}
            }
            ,
            t = new eV;
            var ej = {}
              , ez = {};
            function eQ(e, t, r) {
                e.L = 1,
                e.v = ts(te(t)),
                e.m = r,
                e.P = !0,
                eK(e, null)
            }
            function eK(e, t) {
                e.F = Date.now(),
                eG(e),
                e.A = te(e.v);
                var r, n, i, s, a, o, l = e.A, u = e.R;
                Array.isArray(u) || (u = [String(u)]),
                tv(l.i, "t", u),
                e.C = 0,
                l = e.j.J,
                e.h = new eq,
                e.g = t3(e.j, l ? t : null, !e.m),
                0 < e.O && (e.M = new ef(I(e.Y, e, e.g),e.O)),
                t = e.U,
                l = e.g,
                u = e.ca;
                var h = "readystatechange";
                Array.isArray(h) || (h && (eg[0] = h.toString()),
                h = eg);
                for (var c = 0; c < h.length; c++) {
                    var d = function e(t, r, n, i, s) {
                        if (i && i.once)
                            return function e(t, r, n, i, s) {
                                if (Array.isArray(r)) {
                                    for (var a = 0; a < r.length; a++)
                                        e(t, r[a], n, i, s);
                                    return null
                                }
                                return n = el(n),
                                t && t[G] ? t.L(r, n, w(i) ? !!i.capture : !!i, s) : er(t, r, n, !0, i, s)
                            }(t, r, n, i, s);
                        if (Array.isArray(r)) {
                            for (var a = 0; a < r.length; a++)
                                e(t, r[a], n, i, s);
                            return null
                        }
                        return n = el(n),
                        t && t[G] ? t.K(r, n, w(i) ? !!i.capture : !!i, s) : er(t, r, n, !1, i, s)
                    }(l, h[c], u || t.handleEvent, !1, t.h || t);
                    if (!d)
                        break;
                    t.g[d.key] = d
                }
                t = e.H ? O(e.H) : {},
                e.m ? (e.u || (e.u = "POST"),
                t["Content-Type"] = "application/x-www-form-urlencoded",
                e.g.ea(e.A, e.u, e.m, t)) : (e.u = "GET",
                e.g.ea(e.A, e.u, null, t)),
                ek(),
                r = e.i,
                n = e.u,
                i = e.A,
                s = e.l,
                a = e.R,
                o = e.m,
                r.info(function() {
                    if (r.g)
                        if (o)
                            for (var e = "", t = o.split("&"), l = 0; l < t.length; l++) {
                                var u = t[l].split("=");
                                if (1 < u.length) {
                                    var h = u[0];
                                    u = u[1];
                                    var c = h.split("_");
                                    e = 2 <= c.length && "type" == c[1] ? e + (h + "=") + u + "&" : e + (h + "=redacted&")
                                }
                            }
                        else
                            e = null;
                    else
                        e = o;
                    return "XMLHTTP REQ (" + s + ") [attempt " + a + "]: " + n + "\n" + i + "\n" + e
                })
            }
            function e$(e) {
                return !!e.g && "GET" == e.u && 2 != e.L && e.j.Ca
            }
            function eG(e) {
                e.S = Date.now() + e.I,
                eH(e, e.I)
            }
            function eH(e, t) {
                if (null != e.B)
                    throw Error("WatchDog timer not null");
                e.B = eM(I(e.ba, e), t)
            }
            function eW(e) {
                e.B && (y.clearTimeout(e.B),
                e.B = null)
            }
            function eJ(e) {
                0 == e.j.G || e.J || tZ(e.j, e)
            }
            function eY(e) {
                eW(e);
                var t = e.M;
                t && "function" == typeof t.ma && t.ma(),
                e.M = null,
                em(e.U),
                e.g && (t = e.g,
                e.g = null,
                t.abort(),
                t.ma())
            }
            function eX(e, t) {
                try {
                    var r = e.j;
                    if (0 != r.G && (r.g == e || e6(r.h, e))) {
                        if (!e.K && e6(r.h, e) && 3 == r.G) {
                            try {
                                var n = r.Da.g.parse(t)
                            } catch (e) {
                                n = null
                            }
                            if (Array.isArray(n) && 3 == n.length) {
                                var i = n;
                                if (0 == i[0]) {
                                    e: if (!r.u) {
                                        if (r.g)
                                            if (r.g.F + 3e3 < e.F)
                                                tX(r),
                                                tj(r);
                                            else
                                                break e;
                                        tW(r),
                                        eO(18)
                                    }
                                } else
                                    r.za = i[1],
                                    0 < r.za - r.T && 37500 > i[2] && r.F && 0 == r.v && !r.C && (r.C = eM(I(r.Za, r), 6e3));
                                if (1 >= e2(r.h) && r.ca) {
                                    try {
                                        r.ca()
                                    } catch (e) {}
                                    r.ca = void 0
                                }
                            } else
                                t1(r, 11)
                        } else if ((e.K || r.g == e) && tX(r),
                        !x(t))
                            for (i = r.Da.g.parse(t),
                            t = 0; t < i.length; t++) {
                                let o = i[t];
                                if (r.T = o[0],
                                o = o[1],
                                2 == r.G)
                                    if ("c" == o[0]) {
                                        r.K = o[1],
                                        r.ia = o[2];
                                        let t = o[3];
                                        null != t && (r.la = t,
                                        r.j.info("VER=" + r.la));
                                        let i = o[4];
                                        null != i && (r.Aa = i,
                                        r.j.info("SVER=" + r.Aa));
                                        let l = o[5];
                                        null != l && "number" == typeof l && 0 < l && (r.L = n = 1.5 * l,
                                        r.j.info("backChannelRequestTimeoutMs_=" + n)),
                                        n = r;
                                        let u = e.g;
                                        if (u) {
                                            let e = u.g ? u.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                                            if (e) {
                                                var s = n.h;
                                                s.g || -1 == e.indexOf("spdy") && -1 == e.indexOf("quic") && -1 == e.indexOf("h2") || (s.j = s.l,
                                                s.g = new Set,
                                                s.h && (e3(s, s.h),
                                                s.h = null))
                                            }
                                            if (n.D) {
                                                let e = u.g ? u.g.getResponseHeader("X-HTTP-Session-Id") : null;
                                                e && (n.ya = e,
                                                ti(n.I, n.D, e))
                                            }
                                        }
                                        if (r.G = 3,
                                        r.l && r.l.ua(),
                                        r.ba && (r.R = Date.now() - e.F,
                                        r.j.info("Handshake RTT: " + r.R + "ms")),
                                        (n = r).qa = t6(n, n.J ? n.ia : null, n.W),
                                        e.K) {
                                            e5(n.h, e);
                                            var a = n.L;
                                            a && (e.I = a),
                                            e.B && (eW(e),
                                            eG(e)),
                                            n.g = e
                                        } else
                                            tH(n);
                                        0 < r.i.length && tQ(r)
                                    } else
                                        "stop" != o[0] && "close" != o[0] || t1(r, 7);
                                else
                                    3 == r.G && ("stop" == o[0] || "close" == o[0] ? "stop" == o[0] ? t1(r, 7) : tq(r) : "noop" != o[0] && r.l && r.l.ta(o),
                                    r.v = 0)
                            }
                    }
                    ek(4)
                } catch (e) {}
            }
            eU.prototype.ca = function(e) {
                e = e.target;
                let t = this.M;
                t && 3 == tF(e) ? t.j() : this.Y(e)
            }
            ,
            eU.prototype.Y = function(e) {
                try {
                    if (e == this.g)
                        e: {
                            let v = tF(this.g);
                            var t = this.g.Ba();
                            let w = this.g.Z();
                            if (!(3 > v) && (3 != v || this.g && (this.h.h || this.g.oa() || tB(this.g)))) {
                                this.J || 4 != v || 7 == t || (8 == t || 0 >= w ? ek(3) : ek(2)),
                                eW(this);
                                var r = this.g.Z();
                                this.X = r;
                                t: if (e$(this)) {
                                    var n = tB(this.g);
                                    e = "";
                                    var i = n.length
                                      , s = 4 == tF(this.g);
                                    if (!this.h.i) {
                                        if ("undefined" == typeof TextDecoder) {
                                            eY(this),
                                            eJ(this);
                                            var a = "";
                                            break t
                                        }
                                        this.h.i = new y.TextDecoder
                                    }
                                    for (t = 0; t < i; t++)
                                        this.h.h = !0,
                                        e += this.h.i.decode(n[t], {
                                            stream: !(s && t == i - 1)
                                        });
                                    n.length = 0,
                                    this.h.g += e,
                                    this.C = 0,
                                    a = this.h.g
                                } else
                                    a = this.g.oa();
                                if (this.o = 200 == r,
                                o = this.i,
                                l = this.u,
                                u = this.A,
                                h = this.l,
                                c = this.R,
                                d = r,
                                o.info(function() {
                                    return "XMLHTTP RESP (" + h + ") [ attempt " + c + "]: " + l + "\n" + u + "\n" + v + " " + d
                                }),
                                this.o) {
                                    if (this.T && !this.K) {
                                        t: {
                                            if (this.g) {
                                                var o, l, u, h, c, d, f, p = this.g;
                                                if ((f = p.g ? p.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !x(f)) {
                                                    var g = f;
                                                    break t
                                                }
                                            }
                                            g = null
                                        }
                                        if (r = g)
                                            eL(this.i, this.l, r, "Initial handshake response via X-HTTP-Initial-Response"),
                                            this.K = !0,
                                            eX(this, r);
                                        else {
                                            this.o = !1,
                                            this.s = 3,
                                            eO(12),
                                            eY(this),
                                            eJ(this);
                                            break e
                                        }
                                    }
                                    if (this.P) {
                                        let e;
                                        for (r = !0; !this.J && this.C < a.length; )
                                            if ((e = function(e, t) {
                                                var r = e.C
                                                  , n = t.indexOf("\n", r);
                                                return -1 == n ? ez : isNaN(r = Number(t.substring(r, n))) ? ej : (n += 1) + r > t.length ? ez : (t = t.slice(n, n + r),
                                                e.C = n + r,
                                                t)
                                            }(this, a)) == ez) {
                                                4 == v && (this.s = 4,
                                                eO(14),
                                                r = !1),
                                                eL(this.i, this.l, null, "[Incomplete Response]");
                                                break
                                            } else if (e == ej) {
                                                this.s = 4,
                                                eO(15),
                                                eL(this.i, this.l, a, "[Invalid Chunk]"),
                                                r = !1;
                                                break
                                            } else
                                                eL(this.i, this.l, e, null),
                                                eX(this, e);
                                        if (e$(this) && 0 != this.C && (this.h.g = this.h.g.slice(this.C),
                                        this.C = 0),
                                        4 != v || 0 != a.length || this.h.h || (this.s = 1,
                                        eO(16),
                                        r = !1),
                                        this.o = this.o && r,
                                        r) {
                                            if (0 < a.length && !this.W) {
                                                this.W = !0;
                                                var m = this.j;
                                                m.g == this && m.ba && !m.M && (m.j.info("Great, no buffering proxy detected. Bytes received: " + a.length),
                                                tJ(m),
                                                m.M = !0,
                                                eO(11))
                                            }
                                        } else
                                            eL(this.i, this.l, a, "[Invalid Chunked Response]"),
                                            eY(this),
                                            eJ(this)
                                    } else
                                        eL(this.i, this.l, a, null),
                                        eX(this, a);
                                    4 == v && eY(this),
                                    this.o && !this.J && (4 == v ? tZ(this.j, this) : (this.o = !1,
                                    eG(this)))
                                } else
                                    (function(e) {
                                        let t = {};
                                        e = (e.g && 2 <= tF(e) && e.g.getAllResponseHeaders() || "").split("\r\n");
                                        for (let n = 0; n < e.length; n++) {
                                            if (x(e[n]))
                                                continue;
                                            var r = function(e) {
                                                var t = 1;
                                                e = e.split(":");
                                                let r = [];
                                                for (; 0 < t && e.length; )
                                                    r.push(e.shift()),
                                                    t--;
                                                return e.length && r.push(e.join(":")),
                                                r
                                            }(e[n]);
                                            let i = r[0];
                                            if ("string" != typeof (r = r[1]))
                                                continue;
                                            r = r.trim();
                                            let s = t[i] || [];
                                            t[i] = s,
                                            s.push(r)
                                        }
                                        var n = function(e) {
                                            return e.join(", ")
                                        };
                                        for (let e in t)
                                            n.call(void 0, t[e], e, t)
                                    }
                                    )(this.g),
                                    400 == r && 0 < a.indexOf("Unknown SID") ? (this.s = 3,
                                    eO(12)) : (this.s = 0,
                                    eO(13)),
                                    eY(this),
                                    eJ(this)
                            }
                        }
                } catch (e) {} finally {}
            }
            ,
            eU.prototype.cancel = function() {
                this.J = !0,
                eY(this)
            }
            ,
            eU.prototype.ba = function() {
                var e, t;
                this.B = null;
                let r = Date.now();
                0 <= r - this.S ? (e = this.i,
                t = this.A,
                e.info(function() {
                    return "TIMEOUT: " + t
                }),
                2 != this.L && (ek(),
                eO(17)),
                eY(this),
                this.s = 2,
                eJ(this)) : eH(this, this.S - r)
            }
            ;
            var eZ = class {
                constructor(e, t) {
                    this.g = e,
                    this.map = t
                }
            }
            ;
            function e0(e) {
                this.l = e || 10,
                e = y.PerformanceNavigationTiming ? 0 < (e = y.performance.getEntriesByType("navigation")).length && ("hq" == e[0].nextHopProtocol || "h2" == e[0].nextHopProtocol) : !!(y.chrome && y.chrome.loadTimes && y.chrome.loadTimes() && y.chrome.loadTimes().wasFetchedViaSpdy),
                this.j = e ? this.l : 1,
                this.g = null,
                1 < this.j && (this.g = new Set),
                this.h = null,
                this.i = []
            }
            function e1(e) {
                return !!e.h || !!e.g && e.g.size >= e.j
            }
            function e2(e) {
                return e.h ? 1 : e.g ? e.g.size : 0
            }
            function e6(e, t) {
                return e.h ? e.h == t : !!e.g && e.g.has(t)
            }
            function e3(e, t) {
                e.g ? e.g.add(t) : e.h = t
            }
            function e5(e, t) {
                e.h && e.h == t ? e.h = null : e.g && e.g.has(t) && e.g.delete(t)
            }
            function e4(e) {
                if (null != e.h)
                    return e.i.concat(e.h.D);
                if (null != e.g && 0 !== e.g.size) {
                    let t = e.i;
                    for (let r of e.g.values())
                        t = t.concat(r.D);
                    return t
                }
                return S(e.i)
            }
            function e8(e, t) {
                if (e.forEach && "function" == typeof e.forEach)
                    e.forEach(t, void 0);
                else if (v(e) || "string" == typeof e)
                    Array.prototype.forEach.call(e, t, void 0);
                else
                    for (var r = function(e) {
                        if (e.na && "function" == typeof e.na)
                            return e.na();
                        if (!e.V || "function" != typeof e.V) {
                            if ("undefined" != typeof Map && e instanceof Map)
                                return Array.from(e.keys());
                            if (!("undefined" != typeof Set && e instanceof Set)) {
                                if (v(e) || "string" == typeof e) {
                                    var t = [];
                                    e = e.length;
                                    for (var r = 0; r < e; r++)
                                        t.push(r);
                                    return t
                                }
                                for (let n in t = [],
                                r = 0,
                                e)
                                    t[r++] = n;
                                return t
                            }
                        }
                    }(e), n = function(e) {
                        if (e.V && "function" == typeof e.V)
                            return e.V();
                        if ("undefined" != typeof Map && e instanceof Map || "undefined" != typeof Set && e instanceof Set)
                            return Array.from(e.values());
                        if ("string" == typeof e)
                            return e.split("");
                        if (v(e)) {
                            for (var t = [], r = e.length, n = 0; n < r; n++)
                                t.push(e[n]);
                            return t
                        }
                        for (n in t = [],
                        r = 0,
                        e)
                            t[r++] = e[n];
                        return t
                    }(e), i = n.length, s = 0; s < i; s++)
                        t.call(void 0, n[s], r && r[s], e)
            }
            e0.prototype.cancel = function() {
                if (this.i = e4(this),
                this.h)
                    this.h.cancel(),
                    this.h = null;
                else if (this.g && 0 !== this.g.size) {
                    for (let e of this.g.values())
                        e.cancel();
                    this.g.clear()
                }
            }
            ;
            var e7 = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
            function e9(e) {
                if (this.g = this.o = this.j = "",
                this.s = null,
                this.m = this.l = "",
                this.h = !1,
                e instanceof e9) {
                    this.h = e.h,
                    tt(this, e.j),
                    this.o = e.o,
                    this.g = e.g,
                    tr(this, e.s),
                    this.l = e.l;
                    var t = e.i
                      , r = new tp;
                    r.i = t.i,
                    t.g && (r.g = new Map(t.g),
                    r.h = t.h),
                    tn(this, r),
                    this.m = e.m
                } else
                    e && (t = String(e).match(e7)) ? (this.h = !1,
                    tt(this, t[1] || "", !0),
                    this.o = ta(t[2] || ""),
                    this.g = ta(t[3] || "", !0),
                    tr(this, t[4]),
                    this.l = ta(t[5] || "", !0),
                    tn(this, t[6] || "", !0),
                    this.m = ta(t[7] || "")) : (this.h = !1,
                    this.i = new tp(null,this.h))
            }
            function te(e) {
                return new e9(e)
            }
            function tt(e, t, r) {
                e.j = r ? ta(t, !0) : t,
                e.j && (e.j = e.j.replace(/:$/, ""))
            }
            function tr(e, t) {
                if (t) {
                    if (isNaN(t = Number(t)) || 0 > t)
                        throw Error("Bad port number " + t);
                    e.s = t
                } else
                    e.s = null
            }
            function tn(e, t, r) {
                var n, i;
                t instanceof tp ? (e.i = t,
                n = e.i,
                (i = e.h) && !n.j && (tg(n),
                n.i = null,
                n.g.forEach(function(e, t) {
                    var r = t.toLowerCase();
                    t != r && (tm(this, t),
                    tv(this, r, e))
                }, n)),
                n.j = i) : (r || (t = to(t, td)),
                e.i = new tp(t,e.h))
            }
            function ti(e, t, r) {
                e.i.set(t, r)
            }
            function ts(e) {
                return ti(e, "zx", Math.floor(0x80000000 * Math.random()).toString(36) + Math.abs(Math.floor(0x80000000 * Math.random()) ^ Date.now()).toString(36)),
                e
            }
            function ta(e, t) {
                return e ? t ? decodeURI(e.replace(/%25/g, "%2525")) : decodeURIComponent(e) : ""
            }
            function to(e, t, r) {
                return "string" == typeof e ? (e = encodeURI(e).replace(t, tl),
                r && (e = e.replace(/%25([0-9a-fA-F]{2})/g, "%$1")),
                e) : null
            }
            function tl(e) {
                return "%" + ((e = e.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & e).toString(16)
            }
            e9.prototype.toString = function() {
                var e = []
                  , t = this.j;
                t && e.push(to(t, tu, !0), ":");
                var r = this.g;
                return (r || "file" == t) && (e.push("//"),
                (t = this.o) && e.push(to(t, tu, !0), "@"),
                e.push(encodeURIComponent(String(r)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")),
                null != (r = this.s) && e.push(":", String(r))),
                (r = this.l) && (this.g && "/" != r.charAt(0) && e.push("/"),
                e.push(to(r, "/" == r.charAt(0) ? tc : th, !0))),
                (r = this.i.toString()) && e.push("?", r),
                (r = this.m) && e.push("#", to(r, tf)),
                e.join("")
            }
            ;
            var tu = /[#\/\?@]/g
              , th = /[#\?:]/g
              , tc = /[#\?]/g
              , td = /[#\?@]/g
              , tf = /#/g;
            function tp(e, t) {
                this.h = this.g = null,
                this.i = e || null,
                this.j = !!t
            }
            function tg(e) {
                e.g || (e.g = new Map,
                e.h = 0,
                e.i && function(e, t) {
                    if (e) {
                        e = e.split("&");
                        for (var r = 0; r < e.length; r++) {
                            var n = e[r].indexOf("=")
                              , i = null;
                            if (0 <= n) {
                                var s = e[r].substring(0, n);
                                i = e[r].substring(n + 1)
                            } else
                                s = e[r];
                            t(s, i ? decodeURIComponent(i.replace(/\+/g, " ")) : "")
                        }
                    }
                }(e.i, function(t, r) {
                    e.add(decodeURIComponent(t.replace(/\+/g, " ")), r)
                }))
            }
            function tm(e, t) {
                tg(e),
                t = tw(e, t),
                e.g.has(t) && (e.i = null,
                e.h -= e.g.get(t).length,
                e.g.delete(t))
            }
            function ty(e, t) {
                return tg(e),
                t = tw(e, t),
                e.g.has(t)
            }
            function tv(e, t, r) {
                tm(e, t),
                0 < r.length && (e.i = null,
                e.g.set(tw(e, t), S(r)),
                e.h += r.length)
            }
            function tw(e, t) {
                return t = String(t),
                e.j && (t = t.toLowerCase()),
                t
            }
            function tb(e, t, r, n, i) {
                try {
                    i && (i.onload = null,
                    i.onerror = null,
                    i.onabort = null,
                    i.ontimeout = null),
                    n(r)
                } catch (e) {}
            }
            function tE() {
                this.g = new ew
            }
            function tI(e) {
                this.l = e.Ub || null,
                this.j = e.eb || !1
            }
            function t_(e, t) {
                eu.call(this),
                this.D = e,
                this.o = t,
                this.m = void 0,
                this.status = this.readyState = 0,
                this.responseType = this.responseText = this.response = this.statusText = "",
                this.onreadystatechange = null,
                this.u = new Headers,
                this.h = null,
                this.B = "GET",
                this.A = "",
                this.g = !1,
                this.v = this.j = this.l = null
            }
            function tT(e) {
                e.j.read().then(e.Pa.bind(e)).catch(e.ga.bind(e))
            }
            function tS(e) {
                e.readyState = 4,
                e.l = null,
                e.j = null,
                e.v = null,
                tC(e)
            }
            function tC(e) {
                e.onreadystatechange && e.onreadystatechange.call(e)
            }
            function tx(e) {
                let t = "";
                return N(e, function(e, r) {
                    t += r,
                    t += ":",
                    t += e,
                    t += "\r\n"
                }),
                t
            }
            function tA(e, t, r) {
                e: {
                    for (n in r) {
                        var n = !1;
                        break e
                    }
                    n = !0
                }
                n || (r = tx(r),
                "string" == typeof e ? null != r && encodeURIComponent(String(r)) : ti(e, t, r))
            }
            function tD(e) {
                eu.call(this),
                this.headers = new Map,
                this.o = e || null,
                this.h = !1,
                this.v = this.g = null,
                this.D = "",
                this.m = 0,
                this.l = "",
                this.j = this.B = this.u = this.A = !1,
                this.I = null,
                this.H = "",
                this.J = !1
            }
            (r = tp.prototype).add = function(e, t) {
                tg(this),
                this.i = null,
                e = tw(this, e);
                var r = this.g.get(e);
                return r || this.g.set(e, r = []),
                r.push(t),
                this.h += 1,
                this
            }
            ,
            r.forEach = function(e, t) {
                tg(this),
                this.g.forEach(function(r, n) {
                    r.forEach(function(r) {
                        e.call(t, r, n, this)
                    }, this)
                }, this)
            }
            ,
            r.na = function() {
                tg(this);
                let e = Array.from(this.g.values())
                  , t = Array.from(this.g.keys())
                  , r = [];
                for (let n = 0; n < t.length; n++) {
                    let i = e[n];
                    for (let e = 0; e < i.length; e++)
                        r.push(t[n])
                }
                return r
            }
            ,
            r.V = function(e) {
                tg(this);
                let t = [];
                if ("string" == typeof e)
                    ty(this, e) && (t = t.concat(this.g.get(tw(this, e))));
                else {
                    e = Array.from(this.g.values());
                    for (let r = 0; r < e.length; r++)
                        t = t.concat(e[r])
                }
                return t
            }
            ,
            r.set = function(e, t) {
                return tg(this),
                this.i = null,
                ty(this, e = tw(this, e)) && (this.h -= this.g.get(e).length),
                this.g.set(e, [t]),
                this.h += 1,
                this
            }
            ,
            r.get = function(e, t) {
                return e && 0 < (e = this.V(e)).length ? String(e[0]) : t
            }
            ,
            r.toString = function() {
                if (this.i)
                    return this.i;
                if (!this.g)
                    return "";
                let e = []
                  , t = Array.from(this.g.keys());
                for (var r = 0; r < t.length; r++) {
                    var n = t[r];
                    let s = encodeURIComponent(String(n))
                      , a = this.V(n);
                    for (n = 0; n < a.length; n++) {
                        var i = s;
                        "" !== a[n] && (i += "=" + encodeURIComponent(String(a[n]))),
                        e.push(i)
                    }
                }
                return this.i = e.join("&")
            }
            ,
            T(tI, eb),
            tI.prototype.g = function() {
                return new t_(this.l,this.j)
            }
            ,
            tI.prototype.i = (e = {},
            function() {
                return e
            }
            ),
            T(t_, eu),
            (r = t_.prototype).open = function(e, t) {
                if (0 != this.readyState)
                    throw this.abort(),
                    Error("Error reopening a connection");
                this.B = e,
                this.A = t,
                this.readyState = 1,
                tC(this)
            }
            ,
            r.send = function(e) {
                if (1 != this.readyState)
                    throw this.abort(),
                    Error("need to call open() first. ");
                this.g = !0;
                let t = {
                    headers: this.u,
                    method: this.B,
                    credentials: this.m,
                    cache: void 0
                };
                e && (t.body = e),
                (this.D || y).fetch(new Request(this.A,t)).then(this.Sa.bind(this), this.ga.bind(this))
            }
            ,
            r.abort = function() {
                this.response = this.responseText = "",
                this.u = new Headers,
                this.status = 0,
                this.j && this.j.cancel("Request was aborted.").catch( () => {}
                ),
                1 <= this.readyState && this.g && 4 != this.readyState && (this.g = !1,
                tS(this)),
                this.readyState = 0
            }
            ,
            r.Sa = function(e) {
                if (this.g && (this.l = e,
                this.h || (this.status = this.l.status,
                this.statusText = this.l.statusText,
                this.h = e.headers,
                this.readyState = 2,
                tC(this)),
                this.g && (this.readyState = 3,
                tC(this),
                this.g)))
                    if ("arraybuffer" === this.responseType)
                        e.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
                    else if (void 0 !== y.ReadableStream && "body"in e) {
                        if (this.j = e.body.getReader(),
                        this.o) {
                            if (this.responseType)
                                throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
                            this.response = []
                        } else
                            this.response = this.responseText = "",
                            this.v = new TextDecoder;
                        tT(this)
                    } else
                        e.text().then(this.Ra.bind(this), this.ga.bind(this))
            }
            ,
            r.Pa = function(e) {
                if (this.g) {
                    if (this.o && e.value)
                        this.response.push(e.value);
                    else if (!this.o) {
                        var t = e.value ? e.value : new Uint8Array(0);
                        (t = this.v.decode(t, {
                            stream: !e.done
                        })) && (this.response = this.responseText += t)
                    }
                    e.done ? tS(this) : tC(this),
                    3 == this.readyState && tT(this)
                }
            }
            ,
            r.Ra = function(e) {
                this.g && (this.response = this.responseText = e,
                tS(this))
            }
            ,
            r.Qa = function(e) {
                this.g && (this.response = e,
                tS(this))
            }
            ,
            r.ga = function() {
                this.g && tS(this)
            }
            ,
            r.setRequestHeader = function(e, t) {
                this.u.append(e, t)
            }
            ,
            r.getResponseHeader = function(e) {
                return this.h && this.h.get(e.toLowerCase()) || ""
            }
            ,
            r.getAllResponseHeaders = function() {
                if (!this.h)
                    return "";
                let e = []
                  , t = this.h.entries();
                for (var r = t.next(); !r.done; )
                    e.push((r = r.value)[0] + ": " + r[1]),
                    r = t.next();
                return e.join("\r\n")
            }
            ,
            Object.defineProperty(t_.prototype, "withCredentials", {
                get: function() {
                    return "include" === this.m
                },
                set: function(e) {
                    this.m = e ? "include" : "same-origin"
                }
            }),
            T(tD, eu);
            var tk = /^https?$/i
              , tN = ["POST", "PUT"];
            function tO(e, t) {
                e.h = !1,
                e.g && (e.j = !0,
                e.g.abort(),
                e.j = !1),
                e.l = t,
                e.m = 5,
                tR(e),
                tP(e)
            }
            function tR(e) {
                e.A || (e.A = !0,
                eh(e, "complete"),
                eh(e, "error"))
            }
            function tM(e) {
                if (e.h && void 0 !== m && (!e.v[1] || 4 != tF(e) || 2 != e.Z())) {
                    if (e.u && 4 == tF(e))
                        ed(e.Ea, 0, e);
                    else if (eh(e, "readystatechange"),
                    4 == tF(e)) {
                        e.h = !1;
                        try {
                            let a = e.Z();
                            switch (a) {
                            case 200:
                            case 201:
                            case 202:
                            case 204:
                            case 206:
                            case 304:
                            case 1223:
                                var t, r, n = !0;
                                break;
                            default:
                                n = !1
                            }
                            if (!(t = n)) {
                                if (r = 0 === a) {
                                    var i = String(e.D).match(e7)[1] || null;
                                    !i && y.self && y.self.location && (i = y.self.location.protocol.slice(0, -1)),
                                    r = !tk.test(i ? i.toLowerCase() : "")
                                }
                                t = r
                            }
                            if (t)
                                eh(e, "complete"),
                                eh(e, "success");
                            else {
                                e.m = 6;
                                try {
                                    var s = 2 < tF(e) ? e.g.statusText : ""
                                } catch (e) {
                                    s = ""
                                }
                                e.l = s + " [" + e.Z() + "]",
                                tR(e)
                            }
                        } finally {
                            tP(e)
                        }
                    }
                }
            }
            function tP(e, t) {
                if (e.g) {
                    tL(e);
                    let r = e.g
                      , n = e.v[0] ? () => {}
                    : null;
                    e.g = null,
                    e.v = null,
                    t || eh(e, "ready");
                    try {
                        r.onreadystatechange = n
                    } catch (e) {}
                }
            }
            function tL(e) {
                e.I && (y.clearTimeout(e.I),
                e.I = null)
            }
            function tF(e) {
                return e.g ? e.g.readyState : 0
            }
            function tB(e) {
                try {
                    if (!e.g)
                        return null;
                    if ("response"in e.g)
                        return e.g.response;
                    switch (e.H) {
                    case "":
                    case "text":
                        return e.g.responseText;
                    case "arraybuffer":
                        if ("mozResponseArrayBuffer"in e.g)
                            return e.g.mozResponseArrayBuffer
                    }
                    return null
                } catch (e) {
                    return null
                }
            }
            function tV(e, t, r) {
                return r && r.internalChannelParams && r.internalChannelParams[e] || t
            }
            function tU(e) {
                this.Aa = 0,
                this.i = [],
                this.j = new eP,
                this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null,
                this.Ya = this.U = 0,
                this.Va = tV("failFast", !1, e),
                this.F = this.C = this.u = this.s = this.l = null,
                this.X = !0,
                this.za = this.T = -1,
                this.Y = this.v = this.B = 0,
                this.Ta = tV("baseRetryDelayMs", 5e3, e),
                this.cb = tV("retryDelaySeedMs", 1e4, e),
                this.Wa = tV("forwardChannelMaxRetries", 2, e),
                this.wa = tV("forwardChannelRequestTimeoutMs", 2e4, e),
                this.pa = e && e.xmlHttpFactory || void 0,
                this.Xa = e && e.Tb || void 0,
                this.Ca = e && e.useFetchStreams || !1,
                this.L = void 0,
                this.J = e && e.supportsCrossDomainXhr || !1,
                this.K = "",
                this.h = new e0(e && e.concurrentRequestLimit),
                this.Da = new tE,
                this.P = e && e.fastHandshake || !1,
                this.O = e && e.encodeInitMessageHeaders || !1,
                this.P && this.O && (this.O = !1),
                this.Ua = e && e.Rb || !1,
                e && e.xa && this.j.xa(),
                e && e.forceLongPolling && (this.X = !1),
                this.ba = !this.P && this.X && e && e.detectBufferingProxy || !1,
                this.ja = void 0,
                e && e.longPollingTimeout && 0 < e.longPollingTimeout && (this.ja = e.longPollingTimeout),
                this.ca = void 0,
                this.R = 0,
                this.M = !1,
                this.ka = this.A = null
            }
            function tq(e) {
                if (tz(e),
                3 == e.G) {
                    var t = e.U++
                      , r = te(e.I);
                    if (ti(r, "SID", e.K),
                    ti(r, "RID", t),
                    ti(r, "TYPE", "terminate"),
                    t$(e, r),
                    (t = new eU(e,e.j,t)).L = 2,
                    t.v = ts(te(r)),
                    r = !1,
                    y.navigator && y.navigator.sendBeacon)
                        try {
                            r = y.navigator.sendBeacon(t.v.toString(), "")
                        } catch (e) {}
                    !r && y.Image && ((new Image).src = t.v,
                    r = !0),
                    r || (t.g = t3(t.j, null),
                    t.g.ea(t.v)),
                    t.F = Date.now(),
                    eG(t)
                }
                t2(e)
            }
            function tj(e) {
                e.g && (tJ(e),
                e.g.cancel(),
                e.g = null)
            }
            function tz(e) {
                tj(e),
                e.u && (y.clearTimeout(e.u),
                e.u = null),
                tX(e),
                e.h.cancel(),
                e.s && ("number" == typeof e.s && y.clearTimeout(e.s),
                e.s = null)
            }
            function tQ(e) {
                if (!e1(e.h) && !e.s) {
                    e.s = !0;
                    var t = e.Ga;
                    F || U(),
                    B || (F(),
                    B = !0),
                    V.add(t, e),
                    e.B = 0
                }
            }
            function tK(e, t) {
                var r;
                r = t ? t.l : e.U++;
                let n = te(e.I);
                ti(n, "SID", e.K),
                ti(n, "RID", r),
                ti(n, "AID", e.T),
                t$(e, n),
                e.m && e.o && tA(n, e.m, e.o),
                r = new eU(e,e.j,r,e.B + 1),
                null === e.m && (r.H = e.o),
                t && (e.i = t.D.concat(e.i)),
                t = tG(e, r, 1e3),
                r.I = Math.round(.5 * e.wa) + Math.round(.5 * e.wa * Math.random()),
                e3(e.h, r),
                eQ(r, n, t)
            }
            function t$(e, t) {
                e.H && N(e.H, function(e, r) {
                    ti(t, r, e)
                }),
                e.l && e8({}, function(e, r) {
                    ti(t, r, e)
                })
            }
            function tG(e, t, r) {
                r = Math.min(e.i.length, r);
                var n = e.l ? I(e.l.Na, e.l, e) : null;
                e: {
                    var i = e.i;
                    let t = -1;
                    for (; ; ) {
                        let e = ["count=" + r];
                        -1 == t ? 0 < r ? (t = i[0].g,
                        e.push("ofs=" + t)) : t = 0 : e.push("ofs=" + t);
                        let s = !0;
                        for (let a = 0; a < r; a++) {
                            let r = i[a].g
                              , o = i[a].map;
                            if (0 > (r -= t))
                                t = Math.max(0, i[a].g - 100),
                                s = !1;
                            else
                                try {
                                    !function(e, t, r) {
                                        let n = r || "";
                                        try {
                                            e8(e, function(e, r) {
                                                let i = e;
                                                w(e) && (i = ey(e)),
                                                t.push(n + r + "=" + encodeURIComponent(i))
                                            })
                                        } catch (e) {
                                            throw t.push(n + "type=" + encodeURIComponent("_badmap")),
                                            e
                                        }
                                    }(o, e, "req" + r + "_")
                                } catch (e) {
                                    n && n(o)
                                }
                        }
                        if (s) {
                            n = e.join("&");
                            break e
                        }
                    }
                }
                return t.D = e = e.i.splice(0, r),
                n
            }
            function tH(e) {
                if (!e.g && !e.u) {
                    e.Y = 1;
                    var t = e.Fa;
                    F || U(),
                    B || (F(),
                    B = !0),
                    V.add(t, e),
                    e.v = 0
                }
            }
            function tW(e) {
                return !e.g && !e.u && !(3 <= e.v) && (e.Y++,
                e.u = eM(I(e.Fa, e), t0(e, e.v)),
                e.v++,
                !0)
            }
            function tJ(e) {
                null != e.A && (y.clearTimeout(e.A),
                e.A = null)
            }
            function tY(e) {
                e.g = new eU(e,e.j,"rpc",e.Y),
                null === e.m && (e.g.H = e.o),
                e.g.O = 0;
                var t = te(e.qa);
                ti(t, "RID", "rpc"),
                ti(t, "SID", e.K),
                ti(t, "AID", e.T),
                ti(t, "CI", e.F ? "0" : "1"),
                !e.F && e.ja && ti(t, "TO", e.ja),
                ti(t, "TYPE", "xmlhttp"),
                t$(e, t),
                e.m && e.o && tA(t, e.m, e.o),
                e.L && (e.g.I = e.L);
                var r = e.g;
                e = e.ia,
                r.L = 1,
                r.v = ts(te(t)),
                r.m = null,
                r.P = !0,
                eK(r, e)
            }
            function tX(e) {
                null != e.C && (y.clearTimeout(e.C),
                e.C = null)
            }
            function tZ(e, t) {
                var r, n = null;
                if (e.g == t) {
                    tX(e),
                    tJ(e),
                    e.g = null;
                    var i = 2
                } else {
                    if (!e6(e.h, t))
                        return;
                    n = t.D,
                    e5(e.h, t),
                    i = 1
                }
                if (0 != e.G) {
                    if (t.o)
                        if (1 == i) {
                            n = t.m ? t.m.length : 0,
                            t = Date.now() - t.F;
                            var s = e.B;
                            eh(i = eA(), new eR(i,n)),
                            tQ(e)
                        } else
                            tH(e);
                    else if (3 == (s = t.s) || 0 == s && 0 < t.X || !(1 == i && (r = t,
                    !(e2(e.h) >= e.h.j - !!e.s) && (e.s ? (e.i = r.D.concat(e.i),
                    !0) : 1 != e.G && 2 != e.G && !(e.B >= (e.Va ? 0 : e.Wa)) && (e.s = eM(I(e.Ga, e, r), t0(e, e.B)),
                    e.B++,
                    !0))) || 2 == i && tW(e)))
                        switch (n && 0 < n.length && ((t = e.h).i = t.i.concat(n)),
                        s) {
                        case 1:
                            t1(e, 5);
                            break;
                        case 4:
                            t1(e, 10);
                            break;
                        case 3:
                            t1(e, 6);
                            break;
                        default:
                            t1(e, 2)
                        }
                }
            }
            function t0(e, t) {
                let r = e.Ta + Math.floor(Math.random() * e.cb);
                return e.isActive() || (r *= 2),
                r * t
            }
            function t1(e, t) {
                if (e.j.info("Error code " + t),
                2 == t) {
                    var r = I(e.fb, e)
                      , n = e.Xa;
                    let t = !n;
                    n = new e9(n || "//www.google.com/images/cleardot.gif"),
                    y.location && "http" == y.location.protocol || tt(n, "https"),
                    ts(n),
                    t ? function(e, t) {
                        let r = new eP;
                        if (y.Image) {
                            let n = new Image;
                            n.onload = _(tb, r, "TestLoadImage: loaded", !0, t, n),
                            n.onerror = _(tb, r, "TestLoadImage: error", !1, t, n),
                            n.onabort = _(tb, r, "TestLoadImage: abort", !1, t, n),
                            n.ontimeout = _(tb, r, "TestLoadImage: timeout", !1, t, n),
                            y.setTimeout(function() {
                                n.ontimeout && n.ontimeout()
                            }, 1e4),
                            n.src = e
                        } else
                            t(!1)
                    }(n.toString(), r) : function(e, t) {
                        let r = new eP
                          , n = new AbortController
                          , i = setTimeout( () => {
                            n.abort(),
                            tb(r, "TestPingServer: timeout", !1, t)
                        }
                        , 1e4);
                        fetch(e, {
                            signal: n.signal
                        }).then(e => {
                            clearTimeout(i),
                            e.ok ? tb(r, "TestPingServer: ok", !0, t) : tb(r, "TestPingServer: server error", !1, t)
                        }
                        ).catch( () => {
                            clearTimeout(i),
                            tb(r, "TestPingServer: error", !1, t)
                        }
                        )
                    }(n.toString(), r)
                } else
                    eO(2);
                e.G = 0,
                e.l && e.l.sa(t),
                t2(e),
                tz(e)
            }
            function t2(e) {
                if (e.G = 0,
                e.ka = [],
                e.l) {
                    let t = e4(e.h);
                    (0 != t.length || 0 != e.i.length) && (C(e.ka, t),
                    C(e.ka, e.i),
                    e.h.i.length = 0,
                    S(e.i),
                    e.i.length = 0),
                    e.l.ra()
                }
            }
            function t6(e, t, r) {
                var n = r instanceof e9 ? te(r) : new e9(r);
                if ("" != n.g)
                    t && (n.g = t + "." + n.g),
                    tr(n, n.s);
                else {
                    var i = y.location;
                    n = i.protocol,
                    t = t ? t + "." + i.hostname : i.hostname,
                    i = +i.port;
                    var s = new e9(null);
                    n && tt(s, n),
                    t && (s.g = t),
                    i && tr(s, i),
                    r && (s.l = r),
                    n = s
                }
                return r = e.D,
                t = e.ya,
                r && t && ti(n, r, t),
                ti(n, "VER", e.la),
                t$(e, n),
                n
            }
            function t3(e, t, r) {
                if (t && !e.J)
                    throw Error("Can't create secondary domain capable XhrIo object.");
                return (t = new tD(e.Ca && !e.pa ? new tI({
                    eb: r
                }) : e.pa)).Ha(e.J),
                t
            }
            function t5() {}
            function t4() {}
            function t8(e, t) {
                eu.call(this),
                this.g = new tU(t),
                this.l = e,
                this.h = t && t.messageUrlParams || null,
                e = t && t.messageHeaders || null,
                t && t.clientProtocolHeaderRequired && (e ? e["X-Client-Protocol"] = "webchannel" : e = {
                    "X-Client-Protocol": "webchannel"
                }),
                this.g.o = e,
                e = t && t.initMessageHeaders || null,
                t && t.messageContentType && (e ? e["X-WebChannel-Content-Type"] = t.messageContentType : e = {
                    "X-WebChannel-Content-Type": t.messageContentType
                }),
                t && t.va && (e ? e["X-WebChannel-Client-Profile"] = t.va : e = {
                    "X-WebChannel-Client-Profile": t.va
                }),
                this.g.S = e,
                (e = t && t.Sb) && !x(e) && (this.g.m = e),
                this.v = t && t.supportsCrossDomainXhr || !1,
                this.u = t && t.sendRawJson || !1,
                (t = t && t.httpSessionIdParam) && !x(t) && (this.g.D = t,
                null !== (e = this.h) && t in e && t in (e = this.h) && delete e[t]),
                this.j = new re(this)
            }
            function t7(e) {
                eT.call(this),
                e.__headers__ && (this.headers = e.__headers__,
                this.statusCode = e.__status__,
                delete e.__headers__,
                delete e.__status__);
                var t = e.__sm__;
                if (t) {
                    e: {
                        for (let r in t) {
                            e = r;
                            break e
                        }
                        e = void 0
                    }
                    (this.i = e) && (e = this.i,
                    t = null !== t && e in t ? t[e] : void 0),
                    this.data = t
                } else
                    this.data = e
            }
            function t9() {
                eS.call(this),
                this.status = 1
            }
            function re(e) {
                this.g = e
            }
            (r = tD.prototype).Ha = function(e) {
                this.J = e
            }
            ,
            r.ea = function(e, r, n, i) {
                if (this.g)
                    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + e);
                r = r ? r.toUpperCase() : "GET",
                this.D = e,
                this.l = "",
                this.m = 0,
                this.A = !1,
                this.h = !0,
                this.g = this.o ? this.o.g() : t.g(),
                this.v = this.o ? eE(this.o) : eE(t),
                this.g.onreadystatechange = I(this.Ea, this);
                try {
                    this.B = !0,
                    this.g.open(r, String(e), !0),
                    this.B = !1
                } catch (e) {
                    tO(this, e);
                    return
                }
                if (e = n || "",
                n = new Map(this.headers),
                i)
                    if (Object.getPrototypeOf(i) === Object.prototype)
                        for (var s in i)
                            n.set(s, i[s]);
                    else if ("function" == typeof i.keys && "function" == typeof i.get)
                        for (let e of i.keys())
                            n.set(e, i.get(e));
                    else
                        throw Error("Unknown input type for opt_headers: " + String(i));
                for (let[t,a] of (i = Array.from(n.keys()).find(e => "content-type" == e.toLowerCase()),
                s = y.FormData && e instanceof y.FormData,
                !(0 <= Array.prototype.indexOf.call(tN, r, void 0)) || i || s || n.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"),
                n))
                    this.g.setRequestHeader(t, a);
                this.H && (this.g.responseType = this.H),
                "withCredentials"in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
                try {
                    tL(this),
                    this.u = !0,
                    this.g.send(e),
                    this.u = !1
                } catch (e) {
                    tO(this, e)
                }
            }
            ,
            r.abort = function(e) {
                this.g && this.h && (this.h = !1,
                this.j = !0,
                this.g.abort(),
                this.j = !1,
                this.m = e || 7,
                eh(this, "complete"),
                eh(this, "abort"),
                tP(this))
            }
            ,
            r.N = function() {
                this.g && (this.h && (this.h = !1,
                this.j = !0,
                this.g.abort(),
                this.j = !1),
                tP(this, !0)),
                tD.aa.N.call(this)
            }
            ,
            r.Ea = function() {
                this.s || (this.B || this.u || this.j ? tM(this) : this.bb())
            }
            ,
            r.bb = function() {
                tM(this)
            }
            ,
            r.isActive = function() {
                return !!this.g
            }
            ,
            r.Z = function() {
                try {
                    return 2 < tF(this) ? this.g.status : -1
                } catch (e) {
                    return -1
                }
            }
            ,
            r.oa = function() {
                try {
                    return this.g ? this.g.responseText : ""
                } catch (e) {
                    return ""
                }
            }
            ,
            r.Oa = function(e) {
                if (this.g) {
                    var t = this.g.responseText;
                    return e && 0 == t.indexOf(e) && (t = t.substring(e.length)),
                    ev(t)
                }
            }
            ,
            r.Ba = function() {
                return this.m
            }
            ,
            r.Ka = function() {
                return "string" == typeof this.l ? this.l : String(this.l)
            }
            ,
            (r = tU.prototype).la = 8,
            r.G = 1,
            r.connect = function(e, t, r, n) {
                eO(0),
                this.W = e,
                this.H = t || {},
                r && void 0 !== n && (this.H.OSID = r,
                this.H.OAID = n),
                this.F = this.X,
                this.I = t6(this, null, this.W),
                tQ(this)
            }
            ,
            r.Ga = function(e) {
                if (this.s)
                    if (this.s = null,
                    1 == this.G) {
                        if (!e) {
                            this.U = Math.floor(1e5 * Math.random()),
                            e = this.U++;
                            let i = new eU(this,this.j,e)
                              , s = this.o;
                            if (this.S && (s ? M(s = O(s), this.S) : s = this.S),
                            null !== this.m || this.O || (i.H = s,
                            s = null),
                            this.P)
                                e: {
                                    for (var t = 0, r = 0; r < this.i.length; r++) {
                                        t: {
                                            var n = this.i[r];
                                            if ("__data__"in n.map && "string" == typeof (n = n.map.__data__)) {
                                                n = n.length;
                                                break t
                                            }
                                            n = void 0
                                        }
                                        if (void 0 === n)
                                            break;
                                        if (4096 < (t += n)) {
                                            t = r;
                                            break e
                                        }
                                        if (4096 === t || r === this.i.length - 1) {
                                            t = r + 1;
                                            break e
                                        }
                                    }
                                    t = 1e3
                                }
                            else
                                t = 1e3;
                            t = tG(this, i, t),
                            ti(r = te(this.I), "RID", e),
                            ti(r, "CVER", 22),
                            this.D && ti(r, "X-HTTP-Session-Id", this.D),
                            t$(this, r),
                            s && (this.O ? t = "headers=" + encodeURIComponent(String(tx(s))) + "&" + t : this.m && tA(r, this.m, s)),
                            e3(this.h, i),
                            this.Ua && ti(r, "TYPE", "init"),
                            this.P ? (ti(r, "$req", t),
                            ti(r, "SID", "null"),
                            i.T = !0,
                            eQ(i, r, null)) : eQ(i, r, t),
                            this.G = 2
                        }
                    } else
                        3 == this.G && (e ? tK(this, e) : 0 == this.i.length || e1(this.h) || tK(this))
            }
            ,
            r.Fa = function() {
                if (this.u = null,
                tY(this),
                this.ba && !(this.M || null == this.g || 0 >= this.R)) {
                    var e = 2 * this.R;
                    this.j.info("BP detection timer enabled: " + e),
                    this.A = eM(I(this.ab, this), e)
                }
            }
            ,
            r.ab = function() {
                this.A && (this.A = null,
                this.j.info("BP detection timeout reached."),
                this.j.info("Buffering proxy detected and switch to long-polling!"),
                this.F = !1,
                this.M = !0,
                eO(10),
                tj(this),
                tY(this))
            }
            ,
            r.Za = function() {
                null != this.C && (this.C = null,
                tj(this),
                tW(this),
                eO(19))
            }
            ,
            r.fb = function(e) {
                e ? (this.j.info("Successfully pinged google.com"),
                eO(2)) : (this.j.info("Failed to ping google.com"),
                eO(1))
            }
            ,
            r.isActive = function() {
                return !!this.l && this.l.isActive(this)
            }
            ,
            (r = t5.prototype).ua = function() {}
            ,
            r.ta = function() {}
            ,
            r.sa = function() {}
            ,
            r.ra = function() {}
            ,
            r.isActive = function() {
                return !0
            }
            ,
            r.Na = function() {}
            ,
            t4.prototype.g = function(e, t) {
                return new t8(e,t)
            }
            ,
            T(t8, eu),
            t8.prototype.m = function() {
                this.g.l = this.j,
                this.v && (this.g.J = !0),
                this.g.connect(this.l, this.h || void 0)
            }
            ,
            t8.prototype.close = function() {
                tq(this.g)
            }
            ,
            t8.prototype.o = function(e) {
                var t = this.g;
                if ("string" == typeof e) {
                    var r = {};
                    r.__data__ = e,
                    e = r
                } else
                    this.u && ((r = {}).__data__ = ey(e),
                    e = r);
                t.i.push(new eZ(t.Ya++,e)),
                3 == t.G && tQ(t)
            }
            ,
            t8.prototype.N = function() {
                this.g.l = null,
                delete this.j,
                tq(this.g),
                delete this.g,
                t8.aa.N.call(this)
            }
            ,
            T(t7, eT),
            T(t9, eS),
            T(re, t5),
            re.prototype.ua = function() {
                eh(this.g, "a")
            }
            ,
            re.prototype.ta = function(e) {
                eh(this.g, new t7(e))
            }
            ,
            re.prototype.sa = function(e) {
                eh(this.g, new t9)
            }
            ,
            re.prototype.ra = function() {
                eh(this.g, "b")
            }
            ,
            t4.prototype.createWebChannel = t4.prototype.g,
            t8.prototype.send = t8.prototype.o,
            t8.prototype.open = t8.prototype.m,
            t8.prototype.close = t8.prototype.close,
            c = f.createWebChannelTransport = function() {
                return new t4
            }
            ,
            h = f.getStatEventTarget = function() {
                return eA()
            }
            ,
            u = f.Event = eC,
            l = f.Stat = {
                mb: 0,
                pb: 1,
                qb: 2,
                Jb: 3,
                Ob: 4,
                Lb: 5,
                Mb: 6,
                Kb: 7,
                Ib: 8,
                Nb: 9,
                PROXY: 10,
                NOPROXY: 11,
                Gb: 12,
                Cb: 13,
                Db: 14,
                Bb: 15,
                Eb: 16,
                Fb: 17,
                ib: 18,
                hb: 19,
                jb: 20
            },
            eF.NO_ERROR = 0,
            eF.TIMEOUT = 8,
            eF.HTTP_ERROR = 6,
            o = f.ErrorCode = eF,
            eB.COMPLETE = "complete",
            a = f.EventType = eB,
            eI.EventType = e_,
            e_.OPEN = "a",
            e_.CLOSE = "b",
            e_.ERROR = "c",
            e_.MESSAGE = "d",
            eu.prototype.listen = eu.prototype.K,
            s = f.WebChannel = eI,
            i = f.FetchXmlHttpFactory = tI,
            tD.prototype.listenOnce = tD.prototype.L,
            tD.prototype.getLastError = tD.prototype.Ka,
            tD.prototype.getLastErrorCode = tD.prototype.Ba,
            tD.prototype.getStatus = tD.prototype.Z,
            tD.prototype.getResponseJson = tD.prototype.Oa,
            tD.prototype.getResponseText = tD.prototype.oa,
            tD.prototype.send = tD.prototype.ea,
            tD.prototype.setWithCredentials = tD.prototype.Ha,
            n = f.XhrIo = tD
        }
        ).apply(void 0 !== d ? d : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
    ,
    51123: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                AbstractUserDataWriter: () => hP,
                AggregateField: () => ho,
                AggregateQuerySnapshot: () => hl,
                Bytes: () => hu,
                CACHE_SIZE_UNLIMITED: () => hs,
                CollectionReference: () => ht,
                DocumentReference: () => he,
                DocumentSnapshot: () => hB,
                FieldPath: () => hh,
                FieldValue: () => hc,
                Firestore: () => ha,
                FirestoreError: () => sk,
                GeoPoint: () => hd,
                LoadBundleTask: () => hi,
                PersistentCacheIndexManager: () => hX,
                Query: () => u9,
                QueryCompositeFilterConstraint: () => hk,
                QueryConstraint: () => hA,
                QueryDocumentSnapshot: () => hV,
                QueryEndAtConstraint: () => hM,
                QueryFieldFilterConstraint: () => hD,
                QueryLimitConstraint: () => hO,
                QueryOrderByConstraint: () => hN,
                QuerySnapshot: () => hU,
                QueryStartAtConstraint: () => hR,
                SnapshotMetadata: () => hF,
                Timestamp: () => sj,
                Transaction: () => hY,
                VectorValue: () => hf,
                WriteBatch: () => hW,
                _AutoId: () => sq,
                _ByteString: () => or,
                _DatabaseId: () => oh,
                _DocumentKey: () => sW,
                _EmptyAppCheckTokenProvider: () => sU,
                _EmptyAuthCredentialsProvider: () => sR,
                _FieldPath: () => sH,
                _TestingHooks: () => h0,
                _cast: () => nG,
                _debugAssert: () => T,
                _internalAggregationQueryToProtoRunAggregationQueryRequest: () => sS,
                _internalQueryToProtoQueryTarget: () => sT,
                _isBase64Available: () => X,
                _logWarn: () => w,
                _validateIsNotUsedTogether: () => nz,
                addDoc: () => i5,
                aggregateFieldEqual: () => iG,
                aggregateQuerySnapshotEqual: () => iH,
                and: () => ik,
                arrayRemove: () => sf,
                arrayUnion: () => sd,
                average: () => iK,
                clearIndexedDbPersistence: () => ie,
                collection: () => nJ,
                collectionGroup: () => nY,
                connectFirestoreEmulator: () => nW,
                count: () => i$,
                deleteAllPersistentCacheIndexes: () => sI,
                deleteDoc: () => i3,
                deleteField: () => sh,
                disableNetwork: () => ii,
                disablePersistentCacheIndexAutoCreation: () => sE,
                doc: () => nX,
                documentId: () => il,
                enableIndexedDbPersistence: () => n8,
                enableMultiTabIndexedDbPersistence: () => n7,
                enableNetwork: () => ir,
                enablePersistentCacheIndexAutoCreation: () => sb,
                endAt: () => iF,
                endBefore: () => iL,
                ensureFirestoreConfigured: () => n5,
                executeWrite: () => i7,
                getAggregateFromServer: () => st,
                getCountFromServer: () => se,
                getDoc: () => iJ,
                getDocFromCache: () => iY,
                getDocFromServer: () => iX,
                getDocs: () => iZ,
                getDocsFromCache: () => i0,
                getDocsFromServer: () => i1,
                getFirestore: () => n3,
                getPersistentCacheIndexManager: () => sw,
                increment: () => sp,
                initializeFirestore: () => n6,
                limit: () => iO,
                limitToLast: () => iR,
                loadBundle: () => ia,
                memoryEagerGarbageCollector: () => sr,
                memoryLocalCache: () => si,
                memoryLruGarbageCollector: () => sn,
                namedQuery: () => io,
                onSnapshot: () => i4,
                onSnapshotsInSync: () => i8,
                or: () => iD,
                orderBy: () => iN,
                persistentLocalCache: () => ss,
                persistentMultipleTabManager: () => so,
                persistentSingleTabManager: () => sa,
                query: () => ix,
                queryEqual: () => n0,
                refEqual: () => nZ,
                runTransaction: () => su,
                serverTimestamp: () => sc,
                setDoc: () => i2,
                setIndexConfiguration: () => sy,
                setLogLevel: () => m,
                snapshotEqual: () => iW,
                startAfter: () => iP,
                startAt: () => iM,
                sum: () => iQ,
                terminate: () => is,
                updateDoc: () => i6,
                vector: () => sg,
                waitForPendingWrites: () => it,
                where: () => iA,
                writeBatch: () => sm
            });
            var n, i, s, a, o = e.i(22271), l = e.i(9562);
            e.i(33661);
            var u = e.i(94334)
              , h = e.i(42289)
              , c = e.i(94083)
              , d = e.i(81015)
              , f = e.i(27218)
              , p = e.i(20466);
            let t = "@firebase/firestore"
              , r = "4.7.14";
            class sC {
                constructor(e) {
                    this.uid = e
                }
                isAuthenticated() {
                    return null != this.uid
                }
                toKey() {
                    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user"
                }
                isEqual(e) {
                    return e.uid === this.uid
                }
            }
            sC.UNAUTHENTICATED = new sC(null),
            sC.GOOGLE_CREDENTIALS = new sC("google-credentials-uid"),
            sC.FIRST_PARTY = new sC("first-party-uid"),
            sC.MOCK_USER = new sC("mock-user");
            let sx = "11.7.3"
              , sA = new c.Logger("@firebase/firestore");
            function g() {
                return sA.logLevel
            }
            function m(e) {
                sA.setLogLevel(e)
            }
            function y(e, ...t) {
                if (sA.logLevel <= c.LogLevel.DEBUG) {
                    let r = t.map(b);
                    sA.debug(`Firestore (${sx}): ${e}`, ...r)
                }
            }
            function v(e, ...t) {
                if (sA.logLevel <= c.LogLevel.ERROR) {
                    let r = t.map(b);
                    sA.error(`Firestore (${sx}): ${e}`, ...r)
                }
            }
            function w(e, ...t) {
                if (sA.logLevel <= c.LogLevel.WARN) {
                    let r = t.map(b);
                    sA.warn(`Firestore (${sx}): ${e}`, ...r)
                }
            }
            function b(e) {
                if ("string" == typeof e)
                    return e;
                try {
                    return JSON.stringify(e)
                } catch (t) {
                    return e
                }
            }
            function E(e, t, r) {
                let n = "Unexpected state";
                "string" == typeof t ? n = t : r = t,
                I(e, n, r)
            }
            function I(e, t, r) {
                let n = `FIRESTORE (${sx}) INTERNAL ASSERTION FAILED: ${t} (ID: ${e.toString(16)})`;
                if (void 0 !== r)
                    try {
                        n += " CONTEXT: " + JSON.stringify(r)
                    } catch (e) {
                        n += " CONTEXT: " + r
                    }
                throw v(n),
                Error(n)
            }
            function _(e, t, r, n) {
                let i = "Unexpected state";
                "string" == typeof r ? i = r : n = r,
                e || I(t, i, n)
            }
            function T(e, t) {
                e || E(57014, t)
            }
            let sD = {
                OK: "ok",
                CANCELLED: "cancelled",
                UNKNOWN: "unknown",
                INVALID_ARGUMENT: "invalid-argument",
                DEADLINE_EXCEEDED: "deadline-exceeded",
                NOT_FOUND: "not-found",
                ALREADY_EXISTS: "already-exists",
                PERMISSION_DENIED: "permission-denied",
                UNAUTHENTICATED: "unauthenticated",
                RESOURCE_EXHAUSTED: "resource-exhausted",
                FAILED_PRECONDITION: "failed-precondition",
                ABORTED: "aborted",
                OUT_OF_RANGE: "out-of-range",
                UNIMPLEMENTED: "unimplemented",
                INTERNAL: "internal",
                UNAVAILABLE: "unavailable",
                DATA_LOSS: "data-loss"
            };
            class sk extends d.FirebaseError {
                constructor(e, t) {
                    super(e, t),
                    this.code = e,
                    this.message = t,
                    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`
                }
            }
            class sN {
                constructor() {
                    this.promise = new Promise( (e, t) => {
                        this.resolve = e,
                        this.reject = t
                    }
                    )
                }
            }
            class sO {
                constructor(e, t) {
                    this.user = t,
                    this.type = "OAuth",
                    this.headers = new Map,
                    this.headers.set("Authorization", `Bearer ${e}`)
                }
            }
            class sR {
                getToken() {
                    return Promise.resolve(null)
                }
                invalidateToken() {}
                start(e, t) {
                    e.enqueueRetryable( () => t(sC.UNAUTHENTICATED))
                }
                shutdown() {}
            }
            class sM {
                constructor(e) {
                    this.token = e,
                    this.changeListener = null
                }
                getToken() {
                    return Promise.resolve(this.token)
                }
                invalidateToken() {}
                start(e, t) {
                    this.changeListener = t,
                    e.enqueueRetryable( () => t(this.token.user))
                }
                shutdown() {
                    this.changeListener = null
                }
            }
            class sP {
                constructor(e) {
                    this.t = e,
                    this.currentUser = sC.UNAUTHENTICATED,
                    this.i = 0,
                    this.forceRefresh = !1,
                    this.auth = null
                }
                start(e, t) {
                    _(void 0 === this.o, 42304);
                    let r = this.i
                      , n = e => this.i !== r ? (r = this.i,
                    t(e)) : Promise.resolve()
                      , i = new sN;
                    this.o = () => {
                        this.i++,
                        this.currentUser = this.u(),
                        i.resolve(),
                        i = new sN,
                        e.enqueueRetryable( () => n(this.currentUser))
                    }
                    ;
                    let s = () => {
                        let t = i;
                        e.enqueueRetryable(async () => {
                            await t.promise,
                            await n(this.currentUser)
                        }
                        )
                    }
                      , a = e => {
                        y("FirebaseAuthCredentialsProvider", "Auth detected"),
                        this.auth = e,
                        this.o && (this.auth.addAuthTokenListener(this.o),
                        s())
                    }
                    ;
                    this.t.onInit(e => a(e)),
                    setTimeout( () => {
                        if (!this.auth) {
                            let e = this.t.getImmediate({
                                optional: !0
                            });
                            e ? a(e) : (y("FirebaseAuthCredentialsProvider", "Auth not yet detected"),
                            i.resolve(),
                            i = new sN)
                        }
                    }
                    , 0),
                    s()
                }
                getToken() {
                    let e = this.i
                      , t = this.forceRefresh;
                    return this.forceRefresh = !1,
                    this.auth ? this.auth.getToken(t).then(t => this.i !== e ? (y("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."),
                    this.getToken()) : t ? (_("string" == typeof t.accessToken, 31837, {
                        l: t
                    }),
                    new sO(t.accessToken,this.currentUser)) : null) : Promise.resolve(null)
                }
                invalidateToken() {
                    this.forceRefresh = !0
                }
                shutdown() {
                    this.auth && this.o && this.auth.removeAuthTokenListener(this.o),
                    this.o = void 0
                }
                u() {
                    let e = this.auth && this.auth.getUid();
                    return _(null === e || "string" == typeof e, 2055, {
                        h: e
                    }),
                    new sC(e)
                }
            }
            class sL {
                constructor(e, t, r) {
                    this.P = e,
                    this.T = t,
                    this.I = r,
                    this.type = "FirstParty",
                    this.user = sC.FIRST_PARTY,
                    this.A = new Map
                }
                R() {
                    return this.I ? this.I() : null
                }
                get headers() {
                    this.A.set("X-Goog-AuthUser", this.P);
                    let e = this.R();
                    return e && this.A.set("Authorization", e),
                    this.T && this.A.set("X-Goog-Iam-Authorization-Token", this.T),
                    this.A
                }
            }
            class sF {
                constructor(e, t, r) {
                    this.P = e,
                    this.T = t,
                    this.I = r
                }
                getToken() {
                    return Promise.resolve(new sL(this.P,this.T,this.I))
                }
                start(e, t) {
                    e.enqueueRetryable( () => t(sC.FIRST_PARTY))
                }
                shutdown() {}
                invalidateToken() {}
            }
            class sB {
                constructor(e) {
                    this.value = e,
                    this.type = "AppCheck",
                    this.headers = new Map,
                    e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value)
                }
            }
            class sV {
                constructor(e, t) {
                    this.V = t,
                    this.forceRefresh = !1,
                    this.appCheck = null,
                    this.m = null,
                    this.p = null,
                    (0,
                    u._isFirebaseServerApp)(e) && e.settings.appCheckToken && (this.p = e.settings.appCheckToken)
                }
                start(e, t) {
                    _(void 0 === this.o, 3512);
                    let r = e => {
                        null != e.error && y("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);
                        let r = e.token !== this.m;
                        return this.m = e.token,
                        y("FirebaseAppCheckTokenProvider", `Received ${r ? "new" : "existing"} token.`),
                        r ? t(e.token) : Promise.resolve()
                    }
                    ;
                    this.o = t => {
                        e.enqueueRetryable( () => r(t))
                    }
                    ;
                    let n = e => {
                        y("FirebaseAppCheckTokenProvider", "AppCheck detected"),
                        this.appCheck = e,
                        this.o && this.appCheck.addTokenListener(this.o)
                    }
                    ;
                    this.V.onInit(e => n(e)),
                    setTimeout( () => {
                        if (!this.appCheck) {
                            let e = this.V.getImmediate({
                                optional: !0
                            });
                            e ? n(e) : y("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
                        }
                    }
                    , 0)
                }
                getToken() {
                    if (this.p)
                        return Promise.resolve(new sB(this.p));
                    let e = this.forceRefresh;
                    return this.forceRefresh = !1,
                    this.appCheck ? this.appCheck.getToken(e).then(e => e ? (_("string" == typeof e.token, 44558, {
                        tokenResult: e
                    }),
                    this.m = e.token,
                    new sB(e.token)) : null) : Promise.resolve(null)
                }
                invalidateToken() {
                    this.forceRefresh = !0
                }
                shutdown() {
                    this.appCheck && this.o && this.appCheck.removeTokenListener(this.o),
                    this.o = void 0
                }
            }
            class sU {
                getToken() {
                    return Promise.resolve(new sB(""))
                }
                invalidateToken() {}
                start(e, t) {}
                shutdown() {}
            }
            function S() {
                return new TextEncoder
            }
            class sq {
                static newId() {
                    let e = 62 * Math.floor(256 / 62)
                      , t = "";
                    for (; t.length < 20; ) {
                        let r = function(e) {
                            let t = "undefined" != typeof self && (self.crypto || self.msCrypto)
                              , r = new Uint8Array(40);
                            if (t && "function" == typeof t.getRandomValues)
                                t.getRandomValues(r);
                            else
                                for (let e = 0; e < 40; e++)
                                    r[e] = Math.floor(256 * Math.random());
                            return r
                        }(40);
                        for (let n = 0; n < r.length; ++n)
                            t.length < 20 && r[n] < e && (t += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(r[n] % 62))
                    }
                    return t
                }
            }
            function C(e, t) {
                return e < t ? -1 : +(e > t)
            }
            function x(e, t) {
                let r = 0;
                for (; r < e.length && r < t.length; ) {
                    let n = e.codePointAt(r)
                      , i = t.codePointAt(r);
                    if (n !== i) {
                        if (n < 128 && i < 128)
                            return C(n, i);
                        {
                            let s = S()
                              , a = function(e, t) {
                                for (let r = 0; r < e.length && r < t.length; ++r)
                                    if (e[r] !== t[r])
                                        return C(e[r], t[r]);
                                return C(e.length, t.length)
                            }(s.encode(A(e, r)), s.encode(A(t, r)));
                            return 0 !== a ? a : C(n, i)
                        }
                    }
                    r += n > 65535 ? 2 : 1
                }
                return C(e.length, t.length)
            }
            function A(e, t) {
                return e.codePointAt(t) > 65535 ? e.substring(t, t + 2) : e.substring(t, t + 1)
            }
            function D(e, t, r) {
                return e.length === t.length && e.every( (e, n) => r(e, t[n]))
            }
            class sj {
                static now() {
                    return sj.fromMillis(Date.now())
                }
                static fromDate(e) {
                    return sj.fromMillis(e.getTime())
                }
                static fromMillis(e) {
                    let t = Math.floor(e / 1e3)
                      , r = Math.floor((e - 1e3 * t) * 1e6);
                    return new sj(t,r)
                }
                constructor(e, t) {
                    if (this.seconds = e,
                    this.nanoseconds = t,
                    t < 0 || t >= 1e9)
                        throw new sk(sD.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: " + t);
                    if (e < -0xe7791f700 || e >= 0x3afff44180)
                        throw new sk(sD.INVALID_ARGUMENT,"Timestamp seconds out of range: " + e)
                }
                toDate() {
                    return new Date(this.toMillis())
                }
                toMillis() {
                    return 1e3 * this.seconds + this.nanoseconds / 1e6
                }
                _compareTo(e) {
                    return this.seconds === e.seconds ? C(this.nanoseconds, e.nanoseconds) : C(this.seconds, e.seconds)
                }
                isEqual(e) {
                    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds
                }
                toString() {
                    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")"
                }
                toJSON() {
                    return {
                        seconds: this.seconds,
                        nanoseconds: this.nanoseconds
                    }
                }
                valueOf() {
                    return String(this.seconds - -0xe7791f700).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0")
                }
            }
            class sz {
                static fromTimestamp(e) {
                    return new sz(e)
                }
                static min() {
                    return new sz(new sj(0,0))
                }
                static max() {
                    return new sz(new sj(0x3afff4417f,0x3b9ac9ff))
                }
                constructor(e) {
                    this.timestamp = e
                }
                compareTo(e) {
                    return this.timestamp._compareTo(e.timestamp)
                }
                isEqual(e) {
                    return this.timestamp.isEqual(e.timestamp)
                }
                toMicroseconds() {
                    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
                }
                toString() {
                    return "SnapshotVersion(" + this.timestamp.toString() + ")"
                }
                toTimestamp() {
                    return this.timestamp
                }
            }
            let sQ = "__name__";
            class sK {
                constructor(e, t, r) {
                    void 0 === t ? t = 0 : t > e.length && E(637, {
                        offset: t,
                        range: e.length
                    }),
                    void 0 === r ? r = e.length - t : r > e.length - t && E(1746, {
                        length: r,
                        range: e.length - t
                    }),
                    this.segments = e,
                    this.offset = t,
                    this.len = r
                }
                get length() {
                    return this.len
                }
                isEqual(e) {
                    return 0 === sK.comparator(this, e)
                }
                child(e) {
                    let t = this.segments.slice(this.offset, this.limit());
                    return e instanceof sK ? e.forEach(e => {
                        t.push(e)
                    }
                    ) : t.push(e),
                    this.construct(t)
                }
                limit() {
                    return this.offset + this.length
                }
                popFirst(e) {
                    return e = void 0 === e ? 1 : e,
                    this.construct(this.segments, this.offset + e, this.length - e)
                }
                popLast() {
                    return this.construct(this.segments, this.offset, this.length - 1)
                }
                firstSegment() {
                    return this.segments[this.offset]
                }
                lastSegment() {
                    return this.get(this.length - 1)
                }
                get(e) {
                    return this.segments[this.offset + e]
                }
                isEmpty() {
                    return 0 === this.length
                }
                isPrefixOf(e) {
                    if (e.length < this.length)
                        return !1;
                    for (let t = 0; t < this.length; t++)
                        if (this.get(t) !== e.get(t))
                            return !1;
                    return !0
                }
                isImmediateParentOf(e) {
                    if (this.length + 1 !== e.length)
                        return !1;
                    for (let t = 0; t < this.length; t++)
                        if (this.get(t) !== e.get(t))
                            return !1;
                    return !0
                }
                forEach(e) {
                    for (let t = this.offset, r = this.limit(); t < r; t++)
                        e(this.segments[t])
                }
                toArray() {
                    return this.segments.slice(this.offset, this.limit())
                }
                static comparator(e, t) {
                    let r = Math.min(e.length, t.length);
                    for (let n = 0; n < r; n++) {
                        let r = sK.compareSegments(e.get(n), t.get(n));
                        if (0 !== r)
                            return r
                    }
                    return C(e.length, t.length)
                }
                static compareSegments(e, t) {
                    let r = sK.isNumericId(e)
                      , n = sK.isNumericId(t);
                    return r && !n ? -1 : !r && n ? 1 : r && n ? sK.extractNumericId(e).compare(sK.extractNumericId(t)) : x(e, t)
                }
                static isNumericId(e) {
                    return e.startsWith("__id") && e.endsWith("__")
                }
                static extractNumericId(e) {
                    return f.Integer.fromString(e.substring(4, e.length - 2))
                }
            }
            class s$ extends sK {
                construct(e, t, r) {
                    return new s$(e,t,r)
                }
                canonicalString() {
                    return this.toArray().join("/")
                }
                toString() {
                    return this.canonicalString()
                }
                toUriEncodedString() {
                    return this.toArray().map(encodeURIComponent).join("/")
                }
                static fromString(...e) {
                    let t = [];
                    for (let r of e) {
                        if (r.indexOf("//") >= 0)
                            throw new sk(sD.INVALID_ARGUMENT,`Invalid segment (${r}). Paths must not contain // in them.`);
                        t.push(...r.split("/").filter(e => e.length > 0))
                    }
                    return new s$(t)
                }
                static emptyPath() {
                    return new s$([])
                }
            }
            let sG = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
            class sH extends sK {
                construct(e, t, r) {
                    return new sH(e,t,r)
                }
                static isValidIdentifier(e) {
                    return sG.test(e)
                }
                canonicalString() {
                    return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"),
                    sH.isValidIdentifier(e) || (e = "`" + e + "`"),
                    e)).join(".")
                }
                toString() {
                    return this.canonicalString()
                }
                isKeyField() {
                    return 1 === this.length && this.get(0) === sQ
                }
                static keyField() {
                    return new sH([sQ])
                }
                static fromServerFormat(e) {
                    let t = []
                      , r = ""
                      , n = 0
                      , i = () => {
                        if (0 === r.length)
                            throw new sk(sD.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
                        t.push(r),
                        r = ""
                    }
                      , s = !1;
                    for (; n < e.length; ) {
                        let t = e[n];
                        if ("\\" === t) {
                            if (n + 1 === e.length)
                                throw new sk(sD.INVALID_ARGUMENT,"Path has trailing escape character: " + e);
                            let t = e[n + 1];
                            if ("\\" !== t && "." !== t && "`" !== t)
                                throw new sk(sD.INVALID_ARGUMENT,"Path has invalid escape sequence: " + e);
                            r += t,
                            n += 2
                        } else
                            "`" === t ? s = !s : "." !== t || s ? r += t : i(),
                            n++
                    }
                    if (i(),
                    s)
                        throw new sk(sD.INVALID_ARGUMENT,"Unterminated ` in path: " + e);
                    return new sH(t)
                }
                static emptyPath() {
                    return new sH([])
                }
            }
            class sW {
                constructor(e) {
                    this.path = e
                }
                static fromPath(e) {
                    return new sW(s$.fromString(e))
                }
                static fromName(e) {
                    return new sW(s$.fromString(e).popFirst(5))
                }
                static empty() {
                    return new sW(s$.emptyPath())
                }
                get collectionGroup() {
                    return this.path.popLast().lastSegment()
                }
                hasCollectionId(e) {
                    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e
                }
                getCollectionGroup() {
                    return this.path.get(this.path.length - 2)
                }
                getCollectionPath() {
                    return this.path.popLast()
                }
                isEqual(e) {
                    return null !== e && 0 === s$.comparator(this.path, e.path)
                }
                toString() {
                    return this.path.toString()
                }
                static comparator(e, t) {
                    return s$.comparator(e.path, t.path)
                }
                static isDocumentKey(e) {
                    return e.length % 2 == 0
                }
                static fromSegments(e) {
                    return new sW(new s$(e.slice()))
                }
            }
            class sJ {
                constructor(e, t, r, n) {
                    this.indexId = e,
                    this.collectionGroup = t,
                    this.fields = r,
                    this.indexState = n
                }
            }
            function k(e) {
                return e.fields.find(e => 2 === e.kind)
            }
            function N(e) {
                return e.fields.filter(e => 2 !== e.kind)
            }
            function O(e, t) {
                let r = C(e.collectionGroup, t.collectionGroup);
                if (0 !== r)
                    return r;
                for (let n = 0; n < Math.min(e.fields.length, t.fields.length); ++n)
                    if (0 !== (r = function(e, t) {
                        let r = sH.comparator(e.fieldPath, t.fieldPath);
                        return 0 !== r ? r : C(e.kind, t.kind)
                    }(e.fields[n], t.fields[n])))
                        return r;
                return C(e.fields.length, t.fields.length)
            }
            sJ.UNKNOWN_ID = -1;
            class sY {
                constructor(e, t) {
                    this.fieldPath = e,
                    this.kind = t
                }
            }
            class sX {
                constructor(e, t) {
                    this.sequenceNumber = e,
                    this.offset = t
                }
                static empty() {
                    return new sX(0,sZ.min())
                }
            }
            function R(e, t) {
                let r = e.toTimestamp().seconds
                  , n = e.toTimestamp().nanoseconds + 1;
                return new sZ(sz.fromTimestamp(1e9 === n ? new sj(r + 1,0) : new sj(r,n)),sW.empty(),t)
            }
            function M(e) {
                return new sZ(e.readTime,e.key,-1)
            }
            class sZ {
                constructor(e, t, r) {
                    this.readTime = e,
                    this.documentKey = t,
                    this.largestBatchId = r
                }
                static min() {
                    return new sZ(sz.min(),sW.empty(),-1)
                }
                static max() {
                    return new sZ(sz.max(),sW.empty(),-1)
                }
            }
            function P(e, t) {
                let r = e.readTime.compareTo(t.readTime);
                return 0 !== r || 0 !== (r = sW.comparator(e.documentKey, t.documentKey)) ? r : C(e.largestBatchId, t.largestBatchId)
            }
            let s0 = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
            class s1 {
                constructor() {
                    this.onCommittedListeners = []
                }
                addOnCommittedListener(e) {
                    this.onCommittedListeners.push(e)
                }
                raiseOnCommittedEvent() {
                    this.onCommittedListeners.forEach(e => e())
                }
            }
            async function L(e) {
                if (e.code !== sD.FAILED_PRECONDITION || e.message !== s0)
                    throw e;
                y("LocalStore", "Unexpectedly lost primary lease")
            }
            class s2 {
                constructor(e) {
                    this.nextCallback = null,
                    this.catchCallback = null,
                    this.result = void 0,
                    this.error = void 0,
                    this.isDone = !1,
                    this.callbackAttached = !1,
                    e(e => {
                        this.isDone = !0,
                        this.result = e,
                        this.nextCallback && this.nextCallback(e)
                    }
                    , e => {
                        this.isDone = !0,
                        this.error = e,
                        this.catchCallback && this.catchCallback(e)
                    }
                    )
                }
                catch(e) {
                    return this.next(void 0, e)
                }
                next(e, t) {
                    return this.callbackAttached && E(59440),
                    this.callbackAttached = !0,
                    this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new s2( (r, n) => {
                        this.nextCallback = t => {
                            this.wrapSuccess(e, t).next(r, n)
                        }
                        ,
                        this.catchCallback = e => {
                            this.wrapFailure(t, e).next(r, n)
                        }
                    }
                    )
                }
                toPromise() {
                    return new Promise( (e, t) => {
                        this.next(e, t)
                    }
                    )
                }
                wrapUserFunction(e) {
                    try {
                        let t = e();
                        return t instanceof s2 ? t : s2.resolve(t)
                    } catch (e) {
                        return s2.reject(e)
                    }
                }
                wrapSuccess(e, t) {
                    return e ? this.wrapUserFunction( () => e(t)) : s2.resolve(t)
                }
                wrapFailure(e, t) {
                    return e ? this.wrapUserFunction( () => e(t)) : s2.reject(t)
                }
                static resolve(e) {
                    return new s2( (t, r) => {
                        t(e)
                    }
                    )
                }
                static reject(e) {
                    return new s2( (t, r) => {
                        r(e)
                    }
                    )
                }
                static waitFor(e) {
                    return new s2( (t, r) => {
                        let n = 0
                          , i = 0
                          , s = !1;
                        e.forEach(e => {
                            ++n,
                            e.next( () => {
                                ++i,
                                s && i === n && t()
                            }
                            , e => r(e))
                        }
                        ),
                        s = !0,
                        i === n && t()
                    }
                    )
                }
                static or(e) {
                    let t = s2.resolve(!1);
                    for (let r of e)
                        t = t.next(e => e ? s2.resolve(e) : r());
                    return t
                }
                static forEach(e, t) {
                    let r = [];
                    return e.forEach( (e, n) => {
                        r.push(t.call(this, e, n))
                    }
                    ),
                    this.waitFor(r)
                }
                static mapArray(e, t) {
                    return new s2( (r, n) => {
                        let i = e.length
                          , s = Array(i)
                          , a = 0;
                        for (let o = 0; o < i; o++) {
                            let l = o;
                            t(e[l]).next(e => {
                                s[l] = e,
                                ++a === i && r(s)
                            }
                            , e => n(e))
                        }
                    }
                    )
                }
                static doWhile(e, t) {
                    return new s2( (r, n) => {
                        let i = () => {
                            !0 === e() ? t().next( () => {
                                i()
                            }
                            , n) : r()
                        }
                        ;
                        i()
                    }
                    )
                }
            }
            let s6 = "SimpleDb";
            class s3 {
                static open(e, t, r, n) {
                    try {
                        return new s3(t,e.transaction(n, r))
                    } catch (e) {
                        throw new s8(t,e)
                    }
                }
                constructor(e, t) {
                    this.action = e,
                    this.transaction = t,
                    this.aborted = !1,
                    this.S = new sN,
                    this.transaction.oncomplete = () => {
                        this.S.resolve()
                    }
                    ,
                    this.transaction.onabort = () => {
                        t.error ? this.S.reject(new s8(e,t.error)) : this.S.resolve()
                    }
                    ,
                    this.transaction.onerror = t => {
                        let r = U(t.target.error);
                        this.S.reject(new s8(e,r))
                    }
                }
                get D() {
                    return this.S.promise
                }
                abort(e) {
                    e && this.S.reject(e),
                    this.aborted || (y(s6, "Aborting transaction:", e ? e.message : "Client-initiated abort"),
                    this.aborted = !0,
                    this.transaction.abort())
                }
                v() {
                    let e = this.transaction;
                    this.aborted || "function" != typeof e.commit || e.commit()
                }
                store(e) {
                    return new s7(this.transaction.objectStore(e))
                }
            }
            class s5 {
                static delete(e) {
                    return y(s6, "Removing database:", e),
                    V((0,
                    d.getGlobal)().indexedDB.deleteDatabase(e)).toPromise()
                }
                static C() {
                    if (!(0,
                    d.isIndexedDBAvailable)())
                        return !1;
                    if (s5.F())
                        return !0;
                    let e = (0,
                    d.getUA)()
                      , t = s5.M(e)
                      , r = F(e);
                    return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || 0 < t && t < 10 || 0 < r && r < 4.5)
                }
                static F() {
                    var e;
                    return void 0 !== o.default && "YES" === (null == (e = o.default.__PRIVATE_env) ? void 0 : e.O)
                }
                static N(e, t) {
                    return e.store(t)
                }
                static M(e) {
                    let t = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i);
                    return Number(t ? t[1].split("_").slice(0, 2).join(".") : "-1")
                }
                constructor(e, t, r) {
                    this.name = e,
                    this.version = t,
                    this.B = r,
                    this.L = null,
                    12.2 === s5.M((0,
                    d.getUA)()) && v("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.")
                }
                async k(e) {
                    return this.db || (y(s6, "Opening database:", this.name),
                    this.db = await new Promise( (t, r) => {
                        let n = indexedDB.open(this.name, this.version);
                        n.onsuccess = e => {
                            t(e.target.result)
                        }
                        ,
                        n.onblocked = () => {
                            r(new s8(e,"Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."))
                        }
                        ,
                        n.onerror = t => {
                            let n = t.target.error;
                            "VersionError" === n.name ? r(new sk(sD.FAILED_PRECONDITION,"A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : "InvalidStateError" === n.name ? r(new sk(sD.FAILED_PRECONDITION,"Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + n)) : r(new s8(e,n))
                        }
                        ,
                        n.onupgradeneeded = e => {
                            y(s6, 'Database "' + this.name + '" requires upgrade from version:', e.oldVersion);
                            let t = e.target.result;
                            if (null !== this.L && this.L !== e.oldVersion)
                                throw Error(`refusing to open IndexedDB database due to potential corruption of the IndexedDB database data; this corruption could be caused by clicking the "clear site data" button in a web browser; try reloading the web page to re-initialize the IndexedDB database: lastClosedDbVersion=${this.L}, event.oldVersion=${e.oldVersion}, event.newVersion=${e.newVersion}, db.version=${t.version}`);
                            this.B.q(t, n.transaction, e.oldVersion, this.version).next( () => {
                                y(s6, "Database upgrade to version " + this.version + " complete")
                            }
                            )
                        }
                    }
                    ),
                    this.db.addEventListener("close", e => {
                        let t = e.target;
                        this.L = t.version
                    }
                    , {
                        passive: !0
                    })),
                    this.$ && (this.db.onversionchange = e => this.$(e)),
                    this.db
                }
                U(e) {
                    this.$ = e,
                    this.db && (this.db.onversionchange = t => e(t))
                }
                async runTransaction(e, t, r, n) {
                    let i = "readonly" === t
                      , s = 0;
                    for (; ; ) {
                        ++s;
                        try {
                            this.db = await this.k(e);
                            let t = s3.open(this.db, e, i ? "readonly" : "readwrite", r)
                              , s = n(t).next(e => (t.v(),
                            e)).catch(e => (t.abort(e),
                            s2.reject(e))).toPromise();
                            return s.catch( () => {}
                            ),
                            await t.D,
                            s
                        } catch (t) {
                            let e = "FirebaseError" !== t.name && s < 3;
                            if (y(s6, "Transaction failed with error:", t.message, "Retrying:", e),
                            this.close(),
                            !e)
                                return Promise.reject(t)
                        }
                    }
                }
                close() {
                    this.db && this.db.close(),
                    this.db = void 0
                }
            }
            function F(e) {
                let t = e.match(/Android ([\d.]+)/i);
                return Number(t ? t[1].split(".").slice(0, 2).join(".") : "-1")
            }
            class s4 {
                constructor(e) {
                    this.K = e,
                    this.W = !1,
                    this.G = null
                }
                get isDone() {
                    return this.W
                }
                get j() {
                    return this.G
                }
                set cursor(e) {
                    this.K = e
                }
                done() {
                    this.W = !0
                }
                H(e) {
                    this.G = e
                }
                delete() {
                    return V(this.K.delete())
                }
            }
            class s8 extends sk {
                constructor(e, t) {
                    super(sD.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${t}`),
                    this.name = "IndexedDbTransactionError"
                }
            }
            function B(e) {
                return "IndexedDbTransactionError" === e.name
            }
            class s7 {
                constructor(e) {
                    this.store = e
                }
                put(e, t) {
                    let r;
                    return void 0 !== t ? (y(s6, "PUT", this.store.name, e, t),
                    r = this.store.put(t, e)) : (y(s6, "PUT", this.store.name, "<auto-key>", e),
                    r = this.store.put(e)),
                    V(r)
                }
                add(e) {
                    return y(s6, "ADD", this.store.name, e, e),
                    V(this.store.add(e))
                }
                get(e) {
                    return V(this.store.get(e)).next(t => (void 0 === t && (t = null),
                    y(s6, "GET", this.store.name, e, t),
                    t))
                }
                delete(e) {
                    return y(s6, "DELETE", this.store.name, e),
                    V(this.store.delete(e))
                }
                count() {
                    return y(s6, "COUNT", this.store.name),
                    V(this.store.count())
                }
                J(e, t) {
                    let r = this.options(e, t)
                      , n = r.index ? this.store.index(r.index) : this.store;
                    if ("function" == typeof n.getAll) {
                        let e = n.getAll(r.range);
                        return new s2( (t, r) => {
                            e.onerror = e => {
                                r(e.target.error)
                            }
                            ,
                            e.onsuccess = e => {
                                t(e.target.result)
                            }
                        }
                        )
                    }
                    {
                        let e = this.cursor(r)
                          , t = [];
                        return this.Y(e, (e, r) => {
                            t.push(r)
                        }
                        ).next( () => t)
                    }
                }
                Z(e, t) {
                    let r = this.store.getAll(e, null === t ? void 0 : t);
                    return new s2( (e, t) => {
                        r.onerror = e => {
                            t(e.target.error)
                        }
                        ,
                        r.onsuccess = t => {
                            e(t.target.result)
                        }
                    }
                    )
                }
                X(e, t) {
                    y(s6, "DELETE ALL", this.store.name);
                    let r = this.options(e, t);
                    r.ee = !1;
                    let n = this.cursor(r);
                    return this.Y(n, (e, t, r) => r.delete())
                }
                te(e, t) {
                    let r;
                    t ? r = e : (r = {},
                    t = e);
                    let n = this.cursor(r);
                    return this.Y(n, t)
                }
                ne(e) {
                    let t = this.cursor({});
                    return new s2( (r, n) => {
                        t.onerror = e => {
                            n(U(e.target.error))
                        }
                        ,
                        t.onsuccess = t => {
                            let n = t.target.result;
                            n ? e(n.primaryKey, n.value).next(e => {
                                e ? n.continue() : r()
                            }
                            ) : r()
                        }
                    }
                    )
                }
                Y(e, t) {
                    let r = [];
                    return new s2( (n, i) => {
                        e.onerror = e => {
                            i(e.target.error)
                        }
                        ,
                        e.onsuccess = e => {
                            let i = e.target.result;
                            if (!i)
                                return void n();
                            let s = new s4(i)
                              , a = t(i.primaryKey, i.value, s);
                            if (a instanceof s2) {
                                let e = a.catch(e => (s.done(),
                                s2.reject(e)));
                                r.push(e)
                            }
                            s.isDone ? n() : null === s.j ? i.continue() : i.continue(s.j)
                        }
                    }
                    ).next( () => s2.waitFor(r))
                }
                options(e, t) {
                    let r;
                    return void 0 !== e && ("string" == typeof e ? r = e : t = e),
                    {
                        index: r,
                        range: t
                    }
                }
                cursor(e) {
                    let t = "next";
                    if (e.reverse && (t = "prev"),
                    e.index) {
                        let r = this.store.index(e.index);
                        return e.ee ? r.openKeyCursor(e.range, t) : r.openCursor(e.range, t)
                    }
                    return this.store.openCursor(e.range, t)
                }
            }
            function V(e) {
                return new s2( (t, r) => {
                    e.onsuccess = e => {
                        t(e.target.result)
                    }
                    ,
                    e.onerror = e => {
                        r(U(e.target.error))
                    }
                }
                )
            }
            let s9 = !1;
            function U(e) {
                let t = s5.M((0,
                d.getUA)());
                if (t >= 12.2 && t < 13) {
                    let t = "An internal error was encountered in the Indexed Database server";
                    if (e.message.indexOf(t) >= 0) {
                        let e = new sk("internal",`IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${t}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
                        return s9 || (s9 = !0,
                        setTimeout( () => {
                            throw e
                        }
                        , 0)),
                        e
                    }
                }
                return e
            }
            let ae = "IndexBackfiller";
            class at {
                constructor(e, t) {
                    this.asyncQueue = e,
                    this.re = t,
                    this.task = null
                }
                start() {
                    this.ie(15e3)
                }
                stop() {
                    this.task && (this.task.cancel(),
                    this.task = null)
                }
                get started() {
                    return null !== this.task
                }
                ie(e) {
                    y(ae, `Scheduled in ${e}ms`),
                    this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", e, async () => {
                        this.task = null;
                        try {
                            let e = await this.re.se();
                            y(ae, `Documents written: ${e}`)
                        } catch (e) {
                            B(e) ? y(ae, "Ignoring IndexedDB error during index backfill: ", e) : await L(e)
                        }
                        await this.ie(6e4)
                    }
                    )
                }
            }
            class ar {
                constructor(e, t) {
                    this.localStore = e,
                    this.persistence = t
                }
                async se(e=50) {
                    return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", t => this.oe(t, e))
                }
                oe(e, t) {
                    let r = new Set
                      , n = t
                      , i = !0;
                    return s2.doWhile( () => !0 === i && n > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(e).next(t => {
                        if (null !== t && !r.has(t))
                            return y(ae, `Processing collection: ${t}`),
                            this._e(e, t, n).next(e => {
                                n -= e,
                                r.add(t)
                            }
                            );
                        i = !1
                    }
                    )).next( () => t - n)
                }
                _e(e, t, r) {
                    return this.localStore.indexManager.getMinOffsetFromCollectionGroup(e, t).next(n => this.localStore.localDocuments.getNextDocuments(e, t, n, r).next(r => {
                        let i = r.changes;
                        return this.localStore.indexManager.updateIndexEntries(e, i).next( () => this.ae(n, r)).next(r => (y(ae, `Updating offset: ${r}`),
                        this.localStore.indexManager.updateCollectionGroup(e, t, r))).next( () => i.size)
                    }
                    ))
                }
                ae(e, t) {
                    let r = e;
                    return t.changes.forEach( (e, t) => {
                        let n = M(t);
                        P(n, r) > 0 && (r = n)
                    }
                    ),
                    new sZ(r.readTime,r.documentKey,Math.max(t.batchId, e.largestBatchId))
                }
            }
            class an {
                constructor(e, t) {
                    this.previousValue = e,
                    t && (t.sequenceNumberHandler = e => this.ue(e),
                    this.ce = e => t.writeSequenceNumber(e))
                }
                ue(e) {
                    return this.previousValue = Math.max(e, this.previousValue),
                    this.previousValue
                }
                next() {
                    let e = ++this.previousValue;
                    return this.ce && this.ce(e),
                    e
                }
            }
            function q(e) {
                return null == e
            }
            function j(e) {
                return 0 === e && 1 / e == -1 / 0
            }
            function z(e) {
                return "number" == typeof e && Number.isInteger(e) && !j(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER
            }
            function Q(e) {
                let t = "";
                for (let r = 0; r < e.length; r++)
                    t.length > 0 && (t += "\x01\x01"),
                    t = function(e, t) {
                        let r = t
                          , n = e.length;
                        for (let t = 0; t < n; t++) {
                            let n = e.charAt(t);
                            switch (n) {
                            case "\0":
                                r += "\x01\x10";
                                break;
                            case "\x01":
                                r += "\x01\x11";
                                break;
                            default:
                                r += n
                            }
                        }
                        return r
                    }(e.get(r), t);
                return t + "\x01\x01"
            }
            an.le = -1;
            function K(e) {
                let t = e.length;
                if (_(t >= 2, 64408, {
                    path: e
                }),
                2 === t)
                    return _("\x01" === e.charAt(0) && "\x01" === e.charAt(1), 56145, {
                        path: e
                    }),
                    s$.emptyPath();
                let r = t - 2
                  , n = []
                  , i = "";
                for (let s = 0; s < t; ) {
                    let t = e.indexOf("\x01", s);
                    switch ((t < 0 || t > r) && E(50515, {
                        path: e
                    }),
                    e.charAt(t + 1)) {
                    case "\x01":
                        let a, o = e.substring(s, t);
                        0 === i.length ? a = o : (i += o,
                        a = i,
                        i = ""),
                        n.push(a);
                        break;
                    case "\x10":
                        i += e.substring(s, t),
                        i += "\0";
                        break;
                    case "\x11":
                        i += e.substring(s, t + 1);
                        break;
                    default:
                        E(61167, {
                            path: e
                        })
                    }
                    s = t + 2
                }
                return new s$(n)
            }
            let ai = "remoteDocuments"
              , as = "owner"
              , aa = "owner"
              , ao = "mutationQueues"
              , al = "mutations"
              , au = "batchId"
              , ah = "userMutationsIndex"
              , ac = ["userId", "batchId"]
              , ad = {}
              , af = "documentMutations"
              , ap = "remoteDocumentsV14"
              , ag = ["prefixPath", "collectionGroup", "readTime", "documentId"]
              , am = "documentKeyIndex"
              , ay = ["prefixPath", "collectionGroup", "documentId"]
              , av = "collectionGroupIndex"
              , aw = ["collectionGroup", "readTime", "prefixPath", "documentId"]
              , ab = "remoteDocumentGlobal"
              , aE = "remoteDocumentGlobalKey"
              , aI = "targets"
              , a_ = "queryTargetsIndex"
              , aT = ["canonicalId", "targetId"]
              , aS = "targetDocuments"
              , aC = ["targetId", "path"]
              , ax = "documentTargetsIndex"
              , aA = ["path", "targetId"]
              , aD = "targetGlobalKey"
              , ak = "targetGlobal"
              , aN = "collectionParents"
              , aO = ["collectionId", "parent"]
              , aR = "clientMetadata"
              , aM = "bundles"
              , aP = "namedQueries"
              , aL = "indexConfiguration"
              , aF = "collectionGroupIndex"
              , aB = "indexState"
              , aV = ["indexId", "uid"]
              , aU = "sequenceNumberIndex"
              , aq = ["uid", "sequenceNumber"]
              , aj = "indexEntries"
              , az = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"]
              , aQ = "documentKeyIndex"
              , aK = ["indexId", "uid", "orderedDocumentKey"]
              , a$ = "documentOverlays"
              , aG = ["userId", "collectionPath", "documentId"]
              , aH = "collectionPathOverlayIndex"
              , aW = ["userId", "collectionPath", "largestBatchId"]
              , aJ = "collectionGroupOverlayIndex"
              , aY = ["userId", "collectionGroup", "largestBatchId"]
              , aX = "globals"
              , aZ = [ao, al, af, ai, aI, as, ak, aS, aR, ab, aN, aM, aP]
              , a0 = [...aZ, a$]
              , a1 = [ao, al, af, ap, aI, as, ak, aS, aR, ab, aN, aM, aP, a$]
              , a2 = [...a1, aL, aB, aj]
              , a6 = [...a2, aX];
            class a3 extends s1 {
                constructor(e, t) {
                    super(),
                    this.he = e,
                    this.currentSequenceNumber = t
                }
            }
            function $(e, t) {
                return s5.N(e.he, t)
            }
            function G(e) {
                let t = 0;
                for (let r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && t++;
                return t
            }
            function H(e, t) {
                for (let r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && t(r, e[r])
            }
            function W(e, t) {
                let r = [];
                for (let n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && r.push(t(e[n], n, e));
                return r
            }
            function J(e) {
                for (let t in e)
                    if (Object.prototype.hasOwnProperty.call(e, t))
                        return !1;
                return !0
            }
            class a5 {
                constructor(e, t) {
                    this.comparator = e,
                    this.root = t || a8.EMPTY
                }
                insert(e, t) {
                    return new a5(this.comparator,this.root.insert(e, t, this.comparator).copy(null, null, a8.BLACK, null, null))
                }
                remove(e) {
                    return new a5(this.comparator,this.root.remove(e, this.comparator).copy(null, null, a8.BLACK, null, null))
                }
                get(e) {
                    let t = this.root;
                    for (; !t.isEmpty(); ) {
                        let r = this.comparator(e, t.key);
                        if (0 === r)
                            return t.value;
                        r < 0 ? t = t.left : r > 0 && (t = t.right)
                    }
                    return null
                }
                indexOf(e) {
                    let t = 0
                      , r = this.root;
                    for (; !r.isEmpty(); ) {
                        let n = this.comparator(e, r.key);
                        if (0 === n)
                            return t + r.left.size;
                        n < 0 ? r = r.left : (t += r.left.size + 1,
                        r = r.right)
                    }
                    return -1
                }
                isEmpty() {
                    return this.root.isEmpty()
                }
                get size() {
                    return this.root.size
                }
                minKey() {
                    return this.root.minKey()
                }
                maxKey() {
                    return this.root.maxKey()
                }
                inorderTraversal(e) {
                    return this.root.inorderTraversal(e)
                }
                forEach(e) {
                    this.inorderTraversal( (t, r) => (e(t, r),
                    !1))
                }
                toString() {
                    let e = [];
                    return this.inorderTraversal( (t, r) => (e.push(`${t}:${r}`),
                    !1)),
                    `{${e.join(", ")}}`
                }
                reverseTraversal(e) {
                    return this.root.reverseTraversal(e)
                }
                getIterator() {
                    return new a4(this.root,null,this.comparator,!1)
                }
                getIteratorFrom(e) {
                    return new a4(this.root,e,this.comparator,!1)
                }
                getReverseIterator() {
                    return new a4(this.root,null,this.comparator,!0)
                }
                getReverseIteratorFrom(e) {
                    return new a4(this.root,e,this.comparator,!0)
                }
            }
            class a4 {
                constructor(e, t, r, n) {
                    this.isReverse = n,
                    this.nodeStack = [];
                    let i = 1;
                    for (; !e.isEmpty(); )
                        if (i = t ? r(e.key, t) : 1,
                        t && n && (i *= -1),
                        i < 0)
                            e = this.isReverse ? e.left : e.right;
                        else {
                            if (0 === i) {
                                this.nodeStack.push(e);
                                break
                            }
                            this.nodeStack.push(e),
                            e = this.isReverse ? e.right : e.left
                        }
                }
                getNext() {
                    let e = this.nodeStack.pop()
                      , t = {
                        key: e.key,
                        value: e.value
                    };
                    if (this.isReverse)
                        for (e = e.left; !e.isEmpty(); )
                            this.nodeStack.push(e),
                            e = e.right;
                    else
                        for (e = e.right; !e.isEmpty(); )
                            this.nodeStack.push(e),
                            e = e.left;
                    return t
                }
                hasNext() {
                    return this.nodeStack.length > 0
                }
                peek() {
                    if (0 === this.nodeStack.length)
                        return null;
                    let e = this.nodeStack[this.nodeStack.length - 1];
                    return {
                        key: e.key,
                        value: e.value
                    }
                }
            }
            class a8 {
                constructor(e, t, r, n, i) {
                    this.key = e,
                    this.value = t,
                    this.color = null != r ? r : a8.RED,
                    this.left = null != n ? n : a8.EMPTY,
                    this.right = null != i ? i : a8.EMPTY,
                    this.size = this.left.size + 1 + this.right.size
                }
                copy(e, t, r, n, i) {
                    return new a8(null != e ? e : this.key,null != t ? t : this.value,null != r ? r : this.color,null != n ? n : this.left,null != i ? i : this.right)
                }
                isEmpty() {
                    return !1
                }
                inorderTraversal(e) {
                    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e)
                }
                reverseTraversal(e) {
                    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
                }
                min() {
                    return this.left.isEmpty() ? this : this.left.min()
                }
                minKey() {
                    return this.min().key
                }
                maxKey() {
                    return this.right.isEmpty() ? this.key : this.right.maxKey()
                }
                insert(e, t, r) {
                    let n = this
                      , i = r(e, n.key);
                    return (n = i < 0 ? n.copy(null, null, null, n.left.insert(e, t, r), null) : 0 === i ? n.copy(null, t, null, null, null) : n.copy(null, null, null, null, n.right.insert(e, t, r))).fixUp()
                }
                removeMin() {
                    if (this.left.isEmpty())
                        return a8.EMPTY;
                    let e = this;
                    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()),
                    (e = e.copy(null, null, null, e.left.removeMin(), null)).fixUp()
                }
                remove(e, t) {
                    let r, n = this;
                    if (0 > t(e, n.key))
                        n.left.isEmpty() || n.left.isRed() || n.left.left.isRed() || (n = n.moveRedLeft()),
                        n = n.copy(null, null, null, n.left.remove(e, t), null);
                    else {
                        if (n.left.isRed() && (n = n.rotateRight()),
                        n.right.isEmpty() || n.right.isRed() || n.right.left.isRed() || (n = n.moveRedRight()),
                        0 === t(e, n.key)) {
                            if (n.right.isEmpty())
                                return a8.EMPTY;
                            r = n.right.min(),
                            n = n.copy(r.key, r.value, null, null, n.right.removeMin())
                        }
                        n = n.copy(null, null, null, null, n.right.remove(e, t))
                    }
                    return n.fixUp()
                }
                isRed() {
                    return this.color
                }
                fixUp() {
                    let e = this;
                    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
                    e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
                    e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
                    e
                }
                moveRedLeft() {
                    let e = this.colorFlip();
                    return e.right.left.isRed() && (e = (e = (e = e.copy(null, null, null, null, e.right.rotateRight())).rotateLeft()).colorFlip()),
                    e
                }
                moveRedRight() {
                    let e = this.colorFlip();
                    return e.left.left.isRed() && (e = (e = e.rotateRight()).colorFlip()),
                    e
                }
                rotateLeft() {
                    let e = this.copy(null, null, a8.RED, null, this.right.left);
                    return this.right.copy(null, null, this.color, e, null)
                }
                rotateRight() {
                    let e = this.copy(null, null, a8.RED, this.left.right, null);
                    return this.left.copy(null, null, this.color, null, e)
                }
                colorFlip() {
                    let e = this.left.copy(null, null, !this.left.color, null, null)
                      , t = this.right.copy(null, null, !this.right.color, null, null);
                    return this.copy(null, null, !this.color, e, t)
                }
                checkMaxDepth() {
                    return Math.pow(2, this.check()) <= this.size + 1
                }
                check() {
                    if (this.isRed() && this.left.isRed())
                        throw E(43730, {
                            key: this.key,
                            value: this.value
                        });
                    if (this.right.isRed())
                        throw E(14113, {
                            key: this.key,
                            value: this.value
                        });
                    let e = this.left.check();
                    if (e !== this.right.check())
                        throw E(27949);
                    return e + +!this.isRed()
                }
            }
            a8.EMPTY = null,
            a8.RED = !0,
            a8.BLACK = !1,
            a8.EMPTY = new class {
                constructor() {
                    this.size = 0
                }
                get key() {
                    throw E(57766)
                }
                get value() {
                    throw E(16141)
                }
                get color() {
                    throw E(16727)
                }
                get left() {
                    throw E(29726)
                }
                get right() {
                    throw E(36894)
                }
                copy(e, t, r, n, i) {
                    return this
                }
                insert(e, t, r) {
                    return new a8(e,t)
                }
                remove(e, t) {
                    return this
                }
                isEmpty() {
                    return !0
                }
                inorderTraversal(e) {
                    return !1
                }
                reverseTraversal(e) {
                    return !1
                }
                minKey() {
                    return null
                }
                maxKey() {
                    return null
                }
                isRed() {
                    return !1
                }
                checkMaxDepth() {
                    return !0
                }
                check() {
                    return 0
                }
            }
            ;
            class a7 {
                constructor(e) {
                    this.comparator = e,
                    this.data = new a5(this.comparator)
                }
                has(e) {
                    return null !== this.data.get(e)
                }
                first() {
                    return this.data.minKey()
                }
                last() {
                    return this.data.maxKey()
                }
                get size() {
                    return this.data.size
                }
                indexOf(e) {
                    return this.data.indexOf(e)
                }
                forEach(e) {
                    this.data.inorderTraversal( (t, r) => (e(t),
                    !1))
                }
                forEachInRange(e, t) {
                    let r = this.data.getIteratorFrom(e[0]);
                    for (; r.hasNext(); ) {
                        let n = r.getNext();
                        if (this.comparator(n.key, e[1]) >= 0)
                            return;
                        t(n.key)
                    }
                }
                forEachWhile(e, t) {
                    let r;
                    for (r = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); r.hasNext(); )
                        if (!e(r.getNext().key))
                            return
                }
                firstAfterOrEqual(e) {
                    let t = this.data.getIteratorFrom(e);
                    return t.hasNext() ? t.getNext().key : null
                }
                getIterator() {
                    return new a9(this.data.getIterator())
                }
                getIteratorFrom(e) {
                    return new a9(this.data.getIteratorFrom(e))
                }
                add(e) {
                    return this.copy(this.data.remove(e).insert(e, !0))
                }
                delete(e) {
                    return this.has(e) ? this.copy(this.data.remove(e)) : this
                }
                isEmpty() {
                    return this.data.isEmpty()
                }
                unionWith(e) {
                    let t = this;
                    return t.size < e.size && (t = e,
                    e = this),
                    e.forEach(e => {
                        t = t.add(e)
                    }
                    ),
                    t
                }
                isEqual(e) {
                    if (!(e instanceof a7) || this.size !== e.size)
                        return !1;
                    let t = this.data.getIterator()
                      , r = e.data.getIterator();
                    for (; t.hasNext(); ) {
                        let e = t.getNext().key
                          , n = r.getNext().key;
                        if (0 !== this.comparator(e, n))
                            return !1
                    }
                    return !0
                }
                toArray() {
                    let e = [];
                    return this.forEach(t => {
                        e.push(t)
                    }
                    ),
                    e
                }
                toString() {
                    let e = [];
                    return this.forEach(t => e.push(t)),
                    "SortedSet(" + e.toString() + ")"
                }
                copy(e) {
                    let t = new a7(this.comparator);
                    return t.data = e,
                    t
                }
            }
            class a9 {
                constructor(e) {
                    this.iter = e
                }
                getNext() {
                    return this.iter.getNext().key
                }
                hasNext() {
                    return this.iter.hasNext()
                }
            }
            function Y(e) {
                return e.hasNext() ? e.getNext() : void 0
            }
            class oe {
                constructor(e) {
                    this.fields = e,
                    e.sort(sH.comparator)
                }
                static empty() {
                    return new oe([])
                }
                unionWith(e) {
                    let t = new a7(sH.comparator);
                    for (let e of this.fields)
                        t = t.add(e);
                    for (let r of e)
                        t = t.add(r);
                    return new oe(t.toArray())
                }
                covers(e) {
                    for (let t of this.fields)
                        if (t.isPrefixOf(e))
                            return !0;
                    return !1
                }
                isEqual(e) {
                    return D(this.fields, e.fields, (e, t) => e.isEqual(t))
                }
            }
            class ot extends Error {
                constructor() {
                    super(...arguments),
                    this.name = "Base64DecodeError"
                }
            }
            function X() {
                return "undefined" != typeof atob
            }
            class or {
                constructor(e) {
                    this.binaryString = e
                }
                static fromBase64String(e) {
                    return new or(function(e) {
                        try {
                            return atob(e)
                        } catch (e) {
                            throw "undefined" != typeof DOMException && e instanceof DOMException ? new ot("Invalid base64 string: " + e) : e
                        }
                    }(e))
                }
                static fromUint8Array(e) {
                    return new or(function(e) {
                        let t = "";
                        for (let r = 0; r < e.length; ++r)
                            t += String.fromCharCode(e[r]);
                        return t
                    }(e))
                }
                [Symbol.iterator]() {
                    let e = 0;
                    return {
                        next: () => e < this.binaryString.length ? {
                            value: this.binaryString.charCodeAt(e++),
                            done: !1
                        } : {
                            value: void 0,
                            done: !0
                        }
                    }
                }
                toBase64() {
                    return btoa(this.binaryString)
                }
                toUint8Array() {
                    var e = this.binaryString;
                    let t = new Uint8Array(e.length);
                    for (let r = 0; r < e.length; r++)
                        t[r] = e.charCodeAt(r);
                    return t
                }
                approximateByteSize() {
                    return 2 * this.binaryString.length
                }
                compareTo(e) {
                    return C(this.binaryString, e.binaryString)
                }
                isEqual(e) {
                    return this.binaryString === e.binaryString
                }
            }
            or.EMPTY_BYTE_STRING = new or("");
            let on = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
            function Z(e) {
                if (_(!!e, 39018),
                "string" == typeof e) {
                    let t = 0
                      , r = on.exec(e);
                    if (_(!!r, 46558, {
                        timestamp: e
                    }),
                    r[1]) {
                        let e = r[1];
                        t = Number(e = (e + "000000000").substr(0, 9))
                    }
                    return {
                        seconds: Math.floor(new Date(e).getTime() / 1e3),
                        nanos: t
                    }
                }
                return {
                    seconds: ee(e.seconds),
                    nanos: ee(e.nanos)
                }
            }
            function ee(e) {
                return "number" == typeof e ? e : "string" == typeof e ? Number(e) : 0
            }
            function et(e) {
                return "string" == typeof e ? or.fromBase64String(e) : or.fromUint8Array(e)
            }
            let oi = "server_timestamp"
              , os = "__type__"
              , oa = "__previous_value__"
              , oo = "__local_write_time__";
            function er(e) {
                var t, r;
                return (null == (r = ((null == (t = null == e ? void 0 : e.mapValue) ? void 0 : t.fields) || {})[os]) ? void 0 : r.stringValue) === oi
            }
            function en(e) {
                let t = e.mapValue.fields[oa];
                return er(t) ? en(t) : t
            }
            function ei(e) {
                let t = Z(e.mapValue.fields[oo].timestampValue);
                return new sj(t.seconds,t.nanos)
            }
            class ol {
                constructor(e, t, r, n, i, s, a, o, l, u) {
                    this.databaseId = e,
                    this.appId = t,
                    this.persistenceKey = r,
                    this.host = n,
                    this.ssl = i,
                    this.forceLongPolling = s,
                    this.autoDetectLongPolling = a,
                    this.longPollingOptions = o,
                    this.useFetchStreams = l,
                    this.isUsingEmulator = u
                }
            }
            let ou = "(default)";
            class oh {
                constructor(e, t) {
                    this.projectId = e,
                    this.database = t || ou
                }
                static empty() {
                    return new oh("","")
                }
                get isDefaultDatabase() {
                    return this.database === ou
                }
                isEqual(e) {
                    return e instanceof oh && e.projectId === this.projectId && e.database === this.database
                }
            }
            let oc = "__type__"
              , od = "__max__"
              , of = {
                mapValue: {
                    fields: {
                        __type__: {
                            stringValue: od
                        }
                    }
                }
            }
              , op = "__vector__"
              , og = "value"
              , om = {
                nullValue: "NULL_VALUE"
            };
            function es(e) {
                return "nullValue"in e ? 0 : "booleanValue"in e ? 1 : "integerValue"in e || "doubleValue"in e ? 2 : "timestampValue"in e ? 3 : "stringValue"in e ? 5 : "bytesValue"in e ? 6 : "referenceValue"in e ? 7 : "geoPointValue"in e ? 8 : "arrayValue"in e ? 9 : "mapValue"in e ? er(e) ? 4 : eb(e) ? 0x1fffffffffffff : ev(e) ? 10 : 11 : E(28295, {
                    value: e
                })
            }
            function ea(e, t) {
                if (e === t)
                    return !0;
                let r = es(e);
                if (r !== es(t))
                    return !1;
                switch (r) {
                case 0:
                case 0x1fffffffffffff:
                    return !0;
                case 1:
                    return e.booleanValue === t.booleanValue;
                case 4:
                    return ei(e).isEqual(ei(t));
                case 3:
                    if ("string" == typeof e.timestampValue && "string" == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length)
                        return e.timestampValue === t.timestampValue;
                    let n = Z(e.timestampValue)
                      , i = Z(t.timestampValue);
                    return n.seconds === i.seconds && n.nanos === i.nanos;
                case 5:
                    return e.stringValue === t.stringValue;
                case 6:
                    return et(e.bytesValue).isEqual(et(t.bytesValue));
                case 7:
                    return e.referenceValue === t.referenceValue;
                case 8:
                    return ee(e.geoPointValue.latitude) === ee(t.geoPointValue.latitude) && ee(e.geoPointValue.longitude) === ee(t.geoPointValue.longitude);
                case 2:
                    if ("integerValue"in e && "integerValue"in t)
                        return ee(e.integerValue) === ee(t.integerValue);
                    if ("doubleValue"in e && "doubleValue"in t) {
                        let r = ee(e.doubleValue)
                          , n = ee(t.doubleValue);
                        return r === n ? j(r) === j(n) : isNaN(r) && isNaN(n)
                    }
                    return !1;
                case 9:
                    return D(e.arrayValue.values || [], t.arrayValue.values || [], ea);
                case 10:
                case 11:
                    let s = e.mapValue.fields || {}
                      , a = t.mapValue.fields || {};
                    if (G(s) !== G(a))
                        return !1;
                    for (let e in s)
                        if (s.hasOwnProperty(e) && (void 0 === a[e] || !ea(s[e], a[e])))
                            return !1;
                    return !0;
                default:
                    return E(52216, {
                        left: e
                    })
                }
            }
            function eo(e, t) {
                return void 0 !== (e.values || []).find(e => ea(e, t))
            }
            function el(e, t) {
                if (e === t)
                    return 0;
                let r = es(e)
                  , n = es(t);
                if (r !== n)
                    return C(r, n);
                switch (r) {
                case 0:
                case 0x1fffffffffffff:
                    return 0;
                case 1:
                    return C(e.booleanValue, t.booleanValue);
                case 2:
                    let i = ee(e.integerValue || e.doubleValue)
                      , s = ee(t.integerValue || t.doubleValue);
                    return i < s ? -1 : i > s ? 1 : i === s ? 0 : isNaN(i) ? isNaN(s) ? 0 : -1 : 1;
                case 3:
                    return eu(e.timestampValue, t.timestampValue);
                case 4:
                    return eu(ei(e), ei(t));
                case 5:
                    return x(e.stringValue, t.stringValue);
                case 6:
                    return function(e, t) {
                        let r = et(e)
                          , n = et(t);
                        return r.compareTo(n)
                    }(e.bytesValue, t.bytesValue);
                case 7:
                    return function(e, t) {
                        let r = e.split("/")
                          , n = t.split("/");
                        for (let e = 0; e < r.length && e < n.length; e++) {
                            let t = C(r[e], n[e]);
                            if (0 !== t)
                                return t
                        }
                        return C(r.length, n.length)
                    }(e.referenceValue, t.referenceValue);
                case 8:
                    return function(e, t) {
                        let r = C(ee(e.latitude), ee(t.latitude));
                        return 0 !== r ? r : C(ee(e.longitude), ee(t.longitude))
                    }(e.geoPointValue, t.geoPointValue);
                case 9:
                    return eh(e.arrayValue, t.arrayValue);
                case 10:
                    return function(e, t) {
                        var r, n, i, s;
                        let a = e.fields || {}
                          , o = t.fields || {}
                          , l = null == (r = a[og]) ? void 0 : r.arrayValue
                          , u = null == (n = o[og]) ? void 0 : n.arrayValue
                          , h = C((null == (i = null == l ? void 0 : l.values) ? void 0 : i.length) || 0, (null == (s = null == u ? void 0 : u.values) ? void 0 : s.length) || 0);
                        return 0 !== h ? h : eh(l, u)
                    }(e.mapValue, t.mapValue);
                case 11:
                    return function(e, t) {
                        if (e === of.mapValue && t === of.mapValue)
                            return 0;
                        if (e === of.mapValue)
                            return 1;
                        if (t === of.mapValue)
                            return -1;
                        let r = e.fields || {}
                          , n = Object.keys(r)
                          , i = t.fields || {}
                          , s = Object.keys(i);
                        n.sort(),
                        s.sort();
                        for (let e = 0; e < n.length && e < s.length; ++e) {
                            let t = x(n[e], s[e]);
                            if (0 !== t)
                                return t;
                            let a = el(r[n[e]], i[s[e]]);
                            if (0 !== a)
                                return a
                        }
                        return C(n.length, s.length)
                    }(e.mapValue, t.mapValue);
                default:
                    throw E(23264, {
                        Pe: r
                    })
                }
            }
            function eu(e, t) {
                if ("string" == typeof e && "string" == typeof t && e.length === t.length)
                    return C(e, t);
                let r = Z(e)
                  , n = Z(t)
                  , i = C(r.seconds, n.seconds);
                return 0 !== i ? i : C(r.nanos, n.nanos)
            }
            function eh(e, t) {
                let r = e.values || []
                  , n = t.values || [];
                for (let e = 0; e < r.length && e < n.length; ++e) {
                    let t = el(r[e], n[e]);
                    if (t)
                        return t
                }
                return C(r.length, n.length)
            }
            function ec(e) {
                var t, r;
                return "nullValue"in e ? "null" : "booleanValue"in e ? "" + e.booleanValue : "integerValue"in e ? "" + e.integerValue : "doubleValue"in e ? "" + e.doubleValue : "timestampValue"in e ? function(e) {
                    let t = Z(e);
                    return `time(${t.seconds},${t.nanos})`
                }(e.timestampValue) : "stringValue"in e ? e.stringValue : "bytesValue"in e ? et(e.bytesValue).toBase64() : "referenceValue"in e ? (t = e.referenceValue,
                sW.fromName(t).toString()) : "geoPointValue"in e ? (r = e.geoPointValue,
                `geo(${r.latitude},${r.longitude})`) : "arrayValue"in e ? function(e) {
                    let t = "["
                      , r = !0;
                    for (let n of e.values || [])
                        r ? r = !1 : t += ",",
                        t += ec(n);
                    return t + "]"
                }(e.arrayValue) : "mapValue"in e ? function(e) {
                    let t = Object.keys(e.fields || {}).sort()
                      , r = "{"
                      , n = !0;
                    for (let i of t)
                        n ? n = !1 : r += ",",
                        r += `${i}:${ec(e.fields[i])}`;
                    return r + "}"
                }(e.mapValue) : E(61005, {
                    value: e
                })
            }
            function ed(e, t) {
                return {
                    referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}`
                }
            }
            function ef(e) {
                return !!e && "integerValue"in e
            }
            function ep(e) {
                return !!e && "arrayValue"in e
            }
            function eg(e) {
                return !!e && "nullValue"in e
            }
            function em(e) {
                return !!e && "doubleValue"in e && isNaN(Number(e.doubleValue))
            }
            function ey(e) {
                return !!e && "mapValue"in e
            }
            function ev(e) {
                var t, r;
                return (null == (r = ((null == (t = null == e ? void 0 : e.mapValue) ? void 0 : t.fields) || {})[oc]) ? void 0 : r.stringValue) === op
            }
            function ew(e) {
                if (e.geoPointValue)
                    return {
                        geoPointValue: Object.assign({}, e.geoPointValue)
                    };
                if (e.timestampValue && "object" == typeof e.timestampValue)
                    return {
                        timestampValue: Object.assign({}, e.timestampValue)
                    };
                if (e.mapValue) {
                    let t = {
                        mapValue: {
                            fields: {}
                        }
                    };
                    return H(e.mapValue.fields, (e, r) => t.mapValue.fields[e] = ew(r)),
                    t
                }
                if (e.arrayValue) {
                    let t = {
                        arrayValue: {
                            values: []
                        }
                    };
                    for (let r = 0; r < (e.arrayValue.values || []).length; ++r)
                        t.arrayValue.values[r] = ew(e.arrayValue.values[r]);
                    return t
                }
                return Object.assign({}, e)
            }
            function eb(e) {
                return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === od
            }
            let oy = {
                mapValue: {
                    fields: {
                        [oc]: {
                            stringValue: op
                        },
                        [og]: {
                            arrayValue: {}
                        }
                    }
                }
            };
            function eE(e, t) {
                let r = el(e.value, t.value);
                return 0 !== r ? r : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0
            }
            function eI(e, t) {
                let r = el(e.value, t.value);
                return 0 !== r ? r : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0
            }
            class ov {
                constructor(e) {
                    this.value = e
                }
                static empty() {
                    return new ov({
                        mapValue: {}
                    })
                }
                field(e) {
                    if (e.isEmpty())
                        return this.value;
                    {
                        let t = this.value;
                        for (let r = 0; r < e.length - 1; ++r)
                            if (!ey(t = (t.mapValue.fields || {})[e.get(r)]))
                                return null;
                        return (t = (t.mapValue.fields || {})[e.lastSegment()]) || null
                    }
                }
                set(e, t) {
                    this.getFieldsMap(e.popLast())[e.lastSegment()] = ew(t)
                }
                setAll(e) {
                    let t = sH.emptyPath()
                      , r = {}
                      , n = [];
                    e.forEach( (e, i) => {
                        if (!t.isImmediateParentOf(i)) {
                            let e = this.getFieldsMap(t);
                            this.applyChanges(e, r, n),
                            r = {},
                            n = [],
                            t = i.popLast()
                        }
                        e ? r[i.lastSegment()] = ew(e) : n.push(i.lastSegment())
                    }
                    );
                    let i = this.getFieldsMap(t);
                    this.applyChanges(i, r, n)
                }
                delete(e) {
                    let t = this.field(e.popLast());
                    ey(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()]
                }
                isEqual(e) {
                    return ea(this.value, e.value)
                }
                getFieldsMap(e) {
                    let t = this.value;
                    t.mapValue.fields || (t.mapValue = {
                        fields: {}
                    });
                    for (let r = 0; r < e.length; ++r) {
                        let n = t.mapValue.fields[e.get(r)];
                        ey(n) && n.mapValue.fields || (n = {
                            mapValue: {
                                fields: {}
                            }
                        },
                        t.mapValue.fields[e.get(r)] = n),
                        t = n
                    }
                    return t.mapValue.fields
                }
                applyChanges(e, t, r) {
                    for (let n of (H(t, (t, r) => e[t] = r),
                    r))
                        delete e[n]
                }
                clone() {
                    return new ov(ew(this.value))
                }
            }
            class ow {
                constructor(e, t, r, n, i, s, a) {
                    this.key = e,
                    this.documentType = t,
                    this.version = r,
                    this.readTime = n,
                    this.createTime = i,
                    this.data = s,
                    this.documentState = a
                }
                static newInvalidDocument(e) {
                    return new ow(e,0,sz.min(),sz.min(),sz.min(),ov.empty(),0)
                }
                static newFoundDocument(e, t, r, n) {
                    return new ow(e,1,t,sz.min(),r,n,0)
                }
                static newNoDocument(e, t) {
                    return new ow(e,2,t,sz.min(),sz.min(),ov.empty(),0)
                }
                static newUnknownDocument(e, t) {
                    return new ow(e,3,t,sz.min(),sz.min(),ov.empty(),2)
                }
                convertToFoundDocument(e, t) {
                    return this.createTime.isEqual(sz.min()) && (2 === this.documentType || 0 === this.documentType) && (this.createTime = e),
                    this.version = e,
                    this.documentType = 1,
                    this.data = t,
                    this.documentState = 0,
                    this
                }
                convertToNoDocument(e) {
                    return this.version = e,
                    this.documentType = 2,
                    this.data = ov.empty(),
                    this.documentState = 0,
                    this
                }
                convertToUnknownDocument(e) {
                    return this.version = e,
                    this.documentType = 3,
                    this.data = ov.empty(),
                    this.documentState = 2,
                    this
                }
                setHasCommittedMutations() {
                    return this.documentState = 2,
                    this
                }
                setHasLocalMutations() {
                    return this.documentState = 1,
                    this.version = sz.min(),
                    this
                }
                setReadTime(e) {
                    return this.readTime = e,
                    this
                }
                get hasLocalMutations() {
                    return 1 === this.documentState
                }
                get hasCommittedMutations() {
                    return 2 === this.documentState
                }
                get hasPendingWrites() {
                    return this.hasLocalMutations || this.hasCommittedMutations
                }
                isValidDocument() {
                    return 0 !== this.documentType
                }
                isFoundDocument() {
                    return 1 === this.documentType
                }
                isNoDocument() {
                    return 2 === this.documentType
                }
                isUnknownDocument() {
                    return 3 === this.documentType
                }
                isEqual(e) {
                    return e instanceof ow && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data)
                }
                mutableCopy() {
                    return new ow(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)
                }
                toString() {
                    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
                }
            }
            class ob {
                constructor(e, t) {
                    this.position = e,
                    this.inclusive = t
                }
            }
            function e_(e, t, r) {
                let n = 0;
                for (let i = 0; i < e.position.length; i++) {
                    let s = t[i]
                      , a = e.position[i];
                    if (n = s.field.isKeyField() ? sW.comparator(sW.fromName(a.referenceValue), r.key) : el(a, r.data.field(s.field)),
                    "desc" === s.dir && (n *= -1),
                    0 !== n)
                        break
                }
                return n
            }
            function eT(e, t) {
                if (null === e)
                    return null === t;
                if (null === t || e.inclusive !== t.inclusive || e.position.length !== t.position.length)
                    return !1;
                for (let r = 0; r < e.position.length; r++)
                    if (!ea(e.position[r], t.position[r]))
                        return !1;
                return !0
            }
            class oE {
                constructor(e, t="asc") {
                    this.field = e,
                    this.dir = t
                }
            }
            class oI {
            }
            class o_ extends oI {
                constructor(e, t, r) {
                    super(),
                    this.field = e,
                    this.op = t,
                    this.value = r
                }
                static create(e, t, r) {
                    return e.isKeyField() ? "in" === t || "not-in" === t ? this.createKeyFieldInFilter(e, t, r) : new oS(e,t,r) : "array-contains" === t ? new oA(e,r) : "in" === t ? new oD(e,r) : "not-in" === t ? new ok(e,r) : "array-contains-any" === t ? new oN(e,r) : new o_(e,t,r)
                }
                static createKeyFieldInFilter(e, t, r) {
                    return "in" === t ? new oC(e,r) : new ox(e,r)
                }
                matches(e) {
                    let t = e.data.field(this.field);
                    return "!=" === this.op ? null !== t && void 0 === t.nullValue && this.matchesComparison(el(t, this.value)) : null !== t && es(this.value) === es(t) && this.matchesComparison(el(t, this.value))
                }
                matchesComparison(e) {
                    switch (this.op) {
                    case "<":
                        return e < 0;
                    case "<=":
                        return e <= 0;
                    case "==":
                        return 0 === e;
                    case "!=":
                        return 0 !== e;
                    case ">":
                        return e > 0;
                    case ">=":
                        return e >= 0;
                    default:
                        return E(47266, {
                            operator: this.op
                        })
                    }
                }
                isInequality() {
                    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0
                }
                getFlattenedFilters() {
                    return [this]
                }
                getFilters() {
                    return [this]
                }
            }
            class oT extends oI {
                constructor(e, t) {
                    super(),
                    this.filters = e,
                    this.op = t,
                    this.Te = null
                }
                static create(e, t) {
                    return new oT(e,t)
                }
                matches(e) {
                    return eS(this) ? void 0 === this.filters.find(t => !t.matches(e)) : void 0 !== this.filters.find(t => t.matches(e))
                }
                getFlattenedFilters() {
                    return null !== this.Te || (this.Te = this.filters.reduce( (e, t) => e.concat(t.getFlattenedFilters()), [])),
                    this.Te
                }
                getFilters() {
                    return Object.assign([], this.filters)
                }
            }
            function eS(e) {
                return "and" === e.op
            }
            function eC(e) {
                return "or" === e.op
            }
            function ex(e) {
                return eA(e) && eS(e)
            }
            function eA(e) {
                for (let t of e.filters)
                    if (t instanceof oT)
                        return !1;
                return !0
            }
            function eD(e, t) {
                let r = e.filters.concat(t);
                return oT.create(r, e.op)
            }
            class oS extends o_ {
                constructor(e, t, r) {
                    super(e, t, r),
                    this.key = sW.fromName(r.referenceValue)
                }
                matches(e) {
                    let t = sW.comparator(e.key, this.key);
                    return this.matchesComparison(t)
                }
            }
            class oC extends o_ {
                constructor(e, t) {
                    super(e, "in", t),
                    this.keys = ek("in", t)
                }
                matches(e) {
                    return this.keys.some(t => t.isEqual(e.key))
                }
            }
            class ox extends o_ {
                constructor(e, t) {
                    super(e, "not-in", t),
                    this.keys = ek("not-in", t)
                }
                matches(e) {
                    return !this.keys.some(t => t.isEqual(e.key))
                }
            }
            function ek(e, t) {
                var r;
                return ((null == (r = t.arrayValue) ? void 0 : r.values) || []).map(e => sW.fromName(e.referenceValue))
            }
            class oA extends o_ {
                constructor(e, t) {
                    super(e, "array-contains", t)
                }
                matches(e) {
                    let t = e.data.field(this.field);
                    return ep(t) && eo(t.arrayValue, this.value)
                }
            }
            class oD extends o_ {
                constructor(e, t) {
                    super(e, "in", t)
                }
                matches(e) {
                    let t = e.data.field(this.field);
                    return null !== t && eo(this.value.arrayValue, t)
                }
            }
            class ok extends o_ {
                constructor(e, t) {
                    super(e, "not-in", t)
                }
                matches(e) {
                    if (eo(this.value.arrayValue, {
                        nullValue: "NULL_VALUE"
                    }))
                        return !1;
                    let t = e.data.field(this.field);
                    return null !== t && void 0 === t.nullValue && !eo(this.value.arrayValue, t)
                }
            }
            class oN extends o_ {
                constructor(e, t) {
                    super(e, "array-contains-any", t)
                }
                matches(e) {
                    let t = e.data.field(this.field);
                    return !(!ep(t) || !t.arrayValue.values) && t.arrayValue.values.some(e => eo(this.value.arrayValue, e))
                }
            }
            class oO {
                constructor(e, t=null, r=[], n=[], i=null, s=null, a=null) {
                    this.path = e,
                    this.collectionGroup = t,
                    this.orderBy = r,
                    this.filters = n,
                    this.limit = i,
                    this.startAt = s,
                    this.endAt = a,
                    this.Ie = null
                }
            }
            function eN(e, t=null, r=[], n=[], i=null, s=null, a=null) {
                return new oO(e,t,r,n,i,s,a)
            }
            function eO(e) {
                if (null === e.Ie) {
                    let t = e.path.canonicalString();
                    null !== e.collectionGroup && (t += "|cg:" + e.collectionGroup),
                    t += "|f:",
                    t += e.filters.map(e => (function e(t) {
                        if (t instanceof o_)
                            return t.field.canonicalString() + t.op.toString() + ec(t.value);
                        if (ex(t))
                            return t.filters.map(t => e(t)).join(",");
                        {
                            let r = t.filters.map(t => e(t)).join(",");
                            return `${t.op}(${r})`
                        }
                    }
                    )(e)).join(","),
                    t += "|ob:",
                    t += e.orderBy.map(e => e.field.canonicalString() + e.dir).join(","),
                    q(e.limit) || (t += "|l:",
                    t += e.limit),
                    e.startAt && (t += "|lb:",
                    t += e.startAt.inclusive ? "b:" : "a:",
                    t += e.startAt.position.map(e => ec(e)).join(",")),
                    e.endAt && (t += "|ub:",
                    t += e.endAt.inclusive ? "a:" : "b:",
                    t += e.endAt.position.map(e => ec(e)).join(",")),
                    e.Ie = t
                }
                return e.Ie
            }
            function eR(e, t) {
                if (e.limit !== t.limit || e.orderBy.length !== t.orderBy.length)
                    return !1;
                for (let i = 0; i < e.orderBy.length; i++) {
                    var r, n;
                    if (r = e.orderBy[i],
                    n = t.orderBy[i],
                    !(r.dir === n.dir && r.field.isEqual(n.field)))
                        return !1
                }
                if (e.filters.length !== t.filters.length)
                    return !1;
                for (let r = 0; r < e.filters.length; r++)
                    if (!function e(t, r) {
                        return t instanceof o_ ? r instanceof o_ && t.op === r.op && t.field.isEqual(r.field) && ea(t.value, r.value) : t instanceof oT ? r instanceof oT && t.op === r.op && t.filters.length === r.filters.length && t.filters.reduce( (t, n, i) => t && e(n, r.filters[i]), !0) : void E(19439)
                    }(e.filters[r], t.filters[r]))
                        return !1;
                return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!eT(e.startAt, t.startAt) && eT(e.endAt, t.endAt)
            }
            function eM(e) {
                return sW.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length
            }
            function eP(e, t) {
                return e.filters.filter(e => e instanceof o_ && e.field.isEqual(t))
            }
            function eL(e, t, r) {
                let n = om
                  , i = !0;
                for (let r of eP(e, t)) {
                    let e = om
                      , t = !0;
                    switch (r.op) {
                    case "<":
                    case "<=":
                        var s;
                        e = "nullValue"in (s = r.value) ? om : "booleanValue"in s ? {
                            booleanValue: !1
                        } : "integerValue"in s || "doubleValue"in s ? {
                            doubleValue: NaN
                        } : "timestampValue"in s ? {
                            timestampValue: {
                                seconds: Number.MIN_SAFE_INTEGER
                            }
                        } : "stringValue"in s ? {
                            stringValue: ""
                        } : "bytesValue"in s ? {
                            bytesValue: ""
                        } : "referenceValue"in s ? ed(oh.empty(), sW.empty()) : "geoPointValue"in s ? {
                            geoPointValue: {
                                latitude: -90,
                                longitude: -180
                            }
                        } : "arrayValue"in s ? {
                            arrayValue: {}
                        } : "mapValue"in s ? ev(s) ? oy : {
                            mapValue: {}
                        } : E(35942, {
                            value: s
                        });
                        break;
                    case "==":
                    case "in":
                    case ">=":
                        e = r.value;
                        break;
                    case ">":
                        e = r.value,
                        t = !1;
                        break;
                    case "!=":
                    case "not-in":
                        e = om
                    }
                    0 > eE({
                        value: n,
                        inclusive: i
                    }, {
                        value: e,
                        inclusive: t
                    }) && (n = e,
                    i = t)
                }
                if (null !== r) {
                    for (let s = 0; s < e.orderBy.length; ++s)
                        if (e.orderBy[s].field.isEqual(t)) {
                            let e = r.position[s];
                            0 > eE({
                                value: n,
                                inclusive: i
                            }, {
                                value: e,
                                inclusive: r.inclusive
                            }) && (n = e,
                            i = r.inclusive);
                            break
                        }
                }
                return {
                    value: n,
                    inclusive: i
                }
            }
            function eF(e, t, r) {
                let n = of
                  , i = !0;
                for (let r of eP(e, t)) {
                    let e = of
                      , t = !0;
                    switch (r.op) {
                    case ">=":
                    case ">":
                        var s;
                        e = "nullValue"in (s = r.value) ? {
                            booleanValue: !1
                        } : "booleanValue"in s ? {
                            doubleValue: NaN
                        } : "integerValue"in s || "doubleValue"in s ? {
                            timestampValue: {
                                seconds: Number.MIN_SAFE_INTEGER
                            }
                        } : "timestampValue"in s ? {
                            stringValue: ""
                        } : "stringValue"in s ? {
                            bytesValue: ""
                        } : "bytesValue"in s ? ed(oh.empty(), sW.empty()) : "referenceValue"in s ? {
                            geoPointValue: {
                                latitude: -90,
                                longitude: -180
                            }
                        } : "geoPointValue"in s ? {
                            arrayValue: {}
                        } : "arrayValue"in s ? oy : "mapValue"in s ? ev(s) ? {
                            mapValue: {}
                        } : of : E(61959, {
                            value: s
                        }),
                        t = !1;
                        break;
                    case "==":
                    case "in":
                    case "<=":
                        e = r.value;
                        break;
                    case "<":
                        e = r.value,
                        t = !1;
                        break;
                    case "!=":
                    case "not-in":
                        e = of
                    }
                    eI({
                        value: n,
                        inclusive: i
                    }, {
                        value: e,
                        inclusive: t
                    }) > 0 && (n = e,
                    i = t)
                }
                if (null !== r) {
                    for (let s = 0; s < e.orderBy.length; ++s)
                        if (e.orderBy[s].field.isEqual(t)) {
                            let e = r.position[s];
                            eI({
                                value: n,
                                inclusive: i
                            }, {
                                value: e,
                                inclusive: r.inclusive
                            }) > 0 && (n = e,
                            i = r.inclusive);
                            break
                        }
                }
                return {
                    value: n,
                    inclusive: i
                }
            }
            class oR {
                constructor(e, t=null, r=[], n=[], i=null, s="F", a=null, o=null) {
                    this.path = e,
                    this.collectionGroup = t,
                    this.explicitOrderBy = r,
                    this.filters = n,
                    this.limit = i,
                    this.limitType = s,
                    this.startAt = a,
                    this.endAt = o,
                    this.Ee = null,
                    this.de = null,
                    this.Ae = null,
                    this.startAt,
                    this.endAt
                }
            }
            function eB(e) {
                return new oR(e)
            }
            function eV(e) {
                return 0 === e.filters.length && null === e.limit && null == e.startAt && null == e.endAt && (0 === e.explicitOrderBy.length || 1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField())
            }
            function eU(e) {
                return null !== e.collectionGroup
            }
            function eq(e) {
                if (null === e.Ee) {
                    let t;
                    e.Ee = [];
                    let r = new Set;
                    for (let t of e.explicitOrderBy)
                        e.Ee.push(t),
                        r.add(t.field.canonicalString());
                    let n = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
                    (t = new a7(sH.comparator),
                    e.filters.forEach(e => {
                        e.getFlattenedFilters().forEach(e => {
                            e.isInequality() && (t = t.add(e.field))
                        }
                        )
                    }
                    ),
                    t).forEach(t => {
                        r.has(t.canonicalString()) || t.isKeyField() || e.Ee.push(new oE(t,n))
                    }
                    ),
                    r.has(sH.keyField().canonicalString()) || e.Ee.push(new oE(sH.keyField(),n))
                }
                return e.Ee
            }
            function ej(e) {
                return e.de || (e.de = eQ(e, eq(e))),
                e.de
            }
            function ez(e) {
                return e.Ae || (e.Ae = eQ(e, e.explicitOrderBy)),
                e.Ae
            }
            function eQ(e, t) {
                if ("F" === e.limitType)
                    return eN(e.path, e.collectionGroup, t, e.filters, e.limit, e.startAt, e.endAt);
                {
                    t = t.map(e => {
                        let t = "desc" === e.dir ? "asc" : "desc";
                        return new oE(e.field,t)
                    }
                    );
                    let r = e.endAt ? new ob(e.endAt.position,e.endAt.inclusive) : null
                      , n = e.startAt ? new ob(e.startAt.position,e.startAt.inclusive) : null;
                    return eN(e.path, e.collectionGroup, t, e.filters, e.limit, r, n)
                }
            }
            function eK(e, t) {
                let r = e.filters.concat([t]);
                return new oR(e.path,e.collectionGroup,e.explicitOrderBy.slice(),r,e.limit,e.limitType,e.startAt,e.endAt)
            }
            function e$(e, t, r) {
                return new oR(e.path,e.collectionGroup,e.explicitOrderBy.slice(),e.filters.slice(),t,r,e.startAt,e.endAt)
            }
            function eG(e, t) {
                return eR(ej(e), ej(t)) && e.limitType === t.limitType
            }
            function eH(e) {
                return `${eO(ej(e))}|lt:${e.limitType}`
            }
            function eW(e) {
                var t;
                let r;
                return `Query(target=${r = (t = ej(e)).path.canonicalString(),
                null !== t.collectionGroup && (r += " collectionGroup=" + t.collectionGroup),
                t.filters.length > 0 && (r += `, filters: [${t.filters.map(e => (function e(t) {
                    return t instanceof o_ ? `${t.field.canonicalString()} ${t.op} ${ec(t.value)}` : t instanceof oT ? t.op.toString() + " {" + t.getFilters().map(e).join(" ,") + "}" : "Filter"
                }
                )(e)).join(", ")}]`),
                q(t.limit) || (r += ", limit: " + t.limit),
                t.orderBy.length > 0 && (r += `, orderBy: [${t.orderBy.map(e => `${e.field.canonicalString()} (${e.dir})`).join(", ")}]`),
                t.startAt && (r += ", startAt: ",
                r += t.startAt.inclusive ? "b:" : "a:",
                r += t.startAt.position.map(e => ec(e)).join(",")),
                t.endAt && (r += ", endAt: ",
                r += t.endAt.inclusive ? "a:" : "b:",
                r += t.endAt.position.map(e => ec(e)).join(",")),
                `Target(${r})`}; limitType=${e.limitType})`
            }
            function eJ(e, t) {
                return t.isFoundDocument() && function(e, t) {
                    let r = t.key.path;
                    return null !== e.collectionGroup ? t.key.hasCollectionId(e.collectionGroup) && e.path.isPrefixOf(r) : sW.isDocumentKey(e.path) ? e.path.isEqual(r) : e.path.isImmediateParentOf(r)
                }(e, t) && function(e, t) {
                    for (let r of eq(e))
                        if (!r.field.isKeyField() && null === t.data.field(r.field))
                            return !1;
                    return !0
                }(e, t) && function(e, t) {
                    for (let r of e.filters)
                        if (!r.matches(t))
                            return !1;
                    return !0
                }(e, t) && (!e.startAt || !!function(e, t, r) {
                    let n = e_(e, t, r);
                    return e.inclusive ? n <= 0 : n < 0
                }(e.startAt, eq(e), t)) && (!e.endAt || !!function(e, t, r) {
                    let n = e_(e, t, r);
                    return e.inclusive ? n >= 0 : n > 0
                }(e.endAt, eq(e), t))
            }
            function eY(e) {
                return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2))
            }
            function eX(e) {
                return (t, r) => {
                    let n = !1;
                    for (let i of eq(e)) {
                        let e = function(e, t, r) {
                            let n = e.field.isKeyField() ? sW.comparator(t.key, r.key) : function(e, t, r) {
                                let n = t.data.field(e)
                                  , i = r.data.field(e);
                                return null !== n && null !== i ? el(n, i) : E(42886)
                            }(e.field, t, r);
                            switch (e.dir) {
                            case "asc":
                                return n;
                            case "desc":
                                return -1 * n;
                            default:
                                return E(19790, {
                                    direction: e.dir
                                })
                            }
                        }(i, t, r);
                        if (0 !== e)
                            return e;
                        n = n || i.field.isKeyField()
                    }
                    return 0
                }
            }
            class oM {
                constructor(e, t) {
                    this.mapKeyFn = e,
                    this.equalsFn = t,
                    this.inner = {},
                    this.innerSize = 0
                }
                get(e) {
                    let t = this.mapKeyFn(e)
                      , r = this.inner[t];
                    if (void 0 !== r) {
                        for (let[t,n] of r)
                            if (this.equalsFn(t, e))
                                return n
                    }
                }
                has(e) {
                    return void 0 !== this.get(e)
                }
                set(e, t) {
                    let r = this.mapKeyFn(e)
                      , n = this.inner[r];
                    if (void 0 === n)
                        return this.inner[r] = [[e, t]],
                        void this.innerSize++;
                    for (let r = 0; r < n.length; r++)
                        if (this.equalsFn(n[r][0], e))
                            return void (n[r] = [e, t]);
                    n.push([e, t]),
                    this.innerSize++
                }
                delete(e) {
                    let t = this.mapKeyFn(e)
                      , r = this.inner[t];
                    if (void 0 === r)
                        return !1;
                    for (let n = 0; n < r.length; n++)
                        if (this.equalsFn(r[n][0], e))
                            return 1 === r.length ? delete this.inner[t] : r.splice(n, 1),
                            this.innerSize--,
                            !0;
                    return !1
                }
                forEach(e) {
                    H(this.inner, (t, r) => {
                        for (let[t,n] of r)
                            e(t, n)
                    }
                    )
                }
                isEmpty() {
                    return J(this.inner)
                }
                size() {
                    return this.innerSize
                }
            }
            let oP = new a5(sW.comparator)
              , oL = new a5(sW.comparator);
            function eZ(...e) {
                let t = oL;
                for (let r of e)
                    t = t.insert(r.key, r);
                return t
            }
            function e0(e) {
                let t = oL;
                return e.forEach( (e, r) => t = t.insert(e, r.overlayedDocument)),
                t
            }
            function e1() {
                return new oM(e => e.toString(), (e, t) => e.isEqual(t))
            }
            let oF = new a5(sW.comparator)
              , oB = new a7(sW.comparator);
            function e2(...e) {
                let t = oB;
                for (let r of e)
                    t = t.add(r);
                return t
            }
            let oV = new a7(C);
            function e6(e, t) {
                if (e.useProto3Json) {
                    if (isNaN(t))
                        return {
                            doubleValue: "NaN"
                        };
                    if (t === 1 / 0)
                        return {
                            doubleValue: "Infinity"
                        };
                    if (t === -1 / 0)
                        return {
                            doubleValue: "-Infinity"
                        }
                }
                return {
                    doubleValue: j(t) ? "-0" : t
                }
            }
            function e3(e) {
                return {
                    integerValue: "" + e
                }
            }
            function e5(e, t) {
                return z(t) ? e3(t) : e6(e, t)
            }
            class oU {
                constructor() {
                    this._ = void 0
                }
            }
            function e4(e, t) {
                return e instanceof oQ ? ef(t) || t && "doubleValue"in t ? t : {
                    integerValue: 0
                } : null
            }
            class oq extends oU {
            }
            class oj extends oU {
                constructor(e) {
                    super(),
                    this.elements = e
                }
            }
            function e8(e, t) {
                let r = te(t);
                for (let t of e.elements)
                    r.some(e => ea(e, t)) || r.push(t);
                return {
                    arrayValue: {
                        values: r
                    }
                }
            }
            class oz extends oU {
                constructor(e) {
                    super(),
                    this.elements = e
                }
            }
            function e7(e, t) {
                let r = te(t);
                for (let t of e.elements)
                    r = r.filter(e => !ea(e, t));
                return {
                    arrayValue: {
                        values: r
                    }
                }
            }
            class oQ extends oU {
                constructor(e, t) {
                    super(),
                    this.serializer = e,
                    this.Re = t
                }
            }
            function e9(e) {
                return ee(e.integerValue || e.doubleValue)
            }
            function te(e) {
                return ep(e) && e.arrayValue.values ? e.arrayValue.values.slice() : []
            }
            class oK {
                constructor(e, t) {
                    this.field = e,
                    this.transform = t
                }
            }
            class o$ {
                constructor(e, t) {
                    this.version = e,
                    this.transformResults = t
                }
            }
            class oG {
                constructor(e, t) {
                    this.updateTime = e,
                    this.exists = t
                }
                static none() {
                    return new oG
                }
                static exists(e) {
                    return new oG(void 0,e)
                }
                static updateTime(e) {
                    return new oG(e)
                }
                get isNone() {
                    return void 0 === this.updateTime && void 0 === this.exists
                }
                isEqual(e) {
                    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
                }
            }
            function tt(e, t) {
                return void 0 !== e.updateTime ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : void 0 === e.exists || e.exists === t.isFoundDocument()
            }
            class oH {
            }
            function tr(e, t) {
                if (!e.hasLocalMutations || t && 0 === t.fields.length)
                    return null;
                if (null === t)
                    return e.isNoDocument() ? new oY(e.key,oG.none()) : new oW(e.key,e.data,oG.none());
                {
                    let r = e.data
                      , n = ov.empty()
                      , i = new a7(sH.comparator);
                    for (let e of t.fields)
                        if (!i.has(e)) {
                            let t = r.field(e);
                            null === t && e.length > 1 && (e = e.popLast(),
                            t = r.field(e)),
                            null === t ? n.delete(e) : n.set(e, t),
                            i = i.add(e)
                        }
                    return new oJ(e.key,n,new oe(i.toArray()),oG.none())
                }
            }
            function tn(e, t, r, n) {
                return e instanceof oW ? function(e, t, r, n) {
                    if (!tt(e.precondition, t))
                        return r;
                    let i = e.value.clone()
                      , s = to(e.fieldTransforms, n, t);
                    return i.setAll(s),
                    t.convertToFoundDocument(t.version, i).setHasLocalMutations(),
                    null
                }(e, t, r, n) : e instanceof oJ ? function(e, t, r, n) {
                    if (!tt(e.precondition, t))
                        return r;
                    let i = to(e.fieldTransforms, n, t)
                      , s = t.data;
                    return (s.setAll(ts(e)),
                    s.setAll(i),
                    t.convertToFoundDocument(t.version, s).setHasLocalMutations(),
                    null === r) ? null : r.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map(e => e.field))
                }(e, t, r, n) : tt(e.precondition, t) ? (t.convertToNoDocument(t.version).setHasLocalMutations(),
                null) : r
            }
            function ti(e, t) {
                var r, n;
                return e.type === t.type && !!e.key.isEqual(t.key) && !!e.precondition.isEqual(t.precondition) && (r = e.fieldTransforms,
                n = t.fieldTransforms,
                !!(void 0 === r && void 0 === n || !(!r || !n) && D(r, n, (e, t) => {
                    var r, n;
                    return e.field.isEqual(t.field) && (r = e.transform,
                    n = t.transform,
                    r instanceof oj && n instanceof oj || r instanceof oz && n instanceof oz ? D(r.elements, n.elements, ea) : r instanceof oQ && n instanceof oQ ? ea(r.Re, n.Re) : r instanceof oq && n instanceof oq)
                }
                ))) && (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask))
            }
            class oW extends oH {
                constructor(e, t, r, n=[]) {
                    super(),
                    this.key = e,
                    this.value = t,
                    this.precondition = r,
                    this.fieldTransforms = n,
                    this.type = 0
                }
                getFieldMask() {
                    return null
                }
            }
            class oJ extends oH {
                constructor(e, t, r, n, i=[]) {
                    super(),
                    this.key = e,
                    this.data = t,
                    this.fieldMask = r,
                    this.precondition = n,
                    this.fieldTransforms = i,
                    this.type = 1
                }
                getFieldMask() {
                    return this.fieldMask
                }
            }
            function ts(e) {
                let t = new Map;
                return e.fieldMask.fields.forEach(r => {
                    if (!r.isEmpty()) {
                        let n = e.data.field(r);
                        t.set(r, n)
                    }
                }
                ),
                t
            }
            function ta(e, t, r) {
                let n = new Map;
                _(e.length === r.length, 32656, {
                    Ve: r.length,
                    me: e.length
                });
                for (let s = 0; s < r.length; s++) {
                    var i;
                    let a = e[s]
                      , o = a.transform
                      , l = t.data.field(a.field);
                    n.set(a.field, (i = r[s],
                    o instanceof oj ? e8(o, l) : o instanceof oz ? e7(o, l) : i))
                }
                return n
            }
            function to(e, t, r) {
                let n = new Map;
                for (let i of e) {
                    let e = i.transform
                      , s = r.data.field(i.field);
                    n.set(i.field, e instanceof oq ? function(e, t) {
                        let r = {
                            fields: {
                                [os]: {
                                    stringValue: oi
                                },
                                [oo]: {
                                    timestampValue: {
                                        seconds: e.seconds,
                                        nanos: e.nanoseconds
                                    }
                                }
                            }
                        };
                        return t && er(t) && (t = en(t)),
                        t && (r.fields[oa] = t),
                        {
                            mapValue: r
                        }
                    }(t, s) : e instanceof oj ? e8(e, s) : e instanceof oz ? e7(e, s) : function(e, t) {
                        let r = e4(e, t)
                          , n = e9(r) + e9(e.Re);
                        return ef(r) && ef(e.Re) ? e3(n) : e6(e.serializer, n)
                    }(e, s))
                }
                return n
            }
            class oY extends oH {
                constructor(e, t) {
                    super(),
                    this.key = e,
                    this.precondition = t,
                    this.type = 2,
                    this.fieldTransforms = []
                }
                getFieldMask() {
                    return null
                }
            }
            class oX extends oH {
                constructor(e, t) {
                    super(),
                    this.key = e,
                    this.precondition = t,
                    this.type = 3,
                    this.fieldTransforms = []
                }
                getFieldMask() {
                    return null
                }
            }
            class oZ {
                constructor(e, t, r, n) {
                    this.batchId = e,
                    this.localWriteTime = t,
                    this.baseMutations = r,
                    this.mutations = n
                }
                applyToRemoteDocument(e, t) {
                    let r = t.mutationResults;
                    for (let t = 0; t < this.mutations.length; t++) {
                        let n = this.mutations[t];
                        n.key.isEqual(e.key) && function(e, t, r) {
                            e instanceof oW ? function(e, t, r) {
                                let n = e.value.clone()
                                  , i = ta(e.fieldTransforms, t, r.transformResults);
                                n.setAll(i),
                                t.convertToFoundDocument(r.version, n).setHasCommittedMutations()
                            }(e, t, r) : e instanceof oJ ? function(e, t, r) {
                                if (!tt(e.precondition, t))
                                    return t.convertToUnknownDocument(r.version);
                                let n = ta(e.fieldTransforms, t, r.transformResults)
                                  , i = t.data;
                                i.setAll(ts(e)),
                                i.setAll(n),
                                t.convertToFoundDocument(r.version, i).setHasCommittedMutations()
                            }(e, t, r) : t.convertToNoDocument(r.version).setHasCommittedMutations()
                        }(n, e, r[t])
                    }
                }
                applyToLocalView(e, t) {
                    for (let r of this.baseMutations)
                        r.key.isEqual(e.key) && (t = tn(r, e, t, this.localWriteTime));
                    for (let r of this.mutations)
                        r.key.isEqual(e.key) && (t = tn(r, e, t, this.localWriteTime));
                    return t
                }
                applyToLocalDocumentSet(e, t) {
                    let r = e1();
                    return this.mutations.forEach(n => {
                        let i = e.get(n.key)
                          , s = i.overlayedDocument
                          , a = this.applyToLocalView(s, i.mutatedFields)
                          , o = tr(s, a = t.has(n.key) ? null : a);
                        null !== o && r.set(n.key, o),
                        s.isValidDocument() || s.convertToNoDocument(sz.min())
                    }
                    ),
                    r
                }
                keys() {
                    return this.mutations.reduce( (e, t) => e.add(t.key), e2())
                }
                isEqual(e) {
                    return this.batchId === e.batchId && D(this.mutations, e.mutations, (e, t) => ti(e, t)) && D(this.baseMutations, e.baseMutations, (e, t) => ti(e, t))
                }
            }
            class o0 {
                constructor(e, t, r, n) {
                    this.batch = e,
                    this.commitVersion = t,
                    this.mutationResults = r,
                    this.docVersions = n
                }
                static from(e, t, r) {
                    _(e.mutations.length === r.length, 58842, {
                        fe: e.mutations.length,
                        ge: r.length
                    });
                    let n = oF
                      , i = e.mutations;
                    for (let e = 0; e < i.length; e++)
                        n = n.insert(i[e].key, r[e].version);
                    return new o0(e,t,r,n)
                }
            }
            class o1 {
                constructor(e, t) {
                    this.largestBatchId = e,
                    this.mutation = t
                }
                getKey() {
                    return this.mutation.key
                }
                isEqual(e) {
                    return null !== e && this.mutation === e.mutation
                }
                toString() {
                    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
                }
            }
            class o2 {
                constructor(e, t, r) {
                    this.alias = e,
                    this.aggregateType = t,
                    this.fieldPath = r
                }
            }
            class o6 {
                constructor(e, t) {
                    this.count = e,
                    this.unchangedNames = t
                }
            }
            function tl(e) {
                switch (e) {
                case sD.OK:
                    return E(64938);
                case sD.CANCELLED:
                case sD.UNKNOWN:
                case sD.DEADLINE_EXCEEDED:
                case sD.RESOURCE_EXHAUSTED:
                case sD.INTERNAL:
                case sD.UNAVAILABLE:
                case sD.UNAUTHENTICATED:
                    return !1;
                case sD.INVALID_ARGUMENT:
                case sD.NOT_FOUND:
                case sD.ALREADY_EXISTS:
                case sD.PERMISSION_DENIED:
                case sD.FAILED_PRECONDITION:
                case sD.ABORTED:
                case sD.OUT_OF_RANGE:
                case sD.UNIMPLEMENTED:
                case sD.DATA_LOSS:
                    return !0;
                default:
                    return E(15467, {
                        code: e
                    })
                }
            }
            function tu(e) {
                if (void 0 === e)
                    return v("GRPC error has no .code"),
                    sD.UNKNOWN;
                switch (e) {
                case n.OK:
                    return sD.OK;
                case n.CANCELLED:
                    return sD.CANCELLED;
                case n.UNKNOWN:
                    return sD.UNKNOWN;
                case n.DEADLINE_EXCEEDED:
                    return sD.DEADLINE_EXCEEDED;
                case n.RESOURCE_EXHAUSTED:
                    return sD.RESOURCE_EXHAUSTED;
                case n.INTERNAL:
                    return sD.INTERNAL;
                case n.UNAVAILABLE:
                    return sD.UNAVAILABLE;
                case n.UNAUTHENTICATED:
                    return sD.UNAUTHENTICATED;
                case n.INVALID_ARGUMENT:
                    return sD.INVALID_ARGUMENT;
                case n.NOT_FOUND:
                    return sD.NOT_FOUND;
                case n.ALREADY_EXISTS:
                    return sD.ALREADY_EXISTS;
                case n.PERMISSION_DENIED:
                    return sD.PERMISSION_DENIED;
                case n.FAILED_PRECONDITION:
                    return sD.FAILED_PRECONDITION;
                case n.ABORTED:
                    return sD.ABORTED;
                case n.OUT_OF_RANGE:
                    return sD.OUT_OF_RANGE;
                case n.UNIMPLEMENTED:
                    return sD.UNIMPLEMENTED;
                case n.DATA_LOSS:
                    return sD.DATA_LOSS;
                default:
                    return E(39323, {
                        code: e
                    })
                }
            }
            (i = n || (n = {}))[i.OK = 0] = "OK",
            i[i.CANCELLED = 1] = "CANCELLED",
            i[i.UNKNOWN = 2] = "UNKNOWN",
            i[i.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT",
            i[i.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED",
            i[i.NOT_FOUND = 5] = "NOT_FOUND",
            i[i.ALREADY_EXISTS = 6] = "ALREADY_EXISTS",
            i[i.PERMISSION_DENIED = 7] = "PERMISSION_DENIED",
            i[i.UNAUTHENTICATED = 16] = "UNAUTHENTICATED",
            i[i.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED",
            i[i.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION",
            i[i.ABORTED = 10] = "ABORTED",
            i[i.OUT_OF_RANGE = 11] = "OUT_OF_RANGE",
            i[i.UNIMPLEMENTED = 12] = "UNIMPLEMENTED",
            i[i.INTERNAL = 13] = "INTERNAL",
            i[i.UNAVAILABLE = 14] = "UNAVAILABLE",
            i[i.DATA_LOSS = 15] = "DATA_LOSS";
            let o3 = null
              , o5 = new f.Integer([0xffffffff, 0xffffffff],0);
            function th(e) {
                let t = S().encode(e)
                  , r = new f.Md5;
                return r.update(t),
                new Uint8Array(r.digest())
            }
            function tc(e) {
                let t = new DataView(e.buffer)
                  , r = t.getUint32(0, !0)
                  , n = t.getUint32(4, !0)
                  , i = t.getUint32(8, !0)
                  , s = t.getUint32(12, !0);
                return [new f.Integer([r, n],0), new f.Integer([i, s],0)]
            }
            class o4 {
                constructor(e, t, r) {
                    if (this.bitmap = e,
                    this.padding = t,
                    this.hashCount = r,
                    t < 0 || t >= 8)
                        throw new o8(`Invalid padding: ${t}`);
                    if (r < 0 || e.length > 0 && 0 === this.hashCount)
                        throw new o8(`Invalid hash count: ${r}`);
                    if (0 === e.length && 0 !== t)
                        throw new o8(`Invalid padding when bitmap length is 0: ${t}`);
                    this.pe = 8 * e.length - t,
                    this.ye = f.Integer.fromNumber(this.pe)
                }
                we(e, t, r) {
                    let n = e.add(t.multiply(f.Integer.fromNumber(r)));
                    return 1 === n.compare(o5) && (n = new f.Integer([n.getBits(0), n.getBits(1)],0)),
                    n.modulo(this.ye).toNumber()
                }
                be(e) {
                    return !!(this.bitmap[Math.floor(e / 8)] & 1 << e % 8)
                }
                mightContain(e) {
                    if (0 === this.pe)
                        return !1;
                    let[t,r] = tc(th(e));
                    for (let e = 0; e < this.hashCount; e++) {
                        let n = this.we(t, r, e);
                        if (!this.be(n))
                            return !1
                    }
                    return !0
                }
                static create(e, t, r) {
                    let n = new o4(new Uint8Array(Math.ceil(e / 8)),e % 8 == 0 ? 0 : 8 - e % 8,t);
                    return r.forEach(e => n.insert(e)),
                    n
                }
                insert(e) {
                    if (0 === this.pe)
                        return;
                    let[t,r] = tc(th(e));
                    for (let e = 0; e < this.hashCount; e++) {
                        let n = this.we(t, r, e);
                        this.Se(n)
                    }
                }
                Se(e) {
                    let t = Math.floor(e / 8);
                    this.bitmap[t] |= 1 << e % 8
                }
            }
            class o8 extends Error {
                constructor() {
                    super(...arguments),
                    this.name = "BloomFilterError"
                }
            }
            class o7 {
                constructor(e, t, r, n, i) {
                    this.snapshotVersion = e,
                    this.targetChanges = t,
                    this.targetMismatches = r,
                    this.documentUpdates = n,
                    this.resolvedLimboDocuments = i
                }
                static createSynthesizedRemoteEventForCurrentChange(e, t, r) {
                    let n = new Map;
                    return n.set(e, o9.createSynthesizedTargetChangeForCurrentChange(e, t, r)),
                    new o7(sz.min(),n,new a5(C),oP,e2())
                }
            }
            class o9 {
                constructor(e, t, r, n, i) {
                    this.resumeToken = e,
                    this.current = t,
                    this.addedDocuments = r,
                    this.modifiedDocuments = n,
                    this.removedDocuments = i
                }
                static createSynthesizedTargetChangeForCurrentChange(e, t, r) {
                    return new o9(r,t,e2(),e2(),e2())
                }
            }
            class le {
                constructor(e, t, r, n) {
                    this.De = e,
                    this.removedTargetIds = t,
                    this.key = r,
                    this.ve = n
                }
            }
            class lt {
                constructor(e, t) {
                    this.targetId = e,
                    this.Ce = t
                }
            }
            class lr {
                constructor(e, t, r=or.EMPTY_BYTE_STRING, n=null) {
                    this.state = e,
                    this.targetIds = t,
                    this.resumeToken = r,
                    this.cause = n
                }
            }
            class ln {
                constructor() {
                    this.Fe = 0,
                    this.Me = tf(),
                    this.xe = or.EMPTY_BYTE_STRING,
                    this.Oe = !1,
                    this.Ne = !0
                }
                get current() {
                    return this.Oe
                }
                get resumeToken() {
                    return this.xe
                }
                get Be() {
                    return 0 !== this.Fe
                }
                get Le() {
                    return this.Ne
                }
                ke(e) {
                    e.approximateByteSize() > 0 && (this.Ne = !0,
                    this.xe = e)
                }
                qe() {
                    let e = e2()
                      , t = e2()
                      , r = e2();
                    return this.Me.forEach( (n, i) => {
                        switch (i) {
                        case 0:
                            e = e.add(n);
                            break;
                        case 2:
                            t = t.add(n);
                            break;
                        case 1:
                            r = r.add(n);
                            break;
                        default:
                            E(38017, {
                                changeType: i
                            })
                        }
                    }
                    ),
                    new o9(this.xe,this.Oe,e,t,r)
                }
                Qe() {
                    this.Ne = !1,
                    this.Me = tf()
                }
                $e(e, t) {
                    this.Ne = !0,
                    this.Me = this.Me.insert(e, t)
                }
                Ue(e) {
                    this.Ne = !0,
                    this.Me = this.Me.remove(e)
                }
                Ke() {
                    this.Fe += 1
                }
                We() {
                    this.Fe -= 1,
                    _(this.Fe >= 0, 3241, {
                        Fe: this.Fe
                    })
                }
                Ge() {
                    this.Ne = !0,
                    this.Oe = !0
                }
            }
            class li {
                constructor(e) {
                    this.ze = e,
                    this.je = new Map,
                    this.He = oP,
                    this.Je = td(),
                    this.Ye = td(),
                    this.Ze = new a5(C)
                }
                Xe(e) {
                    for (let t of e.De)
                        e.ve && e.ve.isFoundDocument() ? this.et(t, e.ve) : this.tt(t, e.key, e.ve);
                    for (let t of e.removedTargetIds)
                        this.tt(t, e.key, e.ve)
                }
                nt(e) {
                    this.forEachTarget(e, t => {
                        let r = this.rt(t);
                        switch (e.state) {
                        case 0:
                            this.it(t) && r.ke(e.resumeToken);
                            break;
                        case 1:
                            r.We(),
                            r.Be || r.Qe(),
                            r.ke(e.resumeToken);
                            break;
                        case 2:
                            r.We(),
                            r.Be || this.removeTarget(t);
                            break;
                        case 3:
                            this.it(t) && (r.Ge(),
                            r.ke(e.resumeToken));
                            break;
                        case 4:
                            this.it(t) && (this.st(t),
                            r.ke(e.resumeToken));
                            break;
                        default:
                            E(56790, {
                                state: e.state
                            })
                        }
                    }
                    )
                }
                forEachTarget(e, t) {
                    e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.je.forEach( (e, r) => {
                        this.it(r) && t(r)
                    }
                    )
                }
                ot(e) {
                    let t = e.targetId
                      , r = e.Ce.count
                      , n = this._t(t);
                    if (n) {
                        let i = n.target;
                        if (eM(i))
                            if (0 === r) {
                                let e = new sW(i.path);
                                this.tt(t, e, ow.newNoDocument(e, sz.min()))
                            } else
                                _(1 === r, 20013, {
                                    expectedCount: r
                                });
                        else {
                            let n = this.ut(t);
                            if (n !== r) {
                                let r = this.ct(e)
                                  , i = r ? this.lt(r, e, n) : 1;
                                0 !== i && (this.st(t),
                                this.Ze = this.Ze.insert(t, 2 === i ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch")),
                                null == o3 || o3.ht(function(e, t, r, n, i) {
                                    var s, a, o, l, u, h;
                                    let c = {
                                        localCacheCount: e,
                                        existenceFilterCount: t.count,
                                        databaseId: r.database,
                                        projectId: r.projectId
                                    }
                                      , d = t.unchangedNames;
                                    return d && (c.bloomFilter = {
                                        applied: 0 === i,
                                        hashCount: null != (s = null == d ? void 0 : d.hashCount) ? s : 0,
                                        bitmapLength: null != (l = null == (o = null == (a = null == d ? void 0 : d.bits) ? void 0 : a.bitmap) ? void 0 : o.length) ? l : 0,
                                        padding: null != (h = null == (u = null == d ? void 0 : d.bits) ? void 0 : u.padding) ? h : 0,
                                        mightContain: e => {
                                            var t;
                                            return null != (t = null == n ? void 0 : n.mightContain(e)) && t
                                        }
                                    }),
                                    c
                                }(n, e.Ce, this.ze.Pt(), r, i))
                            }
                        }
                    }
                }
                ct(e) {
                    let t, r, n = e.Ce.unchangedNames;
                    if (!n || !n.bits)
                        return null;
                    let {bits: {bitmap: i="", padding: s=0}, hashCount: a=0} = n;
                    try {
                        t = et(i).toUint8Array()
                    } catch (e) {
                        if (e instanceof ot)
                            return w("Decoding the base64 bloom filter in existence filter failed (" + e.message + "); ignoring the bloom filter and falling back to full re-query."),
                            null;
                        throw e
                    }
                    try {
                        r = new o4(t,s,a)
                    } catch (e) {
                        return w(e instanceof o8 ? "BloomFilter error: " : "Applying bloom filter failed: ", e),
                        null
                    }
                    return 0 === r.pe ? null : r
                }
                lt(e, t, r) {
                    return 2 * (t.Ce.count !== r - this.Tt(e, t.targetId))
                }
                Tt(e, t) {
                    let r = this.ze.getRemoteKeysForTarget(t)
                      , n = 0;
                    return r.forEach(r => {
                        let i = this.ze.Pt()
                          , s = `projects/${i.projectId}/databases/${i.database}/documents/${r.path.canonicalString()}`;
                        e.mightContain(s) || (this.tt(t, r, null),
                        n++)
                    }
                    ),
                    n
                }
                It(e) {
                    let t = new Map;
                    this.je.forEach( (r, n) => {
                        let i = this._t(n);
                        if (i) {
                            if (r.current && eM(i.target)) {
                                let t = new sW(i.target.path);
                                this.Et(t).has(n) || this.dt(n, t) || this.tt(n, t, ow.newNoDocument(t, e))
                            }
                            r.Le && (t.set(n, r.qe()),
                            r.Qe())
                        }
                    }
                    );
                    let r = e2();
                    this.Ye.forEach( (e, t) => {
                        let n = !0;
                        t.forEachWhile(e => {
                            let t = this._t(e);
                            return !t || "TargetPurposeLimboResolution" === t.purpose || (n = !1,
                            !1)
                        }
                        ),
                        n && (r = r.add(e))
                    }
                    ),
                    this.He.forEach( (t, r) => r.setReadTime(e));
                    let n = new o7(e,t,this.Ze,this.He,r);
                    return this.He = oP,
                    this.Je = td(),
                    this.Ye = td(),
                    this.Ze = new a5(C),
                    n
                }
                et(e, t) {
                    if (!this.it(e))
                        return;
                    let r = 2 * !!this.dt(e, t.key);
                    this.rt(e).$e(t.key, r),
                    this.He = this.He.insert(t.key, t),
                    this.Je = this.Je.insert(t.key, this.Et(t.key).add(e)),
                    this.Ye = this.Ye.insert(t.key, this.At(t.key).add(e))
                }
                tt(e, t, r) {
                    if (!this.it(e))
                        return;
                    let n = this.rt(e);
                    this.dt(e, t) ? n.$e(t, 1) : n.Ue(t),
                    this.Ye = this.Ye.insert(t, this.At(t).delete(e)),
                    this.Ye = this.Ye.insert(t, this.At(t).add(e)),
                    r && (this.He = this.He.insert(t, r))
                }
                removeTarget(e) {
                    this.je.delete(e)
                }
                ut(e) {
                    let t = this.rt(e).qe();
                    return this.ze.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size
                }
                Ke(e) {
                    this.rt(e).Ke()
                }
                rt(e) {
                    let t = this.je.get(e);
                    return t || (t = new ln,
                    this.je.set(e, t)),
                    t
                }
                At(e) {
                    let t = this.Ye.get(e);
                    return t || (t = new a7(C),
                    this.Ye = this.Ye.insert(e, t)),
                    t
                }
                Et(e) {
                    let t = this.Je.get(e);
                    return t || (t = new a7(C),
                    this.Je = this.Je.insert(e, t)),
                    t
                }
                it(e) {
                    let t = null !== this._t(e);
                    return t || y("WatchChangeAggregator", "Detected inactive target", e),
                    t
                }
                _t(e) {
                    let t = this.je.get(e);
                    return t && t.Be ? null : this.ze.Rt(e)
                }
                st(e) {
                    this.je.set(e, new ln),
                    this.ze.getRemoteKeysForTarget(e).forEach(t => {
                        this.tt(e, t, null)
                    }
                    )
                }
                dt(e, t) {
                    return this.ze.getRemoteKeysForTarget(e).has(t)
                }
            }
            function td() {
                return new a5(sW.comparator)
            }
            function tf() {
                return new a5(sW.comparator)
            }
            let ls = {
                asc: "ASCENDING",
                desc: "DESCENDING"
            }
              , la = {
                "<": "LESS_THAN",
                "<=": "LESS_THAN_OR_EQUAL",
                ">": "GREATER_THAN",
                ">=": "GREATER_THAN_OR_EQUAL",
                "==": "EQUAL",
                "!=": "NOT_EQUAL",
                "array-contains": "ARRAY_CONTAINS",
                in: "IN",
                "not-in": "NOT_IN",
                "array-contains-any": "ARRAY_CONTAINS_ANY"
            }
              , lo = {
                and: "AND",
                or: "OR"
            };
            class ll {
                constructor(e, t) {
                    this.databaseId = e,
                    this.useProto3Json = t
                }
            }
            function tp(e, t) {
                return e.useProto3Json || q(t) ? t : {
                    value: t
                }
            }
            function tg(e, t) {
                return e.useProto3Json ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z` : {
                    seconds: "" + t.seconds,
                    nanos: t.nanoseconds
                }
            }
            function tm(e, t) {
                return e.useProto3Json ? t.toBase64() : t.toUint8Array()
            }
            function ty(e) {
                return _(!!e, 49232),
                sz.fromTimestamp(function(e) {
                    let t = Z(e);
                    return new sj(t.seconds,t.nanos)
                }(e))
            }
            function tv(e, t) {
                return tw(e, t).canonicalString()
            }
            function tw(e, t) {
                let r = new s$(["projects", e.projectId, "databases", e.database]).child("documents");
                return void 0 === t ? r : r.child(t)
            }
            function tb(e) {
                let t = s$.fromString(e);
                return _(tF(t), 10190, {
                    key: t.toString()
                }),
                t
            }
            function tE(e, t) {
                return tv(e.databaseId, t.path)
            }
            function tI(e, t) {
                let r = tb(t);
                if (r.get(1) !== e.databaseId.projectId)
                    throw new sk(sD.INVALID_ARGUMENT,"Tried to deserialize key from different project: " + r.get(1) + " vs " + e.databaseId.projectId);
                if (r.get(3) !== e.databaseId.database)
                    throw new sk(sD.INVALID_ARGUMENT,"Tried to deserialize key from different database: " + r.get(3) + " vs " + e.databaseId.database);
                return new sW(tC(r))
            }
            function t_(e, t) {
                return tv(e.databaseId, t)
            }
            function tT(e) {
                let t = tb(e);
                return 4 === t.length ? s$.emptyPath() : tC(t)
            }
            function tS(e) {
                return new s$(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString()
            }
            function tC(e) {
                return _(e.length > 4 && "documents" === e.get(4), 29091, {
                    key: e.toString()
                }),
                e.popFirst(5)
            }
            function tx(e, t, r) {
                return {
                    name: tE(e, t),
                    fields: r.value.mapValue.fields
                }
            }
            function tA(e, t, r) {
                let n = tI(e, t.name)
                  , i = ty(t.updateTime)
                  , s = t.createTime ? ty(t.createTime) : sz.min()
                  , a = new ov({
                    mapValue: {
                        fields: t.fields
                    }
                })
                  , o = ow.newFoundDocument(n, i, s, a);
                return r && o.setHasCommittedMutations(),
                r ? o.setHasCommittedMutations() : o
            }
            function tD(e, t) {
                var r;
                let n;
                if (t instanceof oW)
                    n = {
                        update: tx(e, t.key, t.value)
                    };
                else if (t instanceof oY)
                    n = {
                        delete: tE(e, t.key)
                    };
                else if (t instanceof oJ)
                    n = {
                        update: tx(e, t.key, t.data),
                        updateMask: function(e) {
                            let t = [];
                            return e.fields.forEach(e => t.push(e.canonicalString())),
                            {
                                fieldPaths: t
                            }
                        }(t.fieldMask)
                    };
                else {
                    if (!(t instanceof oX))
                        return E(16599, {
                            ft: t.type
                        });
                    n = {
                        verify: tE(e, t.key)
                    }
                }
                return t.fieldTransforms.length > 0 && (n.updateTransforms = t.fieldTransforms.map(e => (function(e, t) {
                    let r = t.transform;
                    if (r instanceof oq)
                        return {
                            fieldPath: t.field.canonicalString(),
                            setToServerValue: "REQUEST_TIME"
                        };
                    if (r instanceof oj)
                        return {
                            fieldPath: t.field.canonicalString(),
                            appendMissingElements: {
                                values: r.elements
                            }
                        };
                    if (r instanceof oz)
                        return {
                            fieldPath: t.field.canonicalString(),
                            removeAllFromArray: {
                                values: r.elements
                            }
                        };
                    if (r instanceof oQ)
                        return {
                            fieldPath: t.field.canonicalString(),
                            increment: r.Re
                        };
                    throw E(20930, {
                        transform: t.transform
                    })
                }
                )(0, e))),
                t.precondition.isNone || (n.currentDocument = void 0 !== (r = t.precondition).updateTime ? {
                    updateTime: tg(e, r.updateTime.toTimestamp())
                } : void 0 !== r.exists ? {
                    exists: r.exists
                } : E(27497)),
                n
            }
            function tk(e, t) {
                var r;
                let n = t.currentDocument ? void 0 !== (r = t.currentDocument).updateTime ? oG.updateTime(ty(r.updateTime)) : void 0 !== r.exists ? oG.exists(r.exists) : oG.none() : oG.none()
                  , i = t.updateTransforms ? t.updateTransforms.map(t => {
                    let r;
                    return r = null,
                    "setToServerValue"in t ? (_("REQUEST_TIME" === t.setToServerValue, 16630, {
                        proto: t
                    }),
                    r = new oq) : "appendMissingElements"in t ? r = new oj(t.appendMissingElements.values || []) : "removeAllFromArray"in t ? r = new oz(t.removeAllFromArray.values || []) : "increment"in t ? r = new oQ(e,t.increment) : E(16584, {
                        proto: t
                    }),
                    new oK(sH.fromServerFormat(t.fieldPath),r)
                }
                ) : [];
                if (t.update) {
                    t.update.name;
                    let r = tI(e, t.update.name)
                      , s = new ov({
                        mapValue: {
                            fields: t.update.fields
                        }
                    });
                    return t.updateMask ? new oJ(r,s,new oe((t.updateMask.fieldPaths || []).map(e => sH.fromServerFormat(e))),n,i) : new oW(r,s,n,i)
                }
                return t.delete ? new oY(tI(e, t.delete),n) : t.verify ? new oX(tI(e, t.verify),n) : E(1463, {
                    proto: t
                })
            }
            function tN(e, t) {
                return {
                    documents: [t_(e, t.path)]
                }
            }
            function tO(e, t) {
                var r, n;
                let i, s = {
                    structuredQuery: {}
                }, a = t.path;
                null !== t.collectionGroup ? (i = a,
                s.structuredQuery.from = [{
                    collectionId: t.collectionGroup,
                    allDescendants: !0
                }]) : (i = a.popLast(),
                s.structuredQuery.from = [{
                    collectionId: a.lastSegment()
                }]),
                s.parent = t_(e, i);
                let o = function(e) {
                    if (0 !== e.length)
                        return function e(t) {
                            return t instanceof o_ ? function(e) {
                                if ("==" === e.op) {
                                    if (em(e.value))
                                        return {
                                            unaryFilter: {
                                                field: tP(e.field),
                                                op: "IS_NAN"
                                            }
                                        };
                                    if (eg(e.value))
                                        return {
                                            unaryFilter: {
                                                field: tP(e.field),
                                                op: "IS_NULL"
                                            }
                                        }
                                } else if ("!=" === e.op) {
                                    if (em(e.value))
                                        return {
                                            unaryFilter: {
                                                field: tP(e.field),
                                                op: "IS_NOT_NAN"
                                            }
                                        };
                                    if (eg(e.value))
                                        return {
                                            unaryFilter: {
                                                field: tP(e.field),
                                                op: "IS_NOT_NULL"
                                            }
                                        }
                                }
                                return {
                                    fieldFilter: {
                                        field: tP(e.field),
                                        op: la[e.op],
                                        value: e.value
                                    }
                                }
                            }(t) : t instanceof oT ? function(t) {
                                let r = t.getFilters().map(t => e(t));
                                return 1 === r.length ? r[0] : {
                                    compositeFilter: {
                                        op: lo[t.op],
                                        filters: r
                                    }
                                }
                            }(t) : E(54877, {
                                filter: t
                            })
                        }(oT.create(e, "and"))
                }(t.filters);
                o && (s.structuredQuery.where = o);
                let l = function(e) {
                    if (0 !== e.length)
                        return e.map(e => ({
                            field: tP(e.field),
                            direction: ls[e.dir]
                        }))
                }(t.orderBy);
                l && (s.structuredQuery.orderBy = l);
                let u = tp(e, t.limit);
                return null !== u && (s.structuredQuery.limit = u),
                t.startAt && (s.structuredQuery.startAt = {
                    before: (r = t.startAt).inclusive,
                    values: r.position
                }),
                t.endAt && (s.structuredQuery.endAt = {
                    before: !(n = t.endAt).inclusive,
                    values: n.position
                }),
                {
                    gt: s,
                    parent: i
                }
            }
            function tR(e, t, r, n) {
                let {gt: i, parent: s} = tO(e, t)
                  , a = {}
                  , o = []
                  , l = 0;
                return r.forEach(e => {
                    let t = n ? e.alias : "aggregate_" + l++;
                    a[t] = e.alias,
                    "count" === e.aggregateType ? o.push({
                        alias: t,
                        count: {}
                    }) : "avg" === e.aggregateType ? o.push({
                        alias: t,
                        avg: {
                            field: tP(e.fieldPath)
                        }
                    }) : "sum" === e.aggregateType && o.push({
                        alias: t,
                        sum: {
                            field: tP(e.fieldPath)
                        }
                    })
                }
                ),
                {
                    request: {
                        structuredAggregationQuery: {
                            aggregations: o,
                            structuredQuery: i.structuredQuery
                        },
                        parent: i.parent
                    },
                    yt: a,
                    parent: s
                }
            }
            function tM(e) {
                var t;
                let r, n = tT(e.parent), i = e.structuredQuery, s = i.from ? i.from.length : 0, a = null;
                if (s > 0) {
                    _(1 === s, 65062);
                    let e = i.from[0];
                    e.allDescendants ? a = e.collectionId : n = n.child(e.collectionId)
                }
                let o = [];
                i.where && (o = function(e) {
                    let t = function e(t) {
                        return void 0 !== t.unaryFilter ? function(e) {
                            switch (e.unaryFilter.op) {
                            case "IS_NAN":
                                let t = tL(e.unaryFilter.field);
                                return o_.create(t, "==", {
                                    doubleValue: NaN
                                });
                            case "IS_NULL":
                                let r = tL(e.unaryFilter.field);
                                return o_.create(r, "==", {
                                    nullValue: "NULL_VALUE"
                                });
                            case "IS_NOT_NAN":
                                let n = tL(e.unaryFilter.field);
                                return o_.create(n, "!=", {
                                    doubleValue: NaN
                                });
                            case "IS_NOT_NULL":
                                let i = tL(e.unaryFilter.field);
                                return o_.create(i, "!=", {
                                    nullValue: "NULL_VALUE"
                                });
                            case "OPERATOR_UNSPECIFIED":
                                return E(61313);
                            default:
                                return E(60726)
                            }
                        }(t) : void 0 !== t.fieldFilter ? o_.create(tL(t.fieldFilter.field), function(e) {
                            switch (e) {
                            case "EQUAL":
                                return "==";
                            case "NOT_EQUAL":
                                return "!=";
                            case "GREATER_THAN":
                                return ">";
                            case "GREATER_THAN_OR_EQUAL":
                                return ">=";
                            case "LESS_THAN":
                                return "<";
                            case "LESS_THAN_OR_EQUAL":
                                return "<=";
                            case "ARRAY_CONTAINS":
                                return "array-contains";
                            case "IN":
                                return "in";
                            case "NOT_IN":
                                return "not-in";
                            case "ARRAY_CONTAINS_ANY":
                                return "array-contains-any";
                            case "OPERATOR_UNSPECIFIED":
                                return E(58110);
                            default:
                                return E(50506)
                            }
                        }(t.fieldFilter.op), t.fieldFilter.value) : void 0 !== t.compositeFilter ? oT.create(t.compositeFilter.filters.map(t => e(t)), function(e) {
                            switch (e) {
                            case "AND":
                                return "and";
                            case "OR":
                                return "or";
                            default:
                                return E(1026)
                            }
                        }(t.compositeFilter.op)) : E(30097, {
                            filter: t
                        })
                    }(e);
                    return t instanceof oT && ex(t) ? t.getFilters() : [t]
                }(i.where));
                let l = [];
                i.orderBy && (l = i.orderBy.map(e => new oE(tL(e.field),function(e) {
                    switch (e) {
                    case "ASCENDING":
                        return "asc";
                    case "DESCENDING":
                        return "desc";
                    default:
                        return
                    }
                }(e.direction))));
                let u = null;
                i.limit && (u = q(r = "object" == typeof (t = i.limit) ? t.value : t) ? null : r);
                let h = null;
                i.startAt && (h = function(e) {
                    let t = !!e.before;
                    return new ob(e.values || [],t)
                }(i.startAt));
                let c = null;
                return i.endAt && (c = function(e) {
                    let t = !e.before;
                    return new ob(e.values || [],t)
                }(i.endAt)),
                new oR(n,a,l,o,u,"F",h,c)
            }
            function tP(e) {
                return {
                    fieldPath: e.canonicalString()
                }
            }
            function tL(e) {
                return sH.fromServerFormat(e.fieldPath)
            }
            function tF(e) {
                return e.length >= 4 && "projects" === e.get(0) && "databases" === e.get(2)
            }
            class lu {
                constructor(e, t, r, n, i=sz.min(), s=sz.min(), a=or.EMPTY_BYTE_STRING, o=null) {
                    this.target = e,
                    this.targetId = t,
                    this.purpose = r,
                    this.sequenceNumber = n,
                    this.snapshotVersion = i,
                    this.lastLimboFreeSnapshotVersion = s,
                    this.resumeToken = a,
                    this.expectedCount = o
                }
                withSequenceNumber(e) {
                    return new lu(this.target,this.targetId,this.purpose,e,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)
                }
                withResumeToken(e, t) {
                    return new lu(this.target,this.targetId,this.purpose,this.sequenceNumber,t,this.lastLimboFreeSnapshotVersion,e,null)
                }
                withExpectedCount(e) {
                    return new lu(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,e)
                }
                withLastLimboFreeSnapshotVersion(e) {
                    return new lu(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,e,this.resumeToken,this.expectedCount)
                }
            }
            class lh {
                constructor(e) {
                    this.wt = e
                }
            }
            function tB(e, t) {
                let r = t.key
                  , n = {
                    prefixPath: r.getCollectionPath().popLast().toArray(),
                    collectionGroup: r.collectionGroup,
                    documentId: r.path.lastSegment(),
                    readTime: tV(t.readTime),
                    hasCommittedMutations: t.hasCommittedMutations
                };
                if (t.isFoundDocument()) {
                    var i;
                    n.document = {
                        name: tE(i = e.wt, t.key),
                        fields: t.data.value.mapValue.fields,
                        updateTime: tg(i, t.version.toTimestamp()),
                        createTime: tg(i, t.createTime.toTimestamp())
                    }
                } else if (t.isNoDocument())
                    n.noDocument = {
                        path: r.path.toArray(),
                        readTime: tU(t.version)
                    };
                else {
                    if (!t.isUnknownDocument())
                        return E(57904, {
                            document: t
                        });
                    n.unknownDocument = {
                        path: r.path.toArray(),
                        version: tU(t.version)
                    }
                }
                return n
            }
            function tV(e) {
                let t = e.toTimestamp();
                return [t.seconds, t.nanoseconds]
            }
            function tU(e) {
                let t = e.toTimestamp();
                return {
                    seconds: t.seconds,
                    nanoseconds: t.nanoseconds
                }
            }
            function tq(e) {
                let t = new sj(e.seconds,e.nanoseconds);
                return sz.fromTimestamp(t)
            }
            function tj(e, t) {
                let r = (t.baseMutations || []).map(t => tk(e.wt, t));
                for (let e = 0; e < t.mutations.length - 1; ++e) {
                    let r = t.mutations[e];
                    e + 1 < t.mutations.length && void 0 !== t.mutations[e + 1].transform && (r.updateTransforms = t.mutations[e + 1].transform.fieldTransforms,
                    t.mutations.splice(e + 1, 1),
                    ++e)
                }
                let n = t.mutations.map(t => tk(e.wt, t))
                  , i = sj.fromMillis(t.localWriteTimeMs);
                return new oZ(t.batchId,i,r,n)
            }
            function tz(e) {
                let t = tq(e.readTime)
                  , r = void 0 !== e.lastLimboFreeSnapshotVersion ? tq(e.lastLimboFreeSnapshotVersion) : sz.min();
                return new lu(void 0 !== e.query.documents ? function(e) {
                    let t = e.documents.length;
                    return _(1 === t, 1966, {
                        count: t
                    }),
                    ej(eB(tT(e.documents[0])))
                }(e.query) : ej(tM(e.query)),e.targetId,"TargetPurposeListen",e.lastListenSequenceNumber,t,r,or.fromBase64String(e.resumeToken))
            }
            function tQ(e, t) {
                let r, n = tU(t.snapshotVersion), i = tU(t.lastLimboFreeSnapshotVersion);
                r = eM(t.target) ? tN(e.wt, t.target) : tO(e.wt, t.target).gt;
                let s = t.resumeToken.toBase64();
                return {
                    targetId: t.targetId,
                    canonicalId: eO(t.target),
                    readTime: n,
                    resumeToken: s,
                    lastListenSequenceNumber: t.sequenceNumber,
                    lastLimboFreeSnapshotVersion: i,
                    query: r
                }
            }
            function tK(e) {
                let t = tM({
                    parent: e.parent,
                    structuredQuery: e.structuredQuery
                });
                return "LAST" === e.limitType ? e$(t, t.limit, "L") : t
            }
            function t$(e, t) {
                return new o1(t.largestBatchId,tk(e.wt, t.overlayMutation))
            }
            function tG(e, t) {
                let r = t.path.lastSegment();
                return [e, Q(t.path.popLast()), r]
            }
            function tH(e, t, r, n) {
                return {
                    indexId: e,
                    uid: t,
                    sequenceNumber: r,
                    readTime: tU(n.readTime),
                    documentKey: Q(n.documentKey.path),
                    largestBatchId: n.largestBatchId
                }
            }
            class lc {
                getBundleMetadata(e, t) {
                    return $(e, aM).get(t).next(e => {
                        if (e)
                            return {
                                id: e.bundleId,
                                createTime: tq(e.createTime),
                                version: e.version
                            }
                    }
                    )
                }
                saveBundleMetadata(e, t) {
                    return $(e, aM).put({
                        bundleId: t.id,
                        createTime: tU(ty(t.createTime)),
                        version: t.version
                    })
                }
                getNamedQuery(e, t) {
                    return $(e, aP).get(t).next(e => {
                        if (e)
                            return {
                                name: e.name,
                                query: tK(e.bundledQuery),
                                readTime: tq(e.readTime)
                            }
                    }
                    )
                }
                saveNamedQuery(e, t) {
                    return $(e, aP).put({
                        name: t.name,
                        readTime: tU(ty(t.readTime)),
                        bundledQuery: t.bundledQuery
                    })
                }
            }
            class ld {
                constructor(e, t) {
                    this.serializer = e,
                    this.userId = t
                }
                static bt(e, t) {
                    return new ld(e,t.uid || "")
                }
                getOverlay(e, t) {
                    return $(e, a$).get(tG(this.userId, t)).next(e => e ? t$(this.serializer, e) : null)
                }
                getOverlays(e, t) {
                    let r = e1();
                    return s2.forEach(t, t => this.getOverlay(e, t).next(e => {
                        null !== e && r.set(t, e)
                    }
                    )).next( () => r)
                }
                saveOverlays(e, t, r) {
                    let n = [];
                    return r.forEach( (r, i) => {
                        let s = new o1(t,i);
                        n.push(this.St(e, s))
                    }
                    ),
                    s2.waitFor(n)
                }
                removeOverlaysForBatchId(e, t, r) {
                    let n = new Set;
                    t.forEach(e => n.add(Q(e.getCollectionPath())));
                    let i = [];
                    return n.forEach(t => {
                        let n = IDBKeyRange.bound([this.userId, t, r], [this.userId, t, r + 1], !1, !0);
                        i.push($(e, a$).X(aH, n))
                    }
                    ),
                    s2.waitFor(i)
                }
                getOverlaysForCollection(e, t, r) {
                    let n = e1()
                      , i = Q(t)
                      , s = IDBKeyRange.bound([this.userId, i, r], [this.userId, i, Number.POSITIVE_INFINITY], !0);
                    return $(e, a$).J(aH, s).next(e => {
                        for (let t of e) {
                            let e = t$(this.serializer, t);
                            n.set(e.getKey(), e)
                        }
                        return n
                    }
                    )
                }
                getOverlaysForCollectionGroup(e, t, r, n) {
                    let i, s = e1(), a = IDBKeyRange.bound([this.userId, t, r], [this.userId, t, Number.POSITIVE_INFINITY], !0);
                    return $(e, a$).te({
                        index: aJ,
                        range: a
                    }, (e, t, r) => {
                        let a = t$(this.serializer, t);
                        s.size() < n || a.largestBatchId === i ? (s.set(a.getKey(), a),
                        i = a.largestBatchId) : r.done()
                    }
                    ).next( () => s)
                }
                St(e, t) {
                    return $(e, a$).put(function(e, t, r) {
                        let[n,i,s] = tG(t, r.mutation.key);
                        return {
                            userId: t,
                            collectionPath: i,
                            documentId: s,
                            collectionGroup: r.mutation.key.getCollectionGroup(),
                            largestBatchId: r.largestBatchId,
                            overlayMutation: tD(e.wt, r.mutation)
                        }
                    }(this.serializer, this.userId, t))
                }
            }
            class lf {
                Dt(e) {
                    return $(e, aX)
                }
                getSessionToken(e) {
                    return this.Dt(e).get("sessionToken").next(e => {
                        let t = null == e ? void 0 : e.value;
                        return t ? or.fromUint8Array(t) : or.EMPTY_BYTE_STRING
                    }
                    )
                }
                setSessionToken(e, t) {
                    return this.Dt(e).put({
                        name: "sessionToken",
                        value: t.toUint8Array()
                    })
                }
            }
            class lp {
                constructor() {}
                vt(e, t) {
                    this.Ct(e, t),
                    t.Ft()
                }
                Ct(e, t) {
                    if ("nullValue"in e)
                        this.Mt(t, 5);
                    else if ("booleanValue"in e)
                        this.Mt(t, 10),
                        t.xt(+!!e.booleanValue);
                    else if ("integerValue"in e)
                        this.Mt(t, 15),
                        t.xt(ee(e.integerValue));
                    else if ("doubleValue"in e) {
                        let r = ee(e.doubleValue);
                        isNaN(r) ? this.Mt(t, 13) : (this.Mt(t, 15),
                        j(r) ? t.xt(0) : t.xt(r))
                    } else if ("timestampValue"in e) {
                        let r = e.timestampValue;
                        this.Mt(t, 20),
                        "string" == typeof r && (r = Z(r)),
                        t.Ot(`${r.seconds || ""}`),
                        t.xt(r.nanos || 0)
                    } else if ("stringValue"in e)
                        this.Nt(e.stringValue, t),
                        this.Bt(t);
                    else if ("bytesValue"in e)
                        this.Mt(t, 30),
                        t.Lt(et(e.bytesValue)),
                        this.Bt(t);
                    else if ("referenceValue"in e)
                        this.kt(e.referenceValue, t);
                    else if ("geoPointValue"in e) {
                        let r = e.geoPointValue;
                        this.Mt(t, 45),
                        t.xt(r.latitude || 0),
                        t.xt(r.longitude || 0)
                    } else
                        "mapValue"in e ? eb(e) ? this.Mt(t, Number.MAX_SAFE_INTEGER) : ev(e) ? this.qt(e.mapValue, t) : (this.Qt(e.mapValue, t),
                        this.Bt(t)) : "arrayValue"in e ? (this.$t(e.arrayValue, t),
                        this.Bt(t)) : E(19022, {
                            Ut: e
                        })
                }
                Nt(e, t) {
                    this.Mt(t, 25),
                    this.Kt(e, t)
                }
                Kt(e, t) {
                    t.Ot(e)
                }
                Qt(e, t) {
                    let r = e.fields || {};
                    for (let e of (this.Mt(t, 55),
                    Object.keys(r)))
                        this.Nt(e, t),
                        this.Ct(r[e], t)
                }
                qt(e, t) {
                    var r, n;
                    let i = e.fields || {};
                    this.Mt(t, 53);
                    let s = (null == (n = null == (r = i[og].arrayValue) ? void 0 : r.values) ? void 0 : n.length) || 0;
                    this.Mt(t, 15),
                    t.xt(ee(s)),
                    this.Nt(og, t),
                    this.Ct(i[og], t)
                }
                $t(e, t) {
                    let r = e.values || [];
                    for (let e of (this.Mt(t, 50),
                    r))
                        this.Ct(e, t)
                }
                kt(e, t) {
                    this.Mt(t, 37),
                    sW.fromName(e).path.forEach(e => {
                        this.Mt(t, 60),
                        this.Kt(e, t)
                    }
                    )
                }
                Mt(e, t) {
                    e.xt(t)
                }
                Bt(e) {
                    e.xt(2)
                }
            }
            function tW(e) {
                return Math.ceil((64 - function(e) {
                    let t = 0;
                    for (let r = 0; r < 8; ++r) {
                        let n = function(e) {
                            if (0 === e)
                                return 8;
                            let t = 0;
                            return e >> 4 || (t += 4,
                            e <<= 4),
                            e >> 6 || (t += 2,
                            e <<= 2),
                            e >> 7 || (t += 1),
                            t
                        }(255 & e[r]);
                        if (t += n,
                        8 !== n)
                            break
                    }
                    return t
                }(e)) / 8)
            }
            lp.Wt = new lp;
            class lg {
                constructor() {
                    this.buffer = new Uint8Array(1024),
                    this.position = 0
                }
                Gt(e) {
                    let t = e[Symbol.iterator]()
                      , r = t.next();
                    for (; !r.done; )
                        this.zt(r.value),
                        r = t.next();
                    this.jt()
                }
                Ht(e) {
                    let t = e[Symbol.iterator]()
                      , r = t.next();
                    for (; !r.done; )
                        this.Jt(r.value),
                        r = t.next();
                    this.Yt()
                }
                Zt(e) {
                    for (let t of e) {
                        let e = t.charCodeAt(0);
                        if (e < 128)
                            this.zt(e);
                        else if (e < 2048)
                            this.zt(960 | e >>> 6),
                            this.zt(128 | 63 & e);
                        else if (t < "\ud800" || "\udbff" < t)
                            this.zt(480 | e >>> 12),
                            this.zt(128 | 63 & e >>> 6),
                            this.zt(128 | 63 & e);
                        else {
                            let e = t.codePointAt(0);
                            this.zt(240 | e >>> 18),
                            this.zt(128 | 63 & e >>> 12),
                            this.zt(128 | 63 & e >>> 6),
                            this.zt(128 | 63 & e)
                        }
                    }
                    this.jt()
                }
                Xt(e) {
                    for (let t of e) {
                        let e = t.charCodeAt(0);
                        if (e < 128)
                            this.Jt(e);
                        else if (e < 2048)
                            this.Jt(960 | e >>> 6),
                            this.Jt(128 | 63 & e);
                        else if (t < "\ud800" || "\udbff" < t)
                            this.Jt(480 | e >>> 12),
                            this.Jt(128 | 63 & e >>> 6),
                            this.Jt(128 | 63 & e);
                        else {
                            let e = t.codePointAt(0);
                            this.Jt(240 | e >>> 18),
                            this.Jt(128 | 63 & e >>> 12),
                            this.Jt(128 | 63 & e >>> 6),
                            this.Jt(128 | 63 & e)
                        }
                    }
                    this.Yt()
                }
                en(e) {
                    let t = this.tn(e)
                      , r = tW(t);
                    this.nn(1 + r),
                    this.buffer[this.position++] = 255 & r;
                    for (let e = t.length - r; e < t.length; ++e)
                        this.buffer[this.position++] = 255 & t[e]
                }
                rn(e) {
                    let t = this.tn(e)
                      , r = tW(t);
                    this.nn(1 + r),
                    this.buffer[this.position++] = ~(255 & r);
                    for (let e = t.length - r; e < t.length; ++e)
                        this.buffer[this.position++] = ~(255 & t[e])
                }
                sn() {
                    this._n(255),
                    this._n(255)
                }
                an() {
                    this.un(255),
                    this.un(255)
                }
                reset() {
                    this.position = 0
                }
                seed(e) {
                    this.nn(e.length),
                    this.buffer.set(e, this.position),
                    this.position += e.length
                }
                cn() {
                    return this.buffer.slice(0, this.position)
                }
                tn(e) {
                    let t = function(e) {
                        let t = new DataView(new ArrayBuffer(8));
                        return t.setFloat64(0, e, !1),
                        new Uint8Array(t.buffer)
                    }(e)
                      , r = !!(128 & t[0]);
                    t[0] ^= r ? 255 : 128;
                    for (let e = 1; e < t.length; ++e)
                        t[e] ^= 255 * !!r;
                    return t
                }
                zt(e) {
                    let t = 255 & e;
                    0 === t ? (this._n(0),
                    this._n(255)) : 255 === t ? (this._n(255),
                    this._n(0)) : this._n(t)
                }
                Jt(e) {
                    let t = 255 & e;
                    0 === t ? (this.un(0),
                    this.un(255)) : 255 === t ? (this.un(255),
                    this.un(0)) : this.un(e)
                }
                jt() {
                    this._n(0),
                    this._n(1)
                }
                Yt() {
                    this.un(0),
                    this.un(1)
                }
                _n(e) {
                    this.nn(1),
                    this.buffer[this.position++] = e
                }
                un(e) {
                    this.nn(1),
                    this.buffer[this.position++] = ~e
                }
                nn(e) {
                    let t = e + this.position;
                    if (t <= this.buffer.length)
                        return;
                    let r = 2 * this.buffer.length;
                    r < t && (r = t);
                    let n = new Uint8Array(r);
                    n.set(this.buffer),
                    this.buffer = n
                }
            }
            class lm {
                constructor(e) {
                    this.ln = e
                }
                Lt(e) {
                    this.ln.Gt(e)
                }
                Ot(e) {
                    this.ln.Zt(e)
                }
                xt(e) {
                    this.ln.en(e)
                }
                Ft() {
                    this.ln.sn()
                }
            }
            class ly {
                constructor(e) {
                    this.ln = e
                }
                Lt(e) {
                    this.ln.Ht(e)
                }
                Ot(e) {
                    this.ln.Xt(e)
                }
                xt(e) {
                    this.ln.rn(e)
                }
                Ft() {
                    this.ln.an()
                }
            }
            class lv {
                constructor() {
                    this.ln = new lg,
                    this.hn = new lm(this.ln),
                    this.Pn = new ly(this.ln)
                }
                seed(e) {
                    this.ln.seed(e)
                }
                Tn(e) {
                    return 0 === e ? this.hn : this.Pn
                }
                cn() {
                    return this.ln.cn()
                }
                reset() {
                    this.ln.reset()
                }
            }
            class lw {
                constructor(e, t, r, n) {
                    this.indexId = e,
                    this.documentKey = t,
                    this.arrayValue = r,
                    this.directionalValue = n
                }
                In() {
                    let e = this.directionalValue.length
                      , t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e
                      , r = new Uint8Array(t);
                    return r.set(this.directionalValue, 0),
                    t !== e ? r.set([0], this.directionalValue.length) : ++r[r.length - 1],
                    new lw(this.indexId,this.documentKey,this.arrayValue,r)
                }
            }
            function tJ(e, t) {
                let r = e.indexId - t.indexId;
                return 0 !== r || 0 !== (r = tY(e.arrayValue, t.arrayValue)) || 0 !== (r = tY(e.directionalValue, t.directionalValue)) ? r : sW.comparator(e.documentKey, t.documentKey)
            }
            function tY(e, t) {
                for (let r = 0; r < e.length && r < t.length; ++r) {
                    let n = e[r] - t[r];
                    if (0 !== n)
                        return n
                }
                return e.length - t.length
            }
            class lb {
                constructor(e) {
                    for (let t of (this.En = new a7( (e, t) => sH.comparator(e.field, t.field)),
                    this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment(),
                    this.dn = e.orderBy,
                    this.An = [],
                    e.filters))
                        t.isInequality() ? this.En = this.En.add(t) : this.An.push(t)
                }
                get Rn() {
                    return this.En.size > 1
                }
                Vn(e) {
                    if (_(e.collectionGroup === this.collectionId, 49279),
                    this.Rn)
                        return !1;
                    let t = k(e);
                    if (void 0 !== t && !this.mn(t))
                        return !1;
                    let r = N(e)
                      , n = new Set
                      , i = 0
                      , s = 0;
                    for (; i < r.length && this.mn(r[i]); ++i)
                        n = n.add(r[i].fieldPath.canonicalString());
                    if (i === r.length)
                        return !0;
                    if (this.En.size > 0) {
                        let e = this.En.getIterator().getNext();
                        if (!n.has(e.field.canonicalString())) {
                            let t = r[i];
                            if (!this.fn(e, t) || !this.gn(this.dn[s++], t))
                                return !1
                        }
                        ++i
                    }
                    for (; i < r.length; ++i) {
                        let e = r[i];
                        if (s >= this.dn.length || !this.gn(this.dn[s++], e))
                            return !1
                    }
                    return !0
                }
                pn() {
                    if (this.Rn)
                        return null;
                    let e = new a7(sH.comparator)
                      , t = [];
                    for (let r of this.An)
                        if (!r.field.isKeyField())
                            if ("array-contains" === r.op || "array-contains-any" === r.op)
                                t.push(new sY(r.field,2));
                            else {
                                if (e.has(r.field))
                                    continue;
                                e = e.add(r.field),
                                t.push(new sY(r.field,0))
                            }
                    for (let r of this.dn)
                        r.field.isKeyField() || e.has(r.field) || (e = e.add(r.field),
                        t.push(new sY(r.field,+("asc" !== r.dir))));
                    return new sJ(sJ.UNKNOWN_ID,this.collectionId,t,sX.empty())
                }
                mn(e) {
                    for (let t of this.An)
                        if (this.fn(t, e))
                            return !0;
                    return !1
                }
                fn(e, t) {
                    if (void 0 === e || !e.field.isEqual(t.fieldPath))
                        return !1;
                    let r = "array-contains" === e.op || "array-contains-any" === e.op;
                    return 2 === t.kind === r
                }
                gn(e, t) {
                    return !!e.field.isEqual(t.fieldPath) && (0 === t.kind && "asc" === e.dir || 1 === t.kind && "desc" === e.dir)
                }
            }
            function tX(e) {
                return e instanceof o_
            }
            function tZ(e) {
                return e instanceof oT && ex(e)
            }
            function t0(e) {
                return tX(e) || tZ(e) || function(e) {
                    if (e instanceof oT && eC(e)) {
                        for (let t of e.getFilters())
                            if (!tX(t) && !tZ(t))
                                return !1;
                        return !0
                    }
                    return !1
                }(e)
            }
            function t1(e, t) {
                return _(e instanceof o_ || e instanceof oT, 38388),
                _(t instanceof o_ || t instanceof oT, 25473),
                t6(e instanceof o_ ? t instanceof o_ ? oT.create([e, t], "and") : t2(e, t) : t instanceof o_ ? t2(t, e) : function(e, t) {
                    if (_(e.filters.length > 0 && t.filters.length > 0, 48005),
                    eS(e) && eS(t))
                        return eD(e, t.getFilters());
                    let r = eC(e) ? e : t
                      , n = eC(e) ? t : e
                      , i = r.filters.map(e => t1(e, n));
                    return oT.create(i, "or")
                }(e, t))
            }
            function t2(e, t) {
                if (eS(t))
                    return eD(t, e.getFilters());
                {
                    let r = t.filters.map(t => t1(e, t));
                    return oT.create(r, "or")
                }
            }
            function t6(e) {
                if (_(e instanceof o_ || e instanceof oT, 11850),
                e instanceof o_)
                    return e;
                let t = e.getFilters();
                if (1 === t.length)
                    return t6(t[0]);
                if (eA(e))
                    return e;
                let r = t.map(e => t6(e))
                  , n = [];
                return r.forEach(t => {
                    t instanceof o_ ? n.push(t) : t instanceof oT && (t.op === e.op ? n.push(...t.filters) : n.push(t))
                }
                ),
                1 === n.length ? n[0] : oT.create(n, e.op)
            }
            class lE {
                constructor() {
                    this.yn = new lI
                }
                addToCollectionParentIndex(e, t) {
                    return this.yn.add(t),
                    s2.resolve()
                }
                getCollectionParents(e, t) {
                    return s2.resolve(this.yn.getEntries(t))
                }
                addFieldIndex(e, t) {
                    return s2.resolve()
                }
                deleteFieldIndex(e, t) {
                    return s2.resolve()
                }
                deleteAllFieldIndexes(e) {
                    return s2.resolve()
                }
                createTargetIndexes(e, t) {
                    return s2.resolve()
                }
                getDocumentsMatchingTarget(e, t) {
                    return s2.resolve(null)
                }
                getIndexType(e, t) {
                    return s2.resolve(0)
                }
                getFieldIndexes(e, t) {
                    return s2.resolve([])
                }
                getNextCollectionGroupToUpdate(e) {
                    return s2.resolve(null)
                }
                getMinOffset(e, t) {
                    return s2.resolve(sZ.min())
                }
                getMinOffsetFromCollectionGroup(e, t) {
                    return s2.resolve(sZ.min())
                }
                updateCollectionGroup(e, t, r) {
                    return s2.resolve()
                }
                updateIndexEntries(e, t) {
                    return s2.resolve()
                }
            }
            class lI {
                constructor() {
                    this.index = {}
                }
                add(e) {
                    let t = e.lastSegment()
                      , r = e.popLast()
                      , n = this.index[t] || new a7(s$.comparator)
                      , i = !n.has(r);
                    return this.index[t] = n.add(r),
                    i
                }
                has(e) {
                    let t = e.lastSegment()
                      , r = e.popLast()
                      , n = this.index[t];
                    return n && n.has(r)
                }
                getEntries(e) {
                    return (this.index[e] || new a7(s$.comparator)).toArray()
                }
            }
            let l_ = "IndexedDbIndexManager"
              , lT = new Uint8Array(0);
            class lS {
                constructor(e, t) {
                    this.databaseId = t,
                    this.wn = new lI,
                    this.bn = new oM(e => eO(e), (e, t) => eR(e, t)),
                    this.uid = e.uid || ""
                }
                addToCollectionParentIndex(e, t) {
                    if (!this.wn.has(t)) {
                        let r = t.lastSegment()
                          , n = t.popLast();
                        e.addOnCommittedListener( () => {
                            this.wn.add(t)
                        }
                        );
                        let i = {
                            collectionId: r,
                            parent: Q(n)
                        };
                        return $(e, aN).put(i)
                    }
                    return s2.resolve()
                }
                getCollectionParents(e, t) {
                    let r = []
                      , n = IDBKeyRange.bound([t, ""], [t + "\0", ""], !1, !0);
                    return $(e, aN).J(n).next(e => {
                        for (let n of e) {
                            if (n.collectionId !== t)
                                break;
                            r.push(K(n.parent))
                        }
                        return r
                    }
                    )
                }
                addFieldIndex(e, t) {
                    let r = $(e, aL)
                      , n = {
                        indexId: t.indexId,
                        collectionGroup: t.collectionGroup,
                        fields: t.fields.map(e => [e.fieldPath.canonicalString(), e.kind])
                    };
                    delete n.indexId;
                    let i = r.add(n);
                    if (t.indexState) {
                        let r = $(e, aB);
                        return i.next(e => {
                            r.put(tH(e, this.uid, t.indexState.sequenceNumber, t.indexState.offset))
                        }
                        )
                    }
                    return i.next()
                }
                deleteFieldIndex(e, t) {
                    let r = $(e, aL)
                      , n = $(e, aB)
                      , i = $(e, aj);
                    return r.delete(t.indexId).next( () => n.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))).next( () => i.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)))
                }
                deleteAllFieldIndexes(e) {
                    let t = $(e, aL)
                      , r = $(e, aj)
                      , n = $(e, aB);
                    return t.X().next( () => r.X()).next( () => n.X())
                }
                createTargetIndexes(e, t) {
                    return s2.forEach(this.Sn(t), t => this.getIndexType(e, t).next(r => {
                        if (0 === r || 1 === r) {
                            let r = new lb(t).pn();
                            if (null != r)
                                return this.addFieldIndex(e, r)
                        }
                    }
                    ))
                }
                getDocumentsMatchingTarget(e, t) {
                    let r = $(e, aj)
                      , n = !0
                      , i = new Map;
                    return s2.forEach(this.Sn(t), t => this.Dn(e, t).next(e => {
                        n && (n = !!e),
                        i.set(t, e)
                    }
                    )).next( () => {
                        if (n) {
                            let e = e2()
                              , n = [];
                            return s2.forEach(i, (i, s) => {
                                y(l_, `Using index id=${i.indexId}|cg=${i.collectionGroup}|f=${i.fields.map(e => `${e.fieldPath}:${e.kind}`).join(",")} to execute ${eO(t)}`);
                                let a = function(e, t) {
                                    let r = k(t);
                                    if (void 0 === r)
                                        return null;
                                    for (let t of eP(e, r.fieldPath))
                                        switch (t.op) {
                                        case "array-contains-any":
                                            return t.value.arrayValue.values || [];
                                        case "array-contains":
                                            return [t.value]
                                        }
                                    return null
                                }(s, i)
                                  , o = function(e, t) {
                                    let r = new Map;
                                    for (let n of N(t))
                                        for (let t of eP(e, n.fieldPath))
                                            switch (t.op) {
                                            case "==":
                                            case "in":
                                                r.set(n.fieldPath.canonicalString(), t.value);
                                                break;
                                            case "not-in":
                                            case "!=":
                                                return r.set(n.fieldPath.canonicalString(), t.value),
                                                Array.from(r.values())
                                            }
                                    return null
                                }(s, i)
                                  , l = function(e, t) {
                                    let r = []
                                      , n = !0;
                                    for (let i of N(t)) {
                                        let t = 0 === i.kind ? eL(e, i.fieldPath, e.startAt) : eF(e, i.fieldPath, e.startAt);
                                        r.push(t.value),
                                        n && (n = t.inclusive)
                                    }
                                    return new ob(r,n)
                                }(s, i)
                                  , u = function(e, t) {
                                    let r = []
                                      , n = !0;
                                    for (let i of N(t)) {
                                        let t = 0 === i.kind ? eF(e, i.fieldPath, e.endAt) : eL(e, i.fieldPath, e.endAt);
                                        r.push(t.value),
                                        n && (n = t.inclusive)
                                    }
                                    return new ob(r,n)
                                }(s, i)
                                  , h = this.vn(i, s, l)
                                  , c = this.vn(i, s, u)
                                  , d = this.Cn(i, s, o)
                                  , f = this.Fn(i.indexId, a, h, l.inclusive, c, u.inclusive, d);
                                return s2.forEach(f, i => r.Z(i, t.limit).next(t => {
                                    t.forEach(t => {
                                        let r = sW.fromSegments(t.documentKey);
                                        e.has(r) || (e = e.add(r),
                                        n.push(r))
                                    }
                                    )
                                }
                                ))
                            }
                            ).next( () => n)
                        }
                        return s2.resolve(null)
                    }
                    )
                }
                Sn(e) {
                    let t = this.bn.get(e);
                    return t || (t = 0 === e.filters.length ? [e] : (function(e) {
                        if (0 === e.getFilters().length)
                            return [];
                        let t = function e(t) {
                            if (_(t instanceof o_ || t instanceof oT, 34018),
                            t instanceof o_)
                                return t;
                            if (1 === t.filters.length)
                                return e(t.filters[0]);
                            let r = t.filters.map(t => e(t))
                              , n = oT.create(r, t.op);
                            return t0(n = t6(n)) ? n : (_(n instanceof oT, 64498),
                            _(eS(n), 40251),
                            _(n.filters.length > 1, 57927),
                            n.filters.reduce( (e, t) => t1(e, t)))
                        }(function e(t) {
                            var r, n;
                            if (_(t instanceof o_ || t instanceof oT, 20012),
                            t instanceof o_) {
                                if (t instanceof oD) {
                                    let e = (null == (n = null == (r = t.value.arrayValue) ? void 0 : r.values) ? void 0 : n.map(e => o_.create(t.field, "==", e))) || [];
                                    return oT.create(e, "or")
                                }
                                return t
                            }
                            let i = t.filters.map(t => e(t));
                            return oT.create(i, t.op)
                        }(e));
                        return _(t0(t), 7391),
                        tX(t) || tZ(t) ? [t] : t.getFilters()
                    }
                    )(oT.create(e.filters, "and")).map(t => eN(e.path, e.collectionGroup, e.orderBy, t.getFilters(), e.limit, e.startAt, e.endAt)),
                    this.bn.set(e, t)),
                    t
                }
                Fn(e, t, r, n, i, s, a) {
                    let o = (null != t ? t.length : 1) * Math.max(r.length, i.length)
                      , l = o / (null != t ? t.length : 1)
                      , u = [];
                    for (let h = 0; h < o; ++h) {
                        let o = t ? this.Mn(t[h / l]) : lT
                          , c = this.xn(e, o, r[h % l], n)
                          , d = this.On(e, o, i[h % l], s)
                          , f = a.map(t => this.xn(e, o, t, !0));
                        u.push(...this.createRange(c, d, f))
                    }
                    return u
                }
                xn(e, t, r, n) {
                    let i = new lw(e,sW.empty(),t,r);
                    return n ? i : i.In()
                }
                On(e, t, r, n) {
                    let i = new lw(e,sW.empty(),t,r);
                    return n ? i.In() : i
                }
                Dn(e, t) {
                    let r = new lb(t)
                      , n = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment();
                    return this.getFieldIndexes(e, n).next(e => {
                        let t = null;
                        for (let n of e)
                            r.Vn(n) && (!t || n.fields.length > t.fields.length) && (t = n);
                        return t
                    }
                    )
                }
                getIndexType(e, t) {
                    let r = 2
                      , n = this.Sn(t);
                    return s2.forEach(n, t => this.Dn(e, t).next(e => {
                        e ? 0 !== r && e.fields.length < function(e) {
                            let t = new a7(sH.comparator)
                              , r = !1;
                            for (let n of e.filters)
                                for (let e of n.getFlattenedFilters())
                                    e.field.isKeyField() || ("array-contains" === e.op || "array-contains-any" === e.op ? r = !0 : t = t.add(e.field));
                            for (let r of e.orderBy)
                                r.field.isKeyField() || (t = t.add(r.field));
                            return t.size + +!!r
                        }(t) && (r = 1) : r = 0
                    }
                    )).next( () => null !== t.limit && n.length > 1 && 2 === r ? 1 : r)
                }
                Nn(e, t) {
                    let r = new lv;
                    for (let n of N(e)) {
                        let e = t.data.field(n.fieldPath);
                        if (null == e)
                            return null;
                        let i = r.Tn(n.kind);
                        lp.Wt.vt(e, i)
                    }
                    return r.cn()
                }
                Mn(e) {
                    let t = new lv;
                    return lp.Wt.vt(e, t.Tn(0)),
                    t.cn()
                }
                Bn(e, t) {
                    let r = new lv;
                    return lp.Wt.vt(ed(this.databaseId, t), r.Tn(function(e) {
                        let t = N(e);
                        return 0 === t.length ? 0 : t[t.length - 1].kind
                    }(e))),
                    r.cn()
                }
                Cn(e, t, r) {
                    if (null === r)
                        return [];
                    let n = [];
                    n.push(new lv);
                    let i = 0;
                    for (let s of N(e)) {
                        let e = r[i++];
                        for (let r of n)
                            if (this.Ln(t, s.fieldPath) && ep(e))
                                n = this.kn(n, s, e);
                            else {
                                let t = r.Tn(s.kind);
                                lp.Wt.vt(e, t)
                            }
                    }
                    return this.qn(n)
                }
                vn(e, t, r) {
                    return this.Cn(e, t, r.position)
                }
                qn(e) {
                    let t = [];
                    for (let r = 0; r < e.length; ++r)
                        t[r] = e[r].cn();
                    return t
                }
                kn(e, t, r) {
                    let n = [...e]
                      , i = [];
                    for (let e of r.arrayValue.values || [])
                        for (let r of n) {
                            let n = new lv;
                            n.seed(r.cn()),
                            lp.Wt.vt(e, n.Tn(t.kind)),
                            i.push(n)
                        }
                    return i
                }
                Ln(e, t) {
                    return !!e.filters.find(e => e instanceof o_ && e.field.isEqual(t) && ("in" === e.op || "not-in" === e.op))
                }
                getFieldIndexes(e, t) {
                    let r = $(e, aL)
                      , n = $(e, aB);
                    return (t ? r.J(aF, IDBKeyRange.bound(t, t)) : r.J()).next(e => {
                        let t = [];
                        return s2.forEach(e, e => n.get([e.indexId, this.uid]).next(r => {
                            t.push(function(e, t) {
                                let r = t ? new sX(t.sequenceNumber,new sZ(tq(t.readTime),new sW(K(t.documentKey)),t.largestBatchId)) : sX.empty()
                                  , n = e.fields.map( ([e,t]) => new sY(sH.fromServerFormat(e),t));
                                return new sJ(e.indexId,e.collectionGroup,n,r)
                            }(e, r))
                        }
                        )).next( () => t)
                    }
                    )
                }
                getNextCollectionGroupToUpdate(e) {
                    return this.getFieldIndexes(e).next(e => 0 === e.length ? null : (e.sort( (e, t) => {
                        let r = e.indexState.sequenceNumber - t.indexState.sequenceNumber;
                        return 0 !== r ? r : C(e.collectionGroup, t.collectionGroup)
                    }
                    ),
                    e[0].collectionGroup))
                }
                updateCollectionGroup(e, t, r) {
                    let n = $(e, aL)
                      , i = $(e, aB);
                    return this.Qn(e).next(e => n.J(aF, IDBKeyRange.bound(t, t)).next(t => s2.forEach(t, t => i.put(tH(t.indexId, this.uid, e, r)))))
                }
                updateIndexEntries(e, t) {
                    let r = new Map;
                    return s2.forEach(t, (t, n) => {
                        let i = r.get(t.collectionGroup);
                        return (i ? s2.resolve(i) : this.getFieldIndexes(e, t.collectionGroup)).next(i => (r.set(t.collectionGroup, i),
                        s2.forEach(i, r => this.$n(e, t, r).next(t => {
                            let i = this.Un(n, r);
                            return t.isEqual(i) ? s2.resolve() : this.Kn(e, n, r, t, i)
                        }
                        ))))
                    }
                    )
                }
                Wn(e, t, r, n) {
                    return $(e, aj).put({
                        indexId: n.indexId,
                        uid: this.uid,
                        arrayValue: n.arrayValue,
                        directionalValue: n.directionalValue,
                        orderedDocumentKey: this.Bn(r, t.key),
                        documentKey: t.key.path.toArray()
                    })
                }
                Gn(e, t, r, n) {
                    return $(e, aj).delete([n.indexId, this.uid, n.arrayValue, n.directionalValue, this.Bn(r, t.key), t.key.path.toArray()])
                }
                $n(e, t, r) {
                    let n = $(e, aj)
                      , i = new a7(tJ);
                    return n.te({
                        index: aQ,
                        range: IDBKeyRange.only([r.indexId, this.uid, this.Bn(r, t)])
                    }, (e, n) => {
                        i = i.add(new lw(r.indexId,t,n.arrayValue,n.directionalValue))
                    }
                    ).next( () => i)
                }
                Un(e, t) {
                    let r = new a7(tJ)
                      , n = this.Nn(t, e);
                    if (null == n)
                        return r;
                    let i = k(t);
                    if (null != i) {
                        let s = e.data.field(i.fieldPath);
                        if (ep(s))
                            for (let i of s.arrayValue.values || [])
                                r = r.add(new lw(t.indexId,e.key,this.Mn(i),n))
                    } else
                        r = r.add(new lw(t.indexId,e.key,lT,n));
                    return r
                }
                Kn(e, t, r, n, i) {
                    y(l_, "Updating index entries for document '%s'", t.key);
                    let s = [];
                    return function(e, t, r, n, i) {
                        let s = e.getIterator()
                          , a = t.getIterator()
                          , o = Y(s)
                          , l = Y(a);
                        for (; o || l; ) {
                            let e = !1
                              , t = !1;
                            if (o && l) {
                                let n = r(o, l);
                                n < 0 ? t = !0 : n > 0 && (e = !0)
                            } else
                                null != o ? t = !0 : e = !0;
                            e ? (n(l),
                            l = Y(a)) : t ? (i(o),
                            o = Y(s)) : (o = Y(s),
                            l = Y(a))
                        }
                    }(n, i, tJ, n => {
                        s.push(this.Wn(e, t, r, n))
                    }
                    , n => {
                        s.push(this.Gn(e, t, r, n))
                    }
                    ),
                    s2.waitFor(s)
                }
                Qn(e) {
                    let t = 1;
                    return $(e, aB).te({
                        index: aU,
                        reverse: !0,
                        range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
                    }, (e, r, n) => {
                        n.done(),
                        t = r.sequenceNumber + 1
                    }
                    ).next( () => t)
                }
                createRange(e, t, r) {
                    r = r.sort( (e, t) => tJ(e, t)).filter( (e, t, r) => !t || 0 !== tJ(e, r[t - 1]));
                    let n = [];
                    for (let i of (n.push(e),
                    r)) {
                        let r = tJ(i, e)
                          , s = tJ(i, t);
                        if (0 === r)
                            n[0] = e.In();
                        else if (r > 0 && s < 0)
                            n.push(i),
                            n.push(i.In());
                        else if (s > 0)
                            break
                    }
                    n.push(t);
                    let i = [];
                    for (let e = 0; e < n.length; e += 2) {
                        if (this.zn(n[e], n[e + 1]))
                            return [];
                        let t = [n[e].indexId, this.uid, n[e].arrayValue, n[e].directionalValue, lT, []]
                          , r = [n[e + 1].indexId, this.uid, n[e + 1].arrayValue, n[e + 1].directionalValue, lT, []];
                        i.push(IDBKeyRange.bound(t, r))
                    }
                    return i
                }
                zn(e, t) {
                    return tJ(e, t) > 0
                }
                getMinOffsetFromCollectionGroup(e, t) {
                    return this.getFieldIndexes(e, t).next(t3)
                }
                getMinOffset(e, t) {
                    return s2.mapArray(this.Sn(t), t => this.Dn(e, t).next(e => e || E(44426))).next(t3)
                }
            }
            function t3(e) {
                _(0 !== e.length, 28825);
                let t = e[0].indexState.offset
                  , r = t.largestBatchId;
                for (let n = 1; n < e.length; n++) {
                    let i = e[n].indexState.offset;
                    0 > P(i, t) && (t = i),
                    r < i.largestBatchId && (r = i.largestBatchId)
                }
                return new sZ(t.readTime,t.documentKey,r)
            }
            let lC = {
                didRun: !1,
                sequenceNumbersCollected: 0,
                targetsRemoved: 0,
                documentsRemoved: 0
            };
            class lx {
                static withCacheSize(e) {
                    return new lx(e,lx.DEFAULT_COLLECTION_PERCENTILE,lx.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)
                }
                constructor(e, t, r) {
                    this.cacheSizeCollectionThreshold = e,
                    this.percentileToCollect = t,
                    this.maximumSequenceNumbersToCollect = r
                }
            }
            function t5(e, t, r) {
                let n = e.store(al)
                  , i = e.store(af)
                  , s = []
                  , a = IDBKeyRange.only(r.batchId)
                  , o = 0
                  , l = n.te({
                    range: a
                }, (e, t, r) => (o++,
                r.delete()));
                s.push(l.next( () => {
                    _(1 === o, 47070, {
                        batchId: r.batchId
                    })
                }
                ));
                let u = [];
                for (let e of r.mutations) {
                    var h, c;
                    let n = (h = e.key.path,
                    c = r.batchId,
                    [t, Q(h), c]);
                    s.push(i.delete(n)),
                    u.push(e.key)
                }
                return s2.waitFor(s).next( () => u)
            }
            function t4(e) {
                let t;
                if (!e)
                    return 0;
                if (e.document)
                    t = e.document;
                else if (e.unknownDocument)
                    t = e.unknownDocument;
                else {
                    if (!e.noDocument)
                        throw E(14731);
                    t = e.noDocument
                }
                return JSON.stringify(t).length
            }
            lx.DEFAULT_COLLECTION_PERCENTILE = 10,
            lx.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3,
            lx.DEFAULT = new lx(0x2800000,lx.DEFAULT_COLLECTION_PERCENTILE,lx.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),
            lx.DISABLED = new lx(-1,0,0);
            class lA {
                constructor(e, t, r, n) {
                    this.userId = e,
                    this.serializer = t,
                    this.indexManager = r,
                    this.referenceDelegate = n,
                    this.jn = {}
                }
                static bt(e, t, r, n) {
                    return _("" !== e.uid, 64387),
                    new lA(e.isAuthenticated() ? e.uid : "",t,r,n)
                }
                checkEmpty(e) {
                    let t = !0
                      , r = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
                    return t7(e).te({
                        index: ah,
                        range: r
                    }, (e, r, n) => {
                        t = !1,
                        n.done()
                    }
                    ).next( () => t)
                }
                addMutationBatch(e, t, r, n) {
                    let i = $(e, af)
                      , s = t7(e);
                    return s.add({}).next(a => {
                        _("number" == typeof a, 49019);
                        let o = new oZ(a,t,r,n)
                          , l = function(e, t, r) {
                            let n = r.baseMutations.map(t => tD(e.wt, t))
                              , i = r.mutations.map(t => tD(e.wt, t));
                            return {
                                userId: t,
                                batchId: r.batchId,
                                localWriteTimeMs: r.localWriteTime.toMillis(),
                                baseMutations: n,
                                mutations: i
                            }
                        }(this.serializer, this.userId, o)
                          , u = []
                          , h = new a7( (e, t) => C(e.canonicalString(), t.canonicalString()));
                        for (let e of n) {
                            var c, d;
                            let t = (c = this.userId,
                            d = e.key.path,
                            [c, Q(d), a]);
                            h = h.add(e.key.path.popLast()),
                            u.push(s.put(l)),
                            u.push(i.put(t, ad))
                        }
                        return h.forEach(t => {
                            u.push(this.indexManager.addToCollectionParentIndex(e, t))
                        }
                        ),
                        e.addOnCommittedListener( () => {
                            this.jn[a] = o.keys()
                        }
                        ),
                        s2.waitFor(u).next( () => o)
                    }
                    )
                }
                lookupMutationBatch(e, t) {
                    return t7(e).get(t).next(e => e ? (_(e.userId === this.userId, 48, "Unexpected user for mutation batch", {
                        userId: e.userId,
                        batchId: t
                    }),
                    tj(this.serializer, e)) : null)
                }
                Hn(e, t) {
                    return this.jn[t] ? s2.resolve(this.jn[t]) : this.lookupMutationBatch(e, t).next(e => {
                        if (e) {
                            let r = e.keys();
                            return this.jn[t] = r,
                            r
                        }
                        return null
                    }
                    )
                }
                getNextMutationBatchAfterBatchId(e, t) {
                    let r = t + 1
                      , n = IDBKeyRange.lowerBound([this.userId, r])
                      , i = null;
                    return t7(e).te({
                        index: ah,
                        range: n
                    }, (e, t, n) => {
                        t.userId === this.userId && (_(t.batchId >= r, 47524, {
                            Jn: r
                        }),
                        i = tj(this.serializer, t)),
                        n.done()
                    }
                    ).next( () => i)
                }
                getHighestUnacknowledgedBatchId(e) {
                    let t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY])
                      , r = -1;
                    return t7(e).te({
                        index: ah,
                        range: t,
                        reverse: !0
                    }, (e, t, n) => {
                        r = t.batchId,
                        n.done()
                    }
                    ).next( () => r)
                }
                getAllMutationBatches(e) {
                    let t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
                    return t7(e).J(ah, t).next(e => e.map(e => tj(this.serializer, e)))
                }
                getAllMutationBatchesAffectingDocumentKey(e, t) {
                    let r = [this.userId, Q(t.path)]
                      , n = IDBKeyRange.lowerBound(r)
                      , i = [];
                    return $(e, af).te({
                        range: n
                    }, (r, n, s) => {
                        let[a,o,l] = r
                          , u = K(o);
                        if (a === this.userId && t.path.isEqual(u))
                            return t7(e).get(l).next(e => {
                                if (!e)
                                    throw E(61480, {
                                        Yn: r,
                                        batchId: l
                                    });
                                _(e.userId === this.userId, 10503, "Unexpected user for mutation batch", {
                                    userId: e.userId,
                                    batchId: l
                                }),
                                i.push(tj(this.serializer, e))
                            }
                            );
                        s.done()
                    }
                    ).next( () => i)
                }
                getAllMutationBatchesAffectingDocumentKeys(e, t) {
                    let r = new a7(C)
                      , n = [];
                    return t.forEach(t => {
                        let i = [this.userId, Q(t.path)]
                          , s = IDBKeyRange.lowerBound(i)
                          , a = $(e, af).te({
                            range: s
                        }, (e, n, i) => {
                            let[s,a,o] = e
                              , l = K(a);
                            s === this.userId && t.path.isEqual(l) ? r = r.add(o) : i.done()
                        }
                        );
                        n.push(a)
                    }
                    ),
                    s2.waitFor(n).next( () => this.Zn(e, r))
                }
                getAllMutationBatchesAffectingQuery(e, t) {
                    let r = t.path
                      , n = r.length + 1
                      , i = [this.userId, Q(r)]
                      , s = IDBKeyRange.lowerBound(i)
                      , a = new a7(C);
                    return $(e, af).te({
                        range: s
                    }, (e, t, i) => {
                        let[s,o,l] = e
                          , u = K(o);
                        s === this.userId && r.isPrefixOf(u) ? u.length === n && (a = a.add(l)) : i.done()
                    }
                    ).next( () => this.Zn(e, a))
                }
                Zn(e, t) {
                    let r = []
                      , n = [];
                    return t.forEach(t => {
                        n.push(t7(e).get(t).next(e => {
                            if (null === e)
                                throw E(35274, {
                                    batchId: t
                                });
                            _(e.userId === this.userId, 9748, "Unexpected user for mutation batch", {
                                userId: e.userId,
                                batchId: t
                            }),
                            r.push(tj(this.serializer, e))
                        }
                        ))
                    }
                    ),
                    s2.waitFor(n).next( () => r)
                }
                removeMutationBatch(e, t) {
                    return t5(e.he, this.userId, t).next(r => (e.addOnCommittedListener( () => {
                        this.Xn(t.batchId)
                    }
                    ),
                    s2.forEach(r, t => this.referenceDelegate.markPotentiallyOrphaned(e, t))))
                }
                Xn(e) {
                    delete this.jn[e]
                }
                performConsistencyCheck(e) {
                    return this.checkEmpty(e).next(t => {
                        if (!t)
                            return s2.resolve();
                        let r = IDBKeyRange.lowerBound([this.userId])
                          , n = [];
                        return $(e, af).te({
                            range: r
                        }, (e, t, r) => {
                            if (e[0] === this.userId) {
                                let t = K(e[1]);
                                n.push(t)
                            } else
                                r.done()
                        }
                        ).next( () => {
                            _(0 === n.length, 56720, {
                                er: n.map(e => e.canonicalString())
                            })
                        }
                        )
                    }
                    )
                }
                containsKey(e, t) {
                    return t8(e, this.userId, t)
                }
                tr(e) {
                    return $(e, ao).get(this.userId).next(e => e || {
                        userId: this.userId,
                        lastAcknowledgedBatchId: -1,
                        lastStreamToken: ""
                    })
                }
            }
            function t8(e, t, r) {
                let n = [t, Q(r.path)]
                  , i = n[1]
                  , s = IDBKeyRange.lowerBound(n)
                  , a = !1;
                return $(e, af).te({
                    range: s,
                    ee: !0
                }, (e, r, n) => {
                    let[s,o,l] = e;
                    s === t && o === i && (a = !0),
                    n.done()
                }
                ).next( () => a)
            }
            function t7(e) {
                return $(e, al)
            }
            class lD {
                constructor(e) {
                    this.nr = e
                }
                next() {
                    return this.nr += 2,
                    this.nr
                }
                static rr() {
                    return new lD(0)
                }
                static ir() {
                    return new lD(-1)
                }
            }
            class lk {
                constructor(e, t) {
                    this.referenceDelegate = e,
                    this.serializer = t
                }
                allocateTargetId(e) {
                    return this.sr(e).next(t => {
                        let r = new lD(t.highestTargetId);
                        return t.highestTargetId = r.next(),
                        this._r(e, t).next( () => t.highestTargetId)
                    }
                    )
                }
                getLastRemoteSnapshotVersion(e) {
                    return this.sr(e).next(e => sz.fromTimestamp(new sj(e.lastRemoteSnapshotVersion.seconds,e.lastRemoteSnapshotVersion.nanoseconds)))
                }
                getHighestSequenceNumber(e) {
                    return this.sr(e).next(e => e.highestListenSequenceNumber)
                }
                setTargetsMetadata(e, t, r) {
                    return this.sr(e).next(n => (n.highestListenSequenceNumber = t,
                    r && (n.lastRemoteSnapshotVersion = r.toTimestamp()),
                    t > n.highestListenSequenceNumber && (n.highestListenSequenceNumber = t),
                    this._r(e, n)))
                }
                addTargetData(e, t) {
                    return this.ar(e, t).next( () => this.sr(e).next(r => (r.targetCount += 1,
                    this.ur(t, r),
                    this._r(e, r))))
                }
                updateTargetData(e, t) {
                    return this.ar(e, t)
                }
                removeTargetData(e, t) {
                    return this.removeMatchingKeysForTargetId(e, t.targetId).next( () => $(e, aI).delete(t.targetId)).next( () => this.sr(e)).next(t => (_(t.targetCount > 0, 8065),
                    t.targetCount -= 1,
                    this._r(e, t)))
                }
                removeTargets(e, t, r) {
                    let n = 0
                      , i = [];
                    return $(e, aI).te( (s, a) => {
                        let o = tz(a);
                        o.sequenceNumber <= t && null === r.get(o.targetId) && (n++,
                        i.push(this.removeTargetData(e, o)))
                    }
                    ).next( () => s2.waitFor(i)).next( () => n)
                }
                forEachTarget(e, t) {
                    return $(e, aI).te( (e, r) => {
                        t(tz(r))
                    }
                    )
                }
                sr(e) {
                    return $(e, ak).get(aD).next(e => (_(null !== e, 2888),
                    e))
                }
                _r(e, t) {
                    return $(e, ak).put(aD, t)
                }
                ar(e, t) {
                    return $(e, aI).put(tQ(this.serializer, t))
                }
                ur(e, t) {
                    let r = !1;
                    return e.targetId > t.highestTargetId && (t.highestTargetId = e.targetId,
                    r = !0),
                    e.sequenceNumber > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = e.sequenceNumber,
                    r = !0),
                    r
                }
                getTargetCount(e) {
                    return this.sr(e).next(e => e.targetCount)
                }
                getTargetData(e, t) {
                    let r = eO(t)
                      , n = IDBKeyRange.bound([r, Number.NEGATIVE_INFINITY], [r, Number.POSITIVE_INFINITY])
                      , i = null;
                    return $(e, aI).te({
                        range: n,
                        index: a_
                    }, (e, r, n) => {
                        let s = tz(r);
                        eR(t, s.target) && (i = s,
                        n.done())
                    }
                    ).next( () => i)
                }
                addMatchingKeys(e, t, r) {
                    let n = []
                      , i = t9(e);
                    return t.forEach(t => {
                        let s = Q(t.path);
                        n.push(i.put({
                            targetId: r,
                            path: s
                        })),
                        n.push(this.referenceDelegate.addReference(e, r, t))
                    }
                    ),
                    s2.waitFor(n)
                }
                removeMatchingKeys(e, t, r) {
                    let n = t9(e);
                    return s2.forEach(t, t => {
                        let i = Q(t.path);
                        return s2.waitFor([n.delete([r, i]), this.referenceDelegate.removeReference(e, r, t)])
                    }
                    )
                }
                removeMatchingKeysForTargetId(e, t) {
                    let r = t9(e)
                      , n = IDBKeyRange.bound([t], [t + 1], !1, !0);
                    return r.delete(n)
                }
                getMatchingKeysForTargetId(e, t) {
                    let r = IDBKeyRange.bound([t], [t + 1], !1, !0)
                      , n = t9(e)
                      , i = e2();
                    return n.te({
                        range: r,
                        ee: !0
                    }, (e, t, r) => {
                        let n = new sW(K(e[1]));
                        i = i.add(n)
                    }
                    ).next( () => i)
                }
                containsKey(e, t) {
                    let r = Q(t.path)
                      , n = IDBKeyRange.bound([r], [r + "\0"], !1, !0)
                      , i = 0;
                    return t9(e).te({
                        index: ax,
                        ee: !0,
                        range: n
                    }, ([e,t], r, n) => {
                        0 !== e && (i++,
                        n.done())
                    }
                    ).next( () => i > 0)
                }
                Rt(e, t) {
                    return $(e, aI).get(t).next(e => e ? tz(e) : null)
                }
            }
            function t9(e) {
                return $(e, aS)
            }
            let lN = "LruGarbageCollector";
            function re([e,t], [r,n]) {
                let i = C(e, r);
                return 0 === i ? C(t, n) : i
            }
            class lO {
                constructor(e) {
                    this.cr = e,
                    this.buffer = new a7(re),
                    this.lr = 0
                }
                hr() {
                    return ++this.lr
                }
                Pr(e) {
                    let t = [e, this.hr()];
                    if (this.buffer.size < this.cr)
                        this.buffer = this.buffer.add(t);
                    else {
                        let e = this.buffer.last();
                        0 > re(t, e) && (this.buffer = this.buffer.delete(e).add(t))
                    }
                }
                get maxValue() {
                    return this.buffer.last()[0]
                }
            }
            class lR {
                constructor(e, t, r) {
                    this.garbageCollector = e,
                    this.asyncQueue = t,
                    this.localStore = r,
                    this.Tr = null
                }
                start() {
                    -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Ir(6e4)
                }
                stop() {
                    this.Tr && (this.Tr.cancel(),
                    this.Tr = null)
                }
                get started() {
                    return null !== this.Tr
                }
                Ir(e) {
                    y(lN, `Garbage collection scheduled in ${e}ms`),
                    this.Tr = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
                        this.Tr = null;
                        try {
                            await this.localStore.collectGarbage(this.garbageCollector)
                        } catch (e) {
                            B(e) ? y(lN, "Ignoring IndexedDB error during garbage collection: ", e) : await L(e)
                        }
                        await this.Ir(3e5)
                    }
                    )
                }
            }
            class lM {
                constructor(e, t) {
                    this.Er = e,
                    this.params = t
                }
                calculateTargetCount(e, t) {
                    return this.Er.dr(e).next(e => Math.floor(t / 100 * e))
                }
                nthSequenceNumber(e, t) {
                    if (0 === t)
                        return s2.resolve(an.le);
                    let r = new lO(t);
                    return this.Er.forEachTarget(e, e => r.Pr(e.sequenceNumber)).next( () => this.Er.Ar(e, e => r.Pr(e))).next( () => r.maxValue)
                }
                removeTargets(e, t, r) {
                    return this.Er.removeTargets(e, t, r)
                }
                removeOrphanedDocuments(e, t) {
                    return this.Er.removeOrphanedDocuments(e, t)
                }
                collect(e, t) {
                    return -1 === this.params.cacheSizeCollectionThreshold ? (y("LruGarbageCollector", "Garbage collection skipped; disabled"),
                    s2.resolve(lC)) : this.getCacheSize(e).next(r => r < this.params.cacheSizeCollectionThreshold ? (y("LruGarbageCollector", `Garbage collection skipped; Cache size ${r} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`),
                    lC) : this.Rr(e, t))
                }
                getCacheSize(e) {
                    return this.Er.getCacheSize(e)
                }
                Rr(e, t) {
                    let r, n, i, s, a, o, l, u = Date.now();
                    return this.calculateTargetCount(e, this.params.percentileToCollect).next(t => (t > this.params.maximumSequenceNumbersToCollect ? (y("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t}`),
                    n = this.params.maximumSequenceNumbersToCollect) : n = t,
                    s = Date.now(),
                    this.nthSequenceNumber(e, n))).next(n => (r = n,
                    a = Date.now(),
                    this.removeTargets(e, r, t))).next(t => (i = t,
                    o = Date.now(),
                    this.removeOrphanedDocuments(e, r))).next(e => (l = Date.now(),
                    g() <= c.LogLevel.DEBUG && y("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${s - u}ms
	Determined least recently used ${n} in ` + (a - s) + "ms\n" + `	Removed ${i} targets in ` + (o - a) + "ms\n" + `	Removed ${e} documents in ` + (l - o) + "ms\n" + `Total Duration: ${l - u}ms`),
                    s2.resolve({
                        didRun: !0,
                        sequenceNumbersCollected: n,
                        targetsRemoved: i,
                        documentsRemoved: e
                    })))
                }
            }
            class lP {
                constructor(e, t) {
                    this.db = e,
                    this.garbageCollector = new lM(this,t)
                }
                dr(e) {
                    let t = this.Vr(e);
                    return this.db.getTargetCache().getTargetCount(e).next(e => t.next(t => e + t))
                }
                Vr(e) {
                    let t = 0;
                    return this.Ar(e, e => {
                        t++
                    }
                    ).next( () => t)
                }
                forEachTarget(e, t) {
                    return this.db.getTargetCache().forEachTarget(e, t)
                }
                Ar(e, t) {
                    return this.mr(e, (e, r) => t(r))
                }
                addReference(e, t, r) {
                    return rt(e, r)
                }
                removeReference(e, t, r) {
                    return rt(e, r)
                }
                removeTargets(e, t, r) {
                    return this.db.getTargetCache().removeTargets(e, t, r)
                }
                markPotentiallyOrphaned(e, t) {
                    return rt(e, t)
                }
                gr(e, t) {
                    let r;
                    return r = !1,
                    $(e, ao).ne(n => t8(e, n, t).next(e => (e && (r = !0),
                    s2.resolve(!e)))).next( () => r)
                }
                removeOrphanedDocuments(e, t) {
                    let r = this.db.getRemoteDocumentCache().newChangeBuffer()
                      , n = []
                      , i = 0;
                    return this.mr(e, (s, a) => {
                        if (a <= t) {
                            let t = this.gr(e, s).next(t => {
                                if (!t)
                                    return i++,
                                    r.getEntry(e, s).next( () => (r.removeEntry(s, sz.min()),
                                    t9(e).delete([0, Q(s.path)])))
                            }
                            );
                            n.push(t)
                        }
                    }
                    ).next( () => s2.waitFor(n)).next( () => r.apply(e)).next( () => i)
                }
                removeTarget(e, t) {
                    let r = t.withSequenceNumber(e.currentSequenceNumber);
                    return this.db.getTargetCache().updateTargetData(e, r)
                }
                updateLimboDocument(e, t) {
                    return rt(e, t)
                }
                mr(e, t) {
                    let r = t9(e), n, i = an.le;
                    return r.te({
                        index: ax
                    }, ([e,r], {path: s, sequenceNumber: a}) => {
                        0 === e ? (i !== an.le && t(new sW(K(n)), i),
                        i = a,
                        n = s) : i = an.le
                    }
                    ).next( () => {
                        i !== an.le && t(new sW(K(n)), i)
                    }
                    )
                }
                getCacheSize(e) {
                    return this.db.getRemoteDocumentCache().getSize(e)
                }
            }
            function rt(e, t) {
                var r;
                return t9(e).put((r = e.currentSequenceNumber,
                {
                    targetId: 0,
                    path: Q(t.path),
                    sequenceNumber: r
                }))
            }
            class lL {
                constructor() {
                    this.changes = new oM(e => e.toString(), (e, t) => e.isEqual(t)),
                    this.changesApplied = !1
                }
                addEntry(e) {
                    this.assertNotApplied(),
                    this.changes.set(e.key, e)
                }
                removeEntry(e, t) {
                    this.assertNotApplied(),
                    this.changes.set(e, ow.newInvalidDocument(e).setReadTime(t))
                }
                getEntry(e, t) {
                    this.assertNotApplied();
                    let r = this.changes.get(t);
                    return void 0 !== r ? s2.resolve(r) : this.getFromCache(e, t)
                }
                getEntries(e, t) {
                    return this.getAllFromCache(e, t)
                }
                apply(e) {
                    return this.assertNotApplied(),
                    this.changesApplied = !0,
                    this.applyChanges(e)
                }
                assertNotApplied() {}
            }
            class lF {
                constructor(e) {
                    this.serializer = e
                }
                setIndexManager(e) {
                    this.indexManager = e
                }
                addEntry(e, t, r) {
                    return $(e, ap).put(r)
                }
                removeEntry(e, t, r) {
                    return $(e, ap).delete(function(e, t) {
                        let r = e.path.toArray();
                        return [r.slice(0, r.length - 2), r[r.length - 2], tV(t), r[r.length - 1]]
                    }(t, r))
                }
                updateMetadata(e, t) {
                    return this.getMetadata(e).next(r => (r.byteSize += t,
                    this.pr(e, r)))
                }
                getEntry(e, t) {
                    let r = ow.newInvalidDocument(t);
                    return $(e, ap).te({
                        index: am,
                        range: IDBKeyRange.only(rr(t))
                    }, (e, n) => {
                        r = this.yr(t, n)
                    }
                    ).next( () => r)
                }
                wr(e, t) {
                    let r = {
                        size: 0,
                        document: ow.newInvalidDocument(t)
                    };
                    return $(e, ap).te({
                        index: am,
                        range: IDBKeyRange.only(rr(t))
                    }, (e, n) => {
                        r = {
                            document: this.yr(t, n),
                            size: t4(n)
                        }
                    }
                    ).next( () => r)
                }
                getEntries(e, t) {
                    let r = oP;
                    return this.br(e, t, (e, t) => {
                        let n = this.yr(e, t);
                        r = r.insert(e, n)
                    }
                    ).next( () => r)
                }
                Sr(e, t) {
                    let r = oP
                      , n = new a5(sW.comparator);
                    return this.br(e, t, (e, t) => {
                        let i = this.yr(e, t);
                        r = r.insert(e, i),
                        n = n.insert(e, t4(t))
                    }
                    ).next( () => ({
                        documents: r,
                        Dr: n
                    }))
                }
                br(e, t, r) {
                    if (t.isEmpty())
                        return s2.resolve();
                    let n = new a7(ri);
                    t.forEach(e => n = n.add(e));
                    let i = IDBKeyRange.bound(rr(n.first()), rr(n.last()))
                      , s = n.getIterator()
                      , a = s.getNext();
                    return $(e, ap).te({
                        index: am,
                        range: i
                    }, (e, t, n) => {
                        let i = sW.fromSegments([...t.prefixPath, t.collectionGroup, t.documentId]);
                        for (; a && 0 > ri(a, i); )
                            r(a, null),
                            a = s.getNext();
                        a && a.isEqual(i) && (r(a, t),
                        a = s.hasNext() ? s.getNext() : null),
                        a ? n.H(rr(a)) : n.done()
                    }
                    ).next( () => {
                        for (; a; )
                            r(a, null),
                            a = s.hasNext() ? s.getNext() : null
                    }
                    )
                }
                getDocumentsMatchingQuery(e, t, r, n, i) {
                    let s = t.path
                      , a = [s.popLast().toArray(), s.lastSegment(), tV(r.readTime), r.documentKey.path.isEmpty() ? "" : r.documentKey.path.lastSegment()]
                      , o = [s.popLast().toArray(), s.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
                    return $(e, ap).J(IDBKeyRange.bound(a, o, !0)).next(e => {
                        null == i || i.incrementDocumentReadCount(e.length);
                        let r = oP;
                        for (let i of e) {
                            let e = this.yr(sW.fromSegments(i.prefixPath.concat(i.collectionGroup, i.documentId)), i);
                            e.isFoundDocument() && (eJ(t, e) || n.has(e.key)) && (r = r.insert(e.key, e))
                        }
                        return r
                    }
                    )
                }
                getAllFromCollectionGroup(e, t, r, n) {
                    let i = oP
                      , s = rn(t, r)
                      , a = rn(t, sZ.max());
                    return $(e, ap).te({
                        index: av,
                        range: IDBKeyRange.bound(s, a, !0)
                    }, (e, t, r) => {
                        let s = this.yr(sW.fromSegments(t.prefixPath.concat(t.collectionGroup, t.documentId)), t);
                        (i = i.insert(s.key, s)).size === n && r.done()
                    }
                    ).next( () => i)
                }
                newChangeBuffer(e) {
                    return new lB(this,!!e && e.trackRemovals)
                }
                getSize(e) {
                    return this.getMetadata(e).next(e => e.byteSize)
                }
                getMetadata(e) {
                    return $(e, ab).get(aE).next(e => (_(!!e, 20021),
                    e))
                }
                pr(e, t) {
                    return $(e, ab).put(aE, t)
                }
                yr(e, t) {
                    if (t) {
                        let e = function(e, t) {
                            let r;
                            if (t.document)
                                r = tA(e.wt, t.document, !!t.hasCommittedMutations);
                            else if (t.noDocument) {
                                let e = sW.fromSegments(t.noDocument.path)
                                  , n = tq(t.noDocument.readTime);
                                r = ow.newNoDocument(e, n),
                                t.hasCommittedMutations && r.setHasCommittedMutations()
                            } else {
                                if (!t.unknownDocument)
                                    return E(56709);
                                {
                                    let e = sW.fromSegments(t.unknownDocument.path)
                                      , n = tq(t.unknownDocument.version);
                                    r = ow.newUnknownDocument(e, n)
                                }
                            }
                            return t.readTime && r.setReadTime(function(e) {
                                let t = new sj(e[0],e[1]);
                                return sz.fromTimestamp(t)
                            }(t.readTime)),
                            r
                        }(this.serializer, t);
                        if (!(e.isNoDocument() && e.version.isEqual(sz.min())))
                            return e
                    }
                    return ow.newInvalidDocument(e)
                }
            }
            class lB extends lL {
                constructor(e, t) {
                    super(),
                    this.vr = e,
                    this.trackRemovals = t,
                    this.Cr = new oM(e => e.toString(), (e, t) => e.isEqual(t))
                }
                applyChanges(e) {
                    let t = []
                      , r = 0
                      , n = new a7( (e, t) => C(e.canonicalString(), t.canonicalString()));
                    return this.changes.forEach( (i, s) => {
                        let a = this.Cr.get(i);
                        if (t.push(this.vr.removeEntry(e, i, a.readTime)),
                        s.isValidDocument()) {
                            let o = tB(this.vr.serializer, s);
                            n = n.add(i.path.popLast());
                            let l = t4(o);
                            r += l - a.size,
                            t.push(this.vr.addEntry(e, i, o))
                        } else if (r -= a.size,
                        this.trackRemovals) {
                            let r = tB(this.vr.serializer, s.convertToNoDocument(sz.min()));
                            t.push(this.vr.addEntry(e, i, r))
                        }
                    }
                    ),
                    n.forEach(r => {
                        t.push(this.vr.indexManager.addToCollectionParentIndex(e, r))
                    }
                    ),
                    t.push(this.vr.updateMetadata(e, r)),
                    s2.waitFor(t)
                }
                getFromCache(e, t) {
                    return this.vr.wr(e, t).next(e => (this.Cr.set(t, {
                        size: e.size,
                        readTime: e.document.readTime
                    }),
                    e.document))
                }
                getAllFromCache(e, t) {
                    return this.vr.Sr(e, t).next( ({documents: e, Dr: t}) => (t.forEach( (t, r) => {
                        this.Cr.set(t, {
                            size: r,
                            readTime: e.get(t).readTime
                        })
                    }
                    ),
                    e))
                }
            }
            function rr(e) {
                let t = e.path.toArray();
                return [t.slice(0, t.length - 2), t[t.length - 2], t[t.length - 1]]
            }
            function rn(e, t) {
                let r = t.documentKey.path.toArray();
                return [e, tV(t.readTime), r.slice(0, r.length - 2), r.length > 0 ? r[r.length - 1] : ""]
            }
            function ri(e, t) {
                let r = e.path.toArray()
                  , n = t.path.toArray()
                  , i = 0;
                for (let e = 0; e < r.length - 2 && e < n.length - 2; ++e)
                    if (i = C(r[e], n[e]))
                        return i;
                return (i = C(r.length, n.length)) || (i = C(r[r.length - 2], n[n.length - 2])) || C(r[r.length - 1], n[n.length - 1])
            }
            class lV {
                constructor(e, t) {
                    this.overlayedDocument = e,
                    this.mutatedFields = t
                }
            }
            class lU {
                constructor(e, t, r, n) {
                    this.remoteDocumentCache = e,
                    this.mutationQueue = t,
                    this.documentOverlayCache = r,
                    this.indexManager = n
                }
                getDocument(e, t) {
                    let r = null;
                    return this.documentOverlayCache.getOverlay(e, t).next(n => (r = n,
                    this.remoteDocumentCache.getEntry(e, t))).next(e => (null !== r && tn(r.mutation, e, oe.empty(), sj.now()),
                    e))
                }
                getDocuments(e, t) {
                    return this.remoteDocumentCache.getEntries(e, t).next(t => this.getLocalViewOfDocuments(e, t, e2()).next( () => t))
                }
                getLocalViewOfDocuments(e, t, r=e2()) {
                    let n = e1();
                    return this.populateOverlays(e, n, t).next( () => this.computeViews(e, t, n, r).next(e => {
                        let t = eZ();
                        return e.forEach( (e, r) => {
                            t = t.insert(e, r.overlayedDocument)
                        }
                        ),
                        t
                    }
                    ))
                }
                getOverlayedDocuments(e, t) {
                    let r = e1();
                    return this.populateOverlays(e, r, t).next( () => this.computeViews(e, t, r, e2()))
                }
                populateOverlays(e, t, r) {
                    let n = [];
                    return r.forEach(e => {
                        t.has(e) || n.push(e)
                    }
                    ),
                    this.documentOverlayCache.getOverlays(e, n).next(e => {
                        e.forEach( (e, r) => {
                            t.set(e, r)
                        }
                        )
                    }
                    )
                }
                computeViews(e, t, r, n) {
                    let i = oP
                      , s = e1()
                      , a = e1();
                    return t.forEach( (e, t) => {
                        let a = r.get(t.key);
                        n.has(t.key) && (void 0 === a || a.mutation instanceof oJ) ? i = i.insert(t.key, t) : void 0 !== a ? (s.set(t.key, a.mutation.getFieldMask()),
                        tn(a.mutation, t, a.mutation.getFieldMask(), sj.now())) : s.set(t.key, oe.empty())
                    }
                    ),
                    this.recalculateAndSaveOverlays(e, i).next(e => (e.forEach( (e, t) => s.set(e, t)),
                    t.forEach( (e, t) => {
                        var r;
                        return a.set(e, new lV(t,null != (r = s.get(e)) ? r : null))
                    }
                    ),
                    a))
                }
                recalculateAndSaveOverlays(e, t) {
                    let r = e1()
                      , n = new a5( (e, t) => e - t)
                      , i = e2();
                    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next(e => {
                        for (let i of e)
                            i.keys().forEach(e => {
                                let s = t.get(e);
                                if (null === s)
                                    return;
                                let a = r.get(e) || oe.empty();
                                a = i.applyToLocalView(s, a),
                                r.set(e, a);
                                let o = (n.get(i.batchId) || e2()).add(e);
                                n = n.insert(i.batchId, o)
                            }
                            )
                    }
                    ).next( () => {
                        let s = []
                          , a = n.getReverseIterator();
                        for (; a.hasNext(); ) {
                            let n = a.getNext()
                              , o = n.key
                              , l = n.value
                              , u = e1();
                            l.forEach(e => {
                                if (!i.has(e)) {
                                    let n = tr(t.get(e), r.get(e));
                                    null !== n && u.set(e, n),
                                    i = i.add(e)
                                }
                            }
                            ),
                            s.push(this.documentOverlayCache.saveOverlays(e, o, u))
                        }
                        return s2.waitFor(s)
                    }
                    ).next( () => r)
                }
                recalculateAndSaveOverlaysForDocumentKeys(e, t) {
                    return this.remoteDocumentCache.getEntries(e, t).next(t => this.recalculateAndSaveOverlays(e, t))
                }
                getDocumentsMatchingQuery(e, t, r, n) {
                    return sW.isDocumentKey(t.path) && null === t.collectionGroup && 0 === t.filters.length ? this.getDocumentsMatchingDocumentQuery(e, t.path) : eU(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, r, n) : this.getDocumentsMatchingCollectionQuery(e, t, r, n)
                }
                getNextDocuments(e, t, r, n) {
                    return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, r, n).next(i => {
                        let s = n - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, r.largestBatchId, n - i.size) : s2.resolve(e1())
                          , a = -1
                          , o = i;
                        return s.next(t => s2.forEach(t, (t, r) => (a < r.largestBatchId && (a = r.largestBatchId),
                        i.get(t) ? s2.resolve() : this.remoteDocumentCache.getEntry(e, t).next(e => {
                            o = o.insert(t, e)
                        }
                        ))).next( () => this.populateOverlays(e, t, i)).next( () => this.computeViews(e, o, t, e2())).next(e => ({
                            batchId: a,
                            changes: e0(e)
                        })))
                    }
                    )
                }
                getDocumentsMatchingDocumentQuery(e, t) {
                    return this.getDocument(e, new sW(t)).next(e => {
                        let t = eZ();
                        return e.isFoundDocument() && (t = t.insert(e.key, e)),
                        t
                    }
                    )
                }
                getDocumentsMatchingCollectionGroupQuery(e, t, r, n) {
                    let i = t.collectionGroup
                      , s = eZ();
                    return this.indexManager.getCollectionParents(e, i).next(a => s2.forEach(a, a => {
                        let o = new oR(a.child(i),null,t.explicitOrderBy.slice(),t.filters.slice(),t.limit,t.limitType,t.startAt,t.endAt);
                        return this.getDocumentsMatchingCollectionQuery(e, o, r, n).next(e => {
                            e.forEach( (e, t) => {
                                s = s.insert(e, t)
                            }
                            )
                        }
                        )
                    }
                    ).next( () => s))
                }
                getDocumentsMatchingCollectionQuery(e, t, r, n) {
                    let i;
                    return this.documentOverlayCache.getOverlaysForCollection(e, t.path, r.largestBatchId).next(s => (i = s,
                    this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, r, i, n))).next(e => {
                        i.forEach( (t, r) => {
                            let n = r.getKey();
                            null === e.get(n) && (e = e.insert(n, ow.newInvalidDocument(n)))
                        }
                        );
                        let r = eZ();
                        return e.forEach( (e, n) => {
                            let s = i.get(e);
                            void 0 !== s && tn(s.mutation, n, oe.empty(), sj.now()),
                            eJ(t, n) && (r = r.insert(e, n))
                        }
                        ),
                        r
                    }
                    )
                }
            }
            class lq {
                constructor(e) {
                    this.serializer = e,
                    this.Fr = new Map,
                    this.Mr = new Map
                }
                getBundleMetadata(e, t) {
                    return s2.resolve(this.Fr.get(t))
                }
                saveBundleMetadata(e, t) {
                    return this.Fr.set(t.id, {
                        id: t.id,
                        version: t.version,
                        createTime: ty(t.createTime)
                    }),
                    s2.resolve()
                }
                getNamedQuery(e, t) {
                    return s2.resolve(this.Mr.get(t))
                }
                saveNamedQuery(e, t) {
                    return this.Mr.set(t.name, {
                        name: t.name,
                        query: tK(t.bundledQuery),
                        readTime: ty(t.readTime)
                    }),
                    s2.resolve()
                }
            }
            class lj {
                constructor() {
                    this.overlays = new a5(sW.comparator),
                    this.Or = new Map
                }
                getOverlay(e, t) {
                    return s2.resolve(this.overlays.get(t))
                }
                getOverlays(e, t) {
                    let r = e1();
                    return s2.forEach(t, t => this.getOverlay(e, t).next(e => {
                        null !== e && r.set(t, e)
                    }
                    )).next( () => r)
                }
                saveOverlays(e, t, r) {
                    return r.forEach( (r, n) => {
                        this.St(e, t, n)
                    }
                    ),
                    s2.resolve()
                }
                removeOverlaysForBatchId(e, t, r) {
                    let n = this.Or.get(r);
                    return void 0 !== n && (n.forEach(e => this.overlays = this.overlays.remove(e)),
                    this.Or.delete(r)),
                    s2.resolve()
                }
                getOverlaysForCollection(e, t, r) {
                    let n = e1()
                      , i = t.length + 1
                      , s = new sW(t.child(""))
                      , a = this.overlays.getIteratorFrom(s);
                    for (; a.hasNext(); ) {
                        let e = a.getNext().value
                          , s = e.getKey();
                        if (!t.isPrefixOf(s.path))
                            break;
                        s.path.length === i && e.largestBatchId > r && n.set(e.getKey(), e)
                    }
                    return s2.resolve(n)
                }
                getOverlaysForCollectionGroup(e, t, r, n) {
                    let i = new a5( (e, t) => e - t)
                      , s = this.overlays.getIterator();
                    for (; s.hasNext(); ) {
                        let e = s.getNext().value;
                        if (e.getKey().getCollectionGroup() === t && e.largestBatchId > r) {
                            let t = i.get(e.largestBatchId);
                            null === t && (t = e1(),
                            i = i.insert(e.largestBatchId, t)),
                            t.set(e.getKey(), e)
                        }
                    }
                    let a = e1()
                      , o = i.getIterator();
                    for (; o.hasNext() && (o.getNext().value.forEach( (e, t) => a.set(e, t)),
                    !(a.size() >= n)); )
                        ;
                    return s2.resolve(a)
                }
                St(e, t, r) {
                    let n = this.overlays.get(r.key);
                    if (null !== n) {
                        let e = this.Or.get(n.largestBatchId).delete(r.key);
                        this.Or.set(n.largestBatchId, e)
                    }
                    this.overlays = this.overlays.insert(r.key, new o1(t,r));
                    let i = this.Or.get(t);
                    void 0 === i && (i = e2(),
                    this.Or.set(t, i)),
                    this.Or.set(t, i.add(r.key))
                }
            }
            class lz {
                constructor() {
                    this.sessionToken = or.EMPTY_BYTE_STRING
                }
                getSessionToken(e) {
                    return s2.resolve(this.sessionToken)
                }
                setSessionToken(e, t) {
                    return this.sessionToken = t,
                    s2.resolve()
                }
            }
            class lQ {
                constructor() {
                    this.Nr = new a7(lK.Br),
                    this.Lr = new a7(lK.kr)
                }
                isEmpty() {
                    return this.Nr.isEmpty()
                }
                addReference(e, t) {
                    let r = new lK(e,t);
                    this.Nr = this.Nr.add(r),
                    this.Lr = this.Lr.add(r)
                }
                qr(e, t) {
                    e.forEach(e => this.addReference(e, t))
                }
                removeReference(e, t) {
                    this.Qr(new lK(e,t))
                }
                $r(e, t) {
                    e.forEach(e => this.removeReference(e, t))
                }
                Ur(e) {
                    let t = new sW(new s$([]))
                      , r = new lK(t,e)
                      , n = new lK(t,e + 1)
                      , i = [];
                    return this.Lr.forEachInRange([r, n], e => {
                        this.Qr(e),
                        i.push(e.key)
                    }
                    ),
                    i
                }
                Kr() {
                    this.Nr.forEach(e => this.Qr(e))
                }
                Qr(e) {
                    this.Nr = this.Nr.delete(e),
                    this.Lr = this.Lr.delete(e)
                }
                Wr(e) {
                    let t = new sW(new s$([]))
                      , r = new lK(t,e)
                      , n = new lK(t,e + 1)
                      , i = e2();
                    return this.Lr.forEachInRange([r, n], e => {
                        i = i.add(e.key)
                    }
                    ),
                    i
                }
                containsKey(e) {
                    let t = new lK(e,0)
                      , r = this.Nr.firstAfterOrEqual(t);
                    return null !== r && e.isEqual(r.key)
                }
            }
            class lK {
                constructor(e, t) {
                    this.key = e,
                    this.Gr = t
                }
                static Br(e, t) {
                    return sW.comparator(e.key, t.key) || C(e.Gr, t.Gr)
                }
                static kr(e, t) {
                    return C(e.Gr, t.Gr) || sW.comparator(e.key, t.key)
                }
            }
            class l$ {
                constructor(e, t) {
                    this.indexManager = e,
                    this.referenceDelegate = t,
                    this.mutationQueue = [],
                    this.Jn = 1,
                    this.zr = new a7(lK.Br)
                }
                checkEmpty(e) {
                    return s2.resolve(0 === this.mutationQueue.length)
                }
                addMutationBatch(e, t, r, n) {
                    let i = this.Jn;
                    this.Jn++,
                    this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
                    let s = new oZ(i,t,r,n);
                    for (let t of (this.mutationQueue.push(s),
                    n))
                        this.zr = this.zr.add(new lK(t.key,i)),
                        this.indexManager.addToCollectionParentIndex(e, t.key.path.popLast());
                    return s2.resolve(s)
                }
                lookupMutationBatch(e, t) {
                    return s2.resolve(this.jr(t))
                }
                getNextMutationBatchAfterBatchId(e, t) {
                    let r = this.Hr(t + 1)
                      , n = r < 0 ? 0 : r;
                    return s2.resolve(this.mutationQueue.length > n ? this.mutationQueue[n] : null)
                }
                getHighestUnacknowledgedBatchId() {
                    return s2.resolve(0 === this.mutationQueue.length ? -1 : this.Jn - 1)
                }
                getAllMutationBatches(e) {
                    return s2.resolve(this.mutationQueue.slice())
                }
                getAllMutationBatchesAffectingDocumentKey(e, t) {
                    let r = new lK(t,0)
                      , n = new lK(t,Number.POSITIVE_INFINITY)
                      , i = [];
                    return this.zr.forEachInRange([r, n], e => {
                        let t = this.jr(e.Gr);
                        i.push(t)
                    }
                    ),
                    s2.resolve(i)
                }
                getAllMutationBatchesAffectingDocumentKeys(e, t) {
                    let r = new a7(C);
                    return t.forEach(e => {
                        let t = new lK(e,0)
                          , n = new lK(e,Number.POSITIVE_INFINITY);
                        this.zr.forEachInRange([t, n], e => {
                            r = r.add(e.Gr)
                        }
                        )
                    }
                    ),
                    s2.resolve(this.Jr(r))
                }
                getAllMutationBatchesAffectingQuery(e, t) {
                    let r = t.path
                      , n = r.length + 1
                      , i = r;
                    sW.isDocumentKey(i) || (i = i.child(""));
                    let s = new lK(new sW(i),0)
                      , a = new a7(C);
                    return this.zr.forEachWhile(e => {
                        let t = e.key.path;
                        return !!r.isPrefixOf(t) && (t.length === n && (a = a.add(e.Gr)),
                        !0)
                    }
                    , s),
                    s2.resolve(this.Jr(a))
                }
                Jr(e) {
                    let t = [];
                    return e.forEach(e => {
                        let r = this.jr(e);
                        null !== r && t.push(r)
                    }
                    ),
                    t
                }
                removeMutationBatch(e, t) {
                    _(0 === this.Yr(t.batchId, "removed"), 55003),
                    this.mutationQueue.shift();
                    let r = this.zr;
                    return s2.forEach(t.mutations, n => {
                        let i = new lK(n.key,t.batchId);
                        return r = r.delete(i),
                        this.referenceDelegate.markPotentiallyOrphaned(e, n.key)
                    }
                    ).next( () => {
                        this.zr = r
                    }
                    )
                }
                Xn(e) {}
                containsKey(e, t) {
                    let r = new lK(t,0)
                      , n = this.zr.firstAfterOrEqual(r);
                    return s2.resolve(t.isEqual(n && n.key))
                }
                performConsistencyCheck(e) {
                    return this.mutationQueue.length,
                    s2.resolve()
                }
                Yr(e, t) {
                    return this.Hr(e)
                }
                Hr(e) {
                    return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId
                }
                jr(e) {
                    let t = this.Hr(e);
                    return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t]
                }
            }
            class lG {
                constructor(e) {
                    this.Zr = e,
                    this.docs = new a5(sW.comparator),
                    this.size = 0
                }
                setIndexManager(e) {
                    this.indexManager = e
                }
                addEntry(e, t) {
                    let r = t.key
                      , n = this.docs.get(r)
                      , i = n ? n.size : 0
                      , s = this.Zr(t);
                    return this.docs = this.docs.insert(r, {
                        document: t.mutableCopy(),
                        size: s
                    }),
                    this.size += s - i,
                    this.indexManager.addToCollectionParentIndex(e, r.path.popLast())
                }
                removeEntry(e) {
                    let t = this.docs.get(e);
                    t && (this.docs = this.docs.remove(e),
                    this.size -= t.size)
                }
                getEntry(e, t) {
                    let r = this.docs.get(t);
                    return s2.resolve(r ? r.document.mutableCopy() : ow.newInvalidDocument(t))
                }
                getEntries(e, t) {
                    let r = oP;
                    return t.forEach(e => {
                        let t = this.docs.get(e);
                        r = r.insert(e, t ? t.document.mutableCopy() : ow.newInvalidDocument(e))
                    }
                    ),
                    s2.resolve(r)
                }
                getDocumentsMatchingQuery(e, t, r, n) {
                    let i = oP
                      , s = t.path
                      , a = new sW(s.child("__id-9223372036854775808__"))
                      , o = this.docs.getIteratorFrom(a);
                    for (; o.hasNext(); ) {
                        let {key: e, value: {document: a}} = o.getNext();
                        if (!s.isPrefixOf(e.path))
                            break;
                        e.path.length > s.length + 1 || 0 >= P(M(a), r) || (n.has(a.key) || eJ(t, a)) && (i = i.insert(a.key, a.mutableCopy()))
                    }
                    return s2.resolve(i)
                }
                getAllFromCollectionGroup(e, t, r, n) {
                    E(9500)
                }
                Xr(e, t) {
                    return s2.forEach(this.docs, e => t(e))
                }
                newChangeBuffer(e) {
                    return new lH(this)
                }
                getSize(e) {
                    return s2.resolve(this.size)
                }
            }
            class lH extends lL {
                constructor(e) {
                    super(),
                    this.vr = e
                }
                applyChanges(e) {
                    let t = [];
                    return this.changes.forEach( (r, n) => {
                        n.isValidDocument() ? t.push(this.vr.addEntry(e, n)) : this.vr.removeEntry(r)
                    }
                    ),
                    s2.waitFor(t)
                }
                getFromCache(e, t) {
                    return this.vr.getEntry(e, t)
                }
                getAllFromCache(e, t) {
                    return this.vr.getEntries(e, t)
                }
            }
            class lW {
                constructor(e) {
                    this.persistence = e,
                    this.ei = new oM(e => eO(e),eR),
                    this.lastRemoteSnapshotVersion = sz.min(),
                    this.highestTargetId = 0,
                    this.ti = 0,
                    this.ni = new lQ,
                    this.targetCount = 0,
                    this.ri = lD.rr()
                }
                forEachTarget(e, t) {
                    return this.ei.forEach( (e, r) => t(r)),
                    s2.resolve()
                }
                getLastRemoteSnapshotVersion(e) {
                    return s2.resolve(this.lastRemoteSnapshotVersion)
                }
                getHighestSequenceNumber(e) {
                    return s2.resolve(this.ti)
                }
                allocateTargetId(e) {
                    return this.highestTargetId = this.ri.next(),
                    s2.resolve(this.highestTargetId)
                }
                setTargetsMetadata(e, t, r) {
                    return r && (this.lastRemoteSnapshotVersion = r),
                    t > this.ti && (this.ti = t),
                    s2.resolve()
                }
                ar(e) {
                    this.ei.set(e.target, e);
                    let t = e.targetId;
                    t > this.highestTargetId && (this.ri = new lD(t),
                    this.highestTargetId = t),
                    e.sequenceNumber > this.ti && (this.ti = e.sequenceNumber)
                }
                addTargetData(e, t) {
                    return this.ar(t),
                    this.targetCount += 1,
                    s2.resolve()
                }
                updateTargetData(e, t) {
                    return this.ar(t),
                    s2.resolve()
                }
                removeTargetData(e, t) {
                    return this.ei.delete(t.target),
                    this.ni.Ur(t.targetId),
                    this.targetCount -= 1,
                    s2.resolve()
                }
                removeTargets(e, t, r) {
                    let n = 0
                      , i = [];
                    return this.ei.forEach( (s, a) => {
                        a.sequenceNumber <= t && null === r.get(a.targetId) && (this.ei.delete(s),
                        i.push(this.removeMatchingKeysForTargetId(e, a.targetId)),
                        n++)
                    }
                    ),
                    s2.waitFor(i).next( () => n)
                }
                getTargetCount(e) {
                    return s2.resolve(this.targetCount)
                }
                getTargetData(e, t) {
                    let r = this.ei.get(t) || null;
                    return s2.resolve(r)
                }
                addMatchingKeys(e, t, r) {
                    return this.ni.qr(t, r),
                    s2.resolve()
                }
                removeMatchingKeys(e, t, r) {
                    this.ni.$r(t, r);
                    let n = this.persistence.referenceDelegate
                      , i = [];
                    return n && t.forEach(t => {
                        i.push(n.markPotentiallyOrphaned(e, t))
                    }
                    ),
                    s2.waitFor(i)
                }
                removeMatchingKeysForTargetId(e, t) {
                    return this.ni.Ur(t),
                    s2.resolve()
                }
                getMatchingKeysForTargetId(e, t) {
                    let r = this.ni.Wr(t);
                    return s2.resolve(r)
                }
                containsKey(e, t) {
                    return s2.resolve(this.ni.containsKey(t))
                }
            }
            class lJ {
                constructor(e, t) {
                    this.ii = {},
                    this.overlays = {},
                    this.si = new an(0),
                    this.oi = !1,
                    this.oi = !0,
                    this._i = new lz,
                    this.referenceDelegate = e(this),
                    this.ai = new lW(this),
                    this.indexManager = new lE,
                    this.remoteDocumentCache = new lG(e => this.referenceDelegate.ui(e)),
                    this.serializer = new lh(t),
                    this.ci = new lq(this.serializer)
                }
                start() {
                    return Promise.resolve()
                }
                shutdown() {
                    return this.oi = !1,
                    Promise.resolve()
                }
                get started() {
                    return this.oi
                }
                setDatabaseDeletedListener() {}
                setNetworkEnabled() {}
                getIndexManager(e) {
                    return this.indexManager
                }
                getDocumentOverlayCache(e) {
                    let t = this.overlays[e.toKey()];
                    return t || (t = new lj,
                    this.overlays[e.toKey()] = t),
                    t
                }
                getMutationQueue(e, t) {
                    let r = this.ii[e.toKey()];
                    return r || (r = new l$(t,this.referenceDelegate),
                    this.ii[e.toKey()] = r),
                    r
                }
                getGlobalsCache() {
                    return this._i
                }
                getTargetCache() {
                    return this.ai
                }
                getRemoteDocumentCache() {
                    return this.remoteDocumentCache
                }
                getBundleCache() {
                    return this.ci
                }
                runTransaction(e, t, r) {
                    y("MemoryPersistence", "Starting transaction:", e);
                    let n = new lY(this.si.next());
                    return this.referenceDelegate.li(),
                    r(n).next(e => this.referenceDelegate.hi(n).next( () => e)).toPromise().then(e => (n.raiseOnCommittedEvent(),
                    e))
                }
                Pi(e, t) {
                    return s2.or(Object.values(this.ii).map(r => () => r.containsKey(e, t)))
                }
            }
            class lY extends s1 {
                constructor(e) {
                    super(),
                    this.currentSequenceNumber = e
                }
            }
            class lX {
                constructor(e) {
                    this.persistence = e,
                    this.Ti = new lQ,
                    this.Ii = null
                }
                static Ei(e) {
                    return new lX(e)
                }
                get di() {
                    if (this.Ii)
                        return this.Ii;
                    throw E(60996)
                }
                addReference(e, t, r) {
                    return this.Ti.addReference(r, t),
                    this.di.delete(r.toString()),
                    s2.resolve()
                }
                removeReference(e, t, r) {
                    return this.Ti.removeReference(r, t),
                    this.di.add(r.toString()),
                    s2.resolve()
                }
                markPotentiallyOrphaned(e, t) {
                    return this.di.add(t.toString()),
                    s2.resolve()
                }
                removeTarget(e, t) {
                    this.Ti.Ur(t.targetId).forEach(e => this.di.add(e.toString()));
                    let r = this.persistence.getTargetCache();
                    return r.getMatchingKeysForTargetId(e, t.targetId).next(e => {
                        e.forEach(e => this.di.add(e.toString()))
                    }
                    ).next( () => r.removeTargetData(e, t))
                }
                li() {
                    this.Ii = new Set
                }
                hi(e) {
                    let t = this.persistence.getRemoteDocumentCache().newChangeBuffer();
                    return s2.forEach(this.di, r => {
                        let n = sW.fromPath(r);
                        return this.Ai(e, n).next(e => {
                            e || t.removeEntry(n, sz.min())
                        }
                        )
                    }
                    ).next( () => (this.Ii = null,
                    t.apply(e)))
                }
                updateLimboDocument(e, t) {
                    return this.Ai(e, t).next(e => {
                        e ? this.di.delete(t.toString()) : this.di.add(t.toString())
                    }
                    )
                }
                ui(e) {
                    return 0
                }
                Ai(e, t) {
                    return s2.or([ () => s2.resolve(this.Ti.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Pi(e, t)])
                }
            }
            class lZ {
                constructor(e, t) {
                    this.persistence = e,
                    this.Ri = new oM(e => Q(e.path), (e, t) => e.isEqual(t)),
                    this.garbageCollector = new lM(this,t)
                }
                static Ei(e, t) {
                    return new lZ(e,t)
                }
                li() {}
                hi(e) {
                    return s2.resolve()
                }
                forEachTarget(e, t) {
                    return this.persistence.getTargetCache().forEachTarget(e, t)
                }
                dr(e) {
                    let t = this.Vr(e);
                    return this.persistence.getTargetCache().getTargetCount(e).next(e => t.next(t => e + t))
                }
                Vr(e) {
                    let t = 0;
                    return this.Ar(e, e => {
                        t++
                    }
                    ).next( () => t)
                }
                Ar(e, t) {
                    return s2.forEach(this.Ri, (r, n) => this.gr(e, r, n).next(e => e ? s2.resolve() : t(n)))
                }
                removeTargets(e, t, r) {
                    return this.persistence.getTargetCache().removeTargets(e, t, r)
                }
                removeOrphanedDocuments(e, t) {
                    let r = 0
                      , n = this.persistence.getRemoteDocumentCache()
                      , i = n.newChangeBuffer();
                    return n.Xr(e, n => this.gr(e, n, t).next(e => {
                        e || (r++,
                        i.removeEntry(n, sz.min()))
                    }
                    )).next( () => i.apply(e)).next( () => r)
                }
                markPotentiallyOrphaned(e, t) {
                    return this.Ri.set(t, e.currentSequenceNumber),
                    s2.resolve()
                }
                removeTarget(e, t) {
                    let r = t.withSequenceNumber(e.currentSequenceNumber);
                    return this.persistence.getTargetCache().updateTargetData(e, r)
                }
                addReference(e, t, r) {
                    return this.Ri.set(r, e.currentSequenceNumber),
                    s2.resolve()
                }
                removeReference(e, t, r) {
                    return this.Ri.set(r, e.currentSequenceNumber),
                    s2.resolve()
                }
                updateLimboDocument(e, t) {
                    return this.Ri.set(t, e.currentSequenceNumber),
                    s2.resolve()
                }
                ui(e) {
                    let t = e.key.toString().length;
                    return e.isFoundDocument() && (t += function e(t) {
                        switch (es(t)) {
                        case 0:
                        case 1:
                            return 4;
                        case 2:
                            return 8;
                        case 3:
                        case 8:
                            return 16;
                        case 4:
                            let r = en(t);
                            return r ? 16 + e(r) : 16;
                        case 5:
                            return 2 * t.stringValue.length;
                        case 6:
                            return et(t.bytesValue).approximateByteSize();
                        case 7:
                            return t.referenceValue.length;
                        case 9:
                            return (t.arrayValue.values || []).reduce( (t, r) => t + e(r), 0);
                        case 10:
                        case 11:
                            var n;
                            let i;
                            return n = t.mapValue,
                            i = 0,
                            H(n.fields, (t, r) => {
                                i += t.length + e(r)
                            }
                            ),
                            i;
                        default:
                            throw E(13486, {
                                value: t
                            })
                        }
                    }(e.data.value)),
                    t
                }
                gr(e, t, r) {
                    return s2.or([ () => this.persistence.Pi(e, t), () => this.persistence.getTargetCache().containsKey(e, t), () => {
                        let e = this.Ri.get(t);
                        return s2.resolve(void 0 !== e && e > r)
                    }
                    ])
                }
                getCacheSize(e) {
                    return this.persistence.getRemoteDocumentCache().getSize(e)
                }
            }
            class l0 {
                constructor(e) {
                    this.serializer = e
                }
                q(e, t, r, n) {
                    let i = new s3("createOrUpgrade",t);
                    r < 1 && n >= 1 && (e.createObjectStore(as),
                    e.createObjectStore(ao, {
                        keyPath: "userId"
                    }),
                    e.createObjectStore(al, {
                        keyPath: au,
                        autoIncrement: !0
                    }).createIndex(ah, ac, {
                        unique: !0
                    }),
                    e.createObjectStore(af),
                    rs(e),
                    e.createObjectStore(ai));
                    let s = s2.resolve();
                    return r < 3 && n >= 3 && (0 !== r && (e.deleteObjectStore(aS),
                    e.deleteObjectStore(aI),
                    e.deleteObjectStore(ak),
                    rs(e)),
                    s = s.next( () => (function(e) {
                        let t = e.store(ak)
                          , r = {
                            highestTargetId: 0,
                            highestListenSequenceNumber: 0,
                            lastRemoteSnapshotVersion: sz.min().toTimestamp(),
                            targetCount: 0
                        };
                        return t.put(aD, r)
                    }
                    )(i))),
                    r < 4 && n >= 4 && (0 !== r && (s = s.next( () => i.store(al).J().next(t => {
                        e.deleteObjectStore(al),
                        e.createObjectStore(al, {
                            keyPath: au,
                            autoIncrement: !0
                        }).createIndex(ah, ac, {
                            unique: !0
                        });
                        let r = i.store(al)
                          , n = t.map(e => r.put(e));
                        return s2.waitFor(n)
                    }
                    ))),
                    s = s.next( () => {
                        e.createObjectStore(aR, {
                            keyPath: "clientId"
                        })
                    }
                    )),
                    r < 5 && n >= 5 && (s = s.next( () => this.Vi(i))),
                    r < 6 && n >= 6 && (s = s.next( () => (e.createObjectStore(ab),
                    this.mi(i)))),
                    r < 7 && n >= 7 && (s = s.next( () => this.fi(i))),
                    r < 8 && n >= 8 && (s = s.next( () => this.gi(e, i))),
                    r < 9 && n >= 9 && (s = s.next( () => {
                        e.objectStoreNames.contains("remoteDocumentChanges") && e.deleteObjectStore("remoteDocumentChanges")
                    }
                    )),
                    r < 10 && n >= 10 && (s = s.next( () => this.pi(i))),
                    r < 11 && n >= 11 && (s = s.next( () => {
                        e.createObjectStore(aM, {
                            keyPath: "bundleId"
                        }),
                        e.createObjectStore(aP, {
                            keyPath: "name"
                        })
                    }
                    )),
                    r < 12 && n >= 12 && (s = s.next( () => {
                        let t = e.createObjectStore(a$, {
                            keyPath: aG
                        });
                        t.createIndex(aH, aW, {
                            unique: !1
                        }),
                        t.createIndex(aJ, aY, {
                            unique: !1
                        })
                    }
                    )),
                    r < 13 && n >= 13 && (s = s.next( () => (function(e) {
                        let t = e.createObjectStore(ap, {
                            keyPath: ag
                        });
                        t.createIndex(am, ay),
                        t.createIndex(av, aw)
                    }
                    )(e)).next( () => this.yi(e, i)).next( () => e.deleteObjectStore(ai))),
                    r < 14 && n >= 14 && (s = s.next( () => this.wi(e, i))),
                    r < 15 && n >= 15 && (s = s.next( () => {
                        e.createObjectStore(aL, {
                            keyPath: "indexId",
                            autoIncrement: !0
                        }).createIndex(aF, "collectionGroup", {
                            unique: !1
                        }),
                        e.createObjectStore(aB, {
                            keyPath: aV
                        }).createIndex(aU, aq, {
                            unique: !1
                        }),
                        e.createObjectStore(aj, {
                            keyPath: az
                        }).createIndex(aQ, aK, {
                            unique: !1
                        })
                    }
                    )),
                    r < 16 && n >= 16 && (s = s.next( () => {
                        t.objectStore(aB).clear()
                    }
                    ).next( () => {
                        t.objectStore(aj).clear()
                    }
                    )),
                    r < 17 && n >= 17 && (s = s.next( () => {
                        e.createObjectStore(aX, {
                            keyPath: "name"
                        })
                    }
                    )),
                    s
                }
                mi(e) {
                    let t = 0;
                    return e.store(ai).te( (e, r) => {
                        t += t4(r)
                    }
                    ).next( () => {
                        let r = {
                            byteSize: t
                        };
                        return e.store(ab).put(aE, r)
                    }
                    )
                }
                Vi(e) {
                    let t = e.store(ao)
                      , r = e.store(al);
                    return t.J().next(t => s2.forEach(t, t => {
                        let n = IDBKeyRange.bound([t.userId, -1], [t.userId, t.lastAcknowledgedBatchId]);
                        return r.J(ah, n).next(r => s2.forEach(r, r => {
                            _(r.userId === t.userId, 18650, "Cannot process batch from unexpected user", {
                                batchId: r.batchId
                            });
                            let n = tj(this.serializer, r);
                            return t5(e, t.userId, n).next( () => {}
                            )
                        }
                        ))
                    }
                    ))
                }
                fi(e) {
                    let t = e.store(aS)
                      , r = e.store(ai);
                    return e.store(ak).get(aD).next(e => {
                        let n = [];
                        return r.te( (r, i) => {
                            let s = new s$(r)
                              , a = [0, Q(s)];
                            n.push(t.get(a).next(r => r ? s2.resolve() : t.put({
                                targetId: 0,
                                path: Q(s),
                                sequenceNumber: e.highestListenSequenceNumber
                            })))
                        }
                        ).next( () => s2.waitFor(n))
                    }
                    )
                }
                gi(e, t) {
                    e.createObjectStore(aN, {
                        keyPath: aO
                    });
                    let r = t.store(aN)
                      , n = new lI
                      , i = e => {
                        if (n.add(e)) {
                            let t = e.lastSegment()
                              , n = e.popLast();
                            return r.put({
                                collectionId: t,
                                parent: Q(n)
                            })
                        }
                    }
                    ;
                    return t.store(ai).te({
                        ee: !0
                    }, (e, t) => i(new s$(e).popLast())).next( () => t.store(af).te({
                        ee: !0
                    }, ([e,t,r], n) => i(K(t).popLast())))
                }
                pi(e) {
                    let t = e.store(aI);
                    return t.te( (e, r) => {
                        let n = tz(r)
                          , i = tQ(this.serializer, n);
                        return t.put(i)
                    }
                    )
                }
                yi(e, t) {
                    let r = t.store(ai)
                      , n = [];
                    return r.te( (e, r) => {
                        let i = t.store(ap)
                          , s = (r.document ? new sW(s$.fromString(r.document.name).popFirst(5)) : r.noDocument ? sW.fromSegments(r.noDocument.path) : r.unknownDocument ? sW.fromSegments(r.unknownDocument.path) : E(36783)).path.toArray()
                          , a = {
                            prefixPath: s.slice(0, s.length - 2),
                            collectionGroup: s[s.length - 2],
                            documentId: s[s.length - 1],
                            readTime: r.readTime || [0, 0],
                            unknownDocument: r.unknownDocument,
                            noDocument: r.noDocument,
                            document: r.document,
                            hasCommittedMutations: !!r.hasCommittedMutations
                        };
                        n.push(i.put(a))
                    }
                    ).next( () => s2.waitFor(n))
                }
                wi(e, t) {
                    let r = t.store(al)
                      , n = new lF(this.serializer)
                      , i = new lJ(lX.Ei,this.serializer.wt);
                    return r.J().next(e => {
                        let r = new Map;
                        return e.forEach(e => {
                            var t;
                            let n = null != (t = r.get(e.userId)) ? t : e2();
                            tj(this.serializer, e).keys().forEach(e => n = n.add(e)),
                            r.set(e.userId, n)
                        }
                        ),
                        s2.forEach(r, (e, r) => {
                            let s = new sC(r)
                              , a = ld.bt(this.serializer, s)
                              , o = i.getIndexManager(s);
                            return new lU(n,lA.bt(s, this.serializer, o, i.referenceDelegate),a,o).recalculateAndSaveOverlaysForDocumentKeys(new a3(t,an.le), e).next()
                        }
                        )
                    }
                    )
                }
            }
            function rs(e) {
                e.createObjectStore(aS, {
                    keyPath: aC
                }).createIndex(ax, aA, {
                    unique: !0
                }),
                e.createObjectStore(aI, {
                    keyPath: "targetId"
                }).createIndex(a_, aT, {
                    unique: !0
                }),
                e.createObjectStore(ak)
            }
            let l1 = "IndexedDbPersistence"
              , l2 = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time."
              , l6 = "main";
            class l3 {
                constructor(e, t, r, n, i, s, a, o, l, u, h=17) {
                    if (this.allowTabSynchronization = e,
                    this.persistenceKey = t,
                    this.clientId = r,
                    this.bi = i,
                    this.window = s,
                    this.document = a,
                    this.Si = l,
                    this.Di = u,
                    this.Ci = h,
                    this.si = null,
                    this.oi = !1,
                    this.isPrimary = !1,
                    this.networkEnabled = !0,
                    this.Fi = null,
                    this.inForeground = !1,
                    this.Mi = null,
                    this.xi = null,
                    this.Oi = Number.NEGATIVE_INFINITY,
                    this.Ni = e => Promise.resolve(),
                    !l3.C())
                        throw new sk(sD.UNIMPLEMENTED,"This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
                    this.referenceDelegate = new lP(this,n),
                    this.Bi = t + l6,
                    this.serializer = new lh(o),
                    this.Li = new s5(this.Bi,this.Ci,new l0(this.serializer)),
                    this._i = new lf,
                    this.ai = new lk(this.referenceDelegate,this.serializer),
                    this.remoteDocumentCache = new lF(this.serializer),
                    this.ci = new lc,
                    this.window && this.window.localStorage ? this.ki = this.window.localStorage : (this.ki = null,
                    !1 === u && v(l1, "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."))
                }
                start() {
                    return this.qi().then( () => {
                        if (!this.isPrimary && !this.allowTabSynchronization)
                            throw new sk(sD.FAILED_PRECONDITION,l2);
                        return this.Qi(),
                        this.$i(),
                        this.Ui(),
                        this.runTransaction("getHighestListenSequenceNumber", "readonly", e => this.ai.getHighestSequenceNumber(e))
                    }
                    ).then(e => {
                        this.si = new an(e,this.Si)
                    }
                    ).then( () => {
                        this.oi = !0
                    }
                    ).catch(e => (this.Li && this.Li.close(),
                    Promise.reject(e)))
                }
                Ki(e) {
                    return this.Ni = async t => {
                        if (this.started)
                            return e(t)
                    }
                    ,
                    e(this.isPrimary)
                }
                setDatabaseDeletedListener(e) {
                    this.Li.U(async t => {
                        null === t.newVersion && await e()
                    }
                    )
                }
                setNetworkEnabled(e) {
                    this.networkEnabled !== e && (this.networkEnabled = e,
                    this.bi.enqueueAndForget(async () => {
                        this.started && await this.qi()
                    }
                    ))
                }
                qi() {
                    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", e => $(e, aR).put({
                        clientId: this.clientId,
                        updateTimeMs: Date.now(),
                        networkEnabled: this.networkEnabled,
                        inForeground: this.inForeground
                    }).next( () => {
                        if (this.isPrimary)
                            return this.Wi(e).next(e => {
                                e || (this.isPrimary = !1,
                                this.bi.enqueueRetryable( () => this.Ni(!1)))
                            }
                            )
                    }
                    ).next( () => this.Gi(e)).next(t => this.isPrimary && !t ? this.zi(e).next( () => !1) : !!t && this.ji(e).next( () => !0))).catch(e => {
                        if (B(e))
                            return y(l1, "Failed to extend owner lease: ", e),
                            this.isPrimary;
                        if (!this.allowTabSynchronization)
                            throw e;
                        return y(l1, "Releasing owner lease after error during lease refresh", e),
                        !1
                    }
                    ).then(e => {
                        this.isPrimary !== e && this.bi.enqueueRetryable( () => this.Ni(e)),
                        this.isPrimary = e
                    }
                    )
                }
                Wi(e) {
                    return $(e, as).get(aa).next(e => s2.resolve(this.Hi(e)))
                }
                Ji(e) {
                    return $(e, aR).delete(this.clientId)
                }
                async Yi() {
                    if (this.isPrimary && !this.Zi(this.Oi, 18e5)) {
                        this.Oi = Date.now();
                        let e = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", e => {
                            let t = $(e, aR);
                            return t.J().next(e => {
                                let r = this.Xi(e, 18e5)
                                  , n = e.filter(e => -1 === r.indexOf(e));
                                return s2.forEach(n, e => t.delete(e.clientId)).next( () => n)
                            }
                            )
                        }
                        ).catch( () => []);
                        if (this.ki)
                            for (let t of e)
                                this.ki.removeItem(this.es(t.clientId))
                    }
                }
                Ui() {
                    this.xi = this.bi.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.qi().then( () => this.Yi()).then( () => this.Ui()))
                }
                Hi(e) {
                    return !!e && e.ownerId === this.clientId
                }
                Gi(e) {
                    return this.Di ? s2.resolve(!0) : $(e, as).get(aa).next(t => {
                        if (null !== t && this.Zi(t.leaseTimestampMs, 5e3) && !this.ts(t.ownerId)) {
                            if (this.Hi(t) && this.networkEnabled)
                                return !0;
                            if (!this.Hi(t)) {
                                if (!t.allowTabSynchronization)
                                    throw new sk(sD.FAILED_PRECONDITION,l2);
                                return !1
                            }
                        }
                        return !(!this.networkEnabled || !this.inForeground) || $(e, aR).J().next(e => void 0 === this.Xi(e, 5e3).find(e => {
                            if (this.clientId !== e.clientId) {
                                let t = !this.networkEnabled && e.networkEnabled
                                  , r = !this.inForeground && e.inForeground
                                  , n = this.networkEnabled === e.networkEnabled;
                                if (t || r && n)
                                    return !0
                            }
                            return !1
                        }
                        ))
                    }
                    ).next(e => (this.isPrimary !== e && y(l1, `Client ${e ? "is" : "is not"} eligible for a primary lease.`),
                    e))
                }
                async shutdown() {
                    this.oi = !1,
                    this.ns(),
                    this.xi && (this.xi.cancel(),
                    this.xi = null),
                    this.rs(),
                    this.ss(),
                    await this.Li.runTransaction("shutdown", "readwrite", [as, aR], e => {
                        let t = new a3(e,an.le);
                        return this.zi(t).next( () => this.Ji(t))
                    }
                    ),
                    this.Li.close(),
                    this._s()
                }
                Xi(e, t) {
                    return e.filter(e => this.Zi(e.updateTimeMs, t) && !this.ts(e.clientId))
                }
                us() {
                    return this.runTransaction("getActiveClients", "readonly", e => $(e, aR).J().next(e => this.Xi(e, 18e5).map(e => e.clientId)))
                }
                get started() {
                    return this.oi
                }
                getGlobalsCache() {
                    return this._i
                }
                getMutationQueue(e, t) {
                    return lA.bt(e, this.serializer, t, this.referenceDelegate)
                }
                getTargetCache() {
                    return this.ai
                }
                getRemoteDocumentCache() {
                    return this.remoteDocumentCache
                }
                getIndexManager(e) {
                    return new lS(e,this.serializer.wt.databaseId)
                }
                getDocumentOverlayCache(e) {
                    return ld.bt(this.serializer, e)
                }
                getBundleCache() {
                    return this.ci
                }
                runTransaction(e, t, r) {
                    var n;
                    let i;
                    y(l1, "Starting transaction:", e);
                    let s = 17 === (n = this.Ci) ? a6 : 16 === n || 15 === n ? a2 : 14 === n || 13 === n ? a1 : 12 === n ? a0 : 11 === n ? aZ : void E(60245);
                    return this.Li.runTransaction(e, "readonly" === t ? "readonly" : "readwrite", s, n => (i = new a3(n,this.si ? this.si.next() : an.le),
                    "readwrite-primary" === t ? this.Wi(i).next(e => !!e || this.Gi(i)).next(t => {
                        if (!t)
                            throw v(`Failed to obtain primary lease for action '${e}'.`),
                            this.isPrimary = !1,
                            this.bi.enqueueRetryable( () => this.Ni(!1)),
                            new sk(sD.FAILED_PRECONDITION,s0);
                        return r(i)
                    }
                    ).next(e => this.ji(i).next( () => e)) : this.cs(i).next( () => r(i)))).then(e => (i.raiseOnCommittedEvent(),
                    e))
                }
                cs(e) {
                    return $(e, as).get(aa).next(e => {
                        if (null !== e && this.Zi(e.leaseTimestampMs, 5e3) && !this.ts(e.ownerId) && !this.Hi(e) && !(this.Di || this.allowTabSynchronization && e.allowTabSynchronization))
                            throw new sk(sD.FAILED_PRECONDITION,l2)
                    }
                    )
                }
                ji(e) {
                    let t = {
                        ownerId: this.clientId,
                        allowTabSynchronization: this.allowTabSynchronization,
                        leaseTimestampMs: Date.now()
                    };
                    return $(e, as).put(aa, t)
                }
                static C() {
                    return s5.C()
                }
                zi(e) {
                    let t = $(e, as);
                    return t.get(aa).next(e => this.Hi(e) ? (y(l1, "Releasing primary lease."),
                    t.delete(aa)) : s2.resolve())
                }
                Zi(e, t) {
                    let r = Date.now();
                    return !(e < r - t) && (!(e > r) || (v(`Detected an update time that is in the future: ${e} > ${r}`),
                    !1))
                }
                Qi() {
                    null !== this.document && "function" == typeof this.document.addEventListener && (this.Mi = () => {
                        this.bi.enqueueAndForget( () => (this.inForeground = "visible" === this.document.visibilityState,
                        this.qi()))
                    }
                    ,
                    this.document.addEventListener("visibilitychange", this.Mi),
                    this.inForeground = "visible" === this.document.visibilityState)
                }
                rs() {
                    this.Mi && (this.document.removeEventListener("visibilitychange", this.Mi),
                    this.Mi = null)
                }
                $i() {
                    var e;
                    "function" == typeof (null == (e = this.window) ? void 0 : e.addEventListener) && (this.Fi = () => {
                        this.ns();
                        let e = /(?:Version|Mobile)\/1[456]/;
                        (0,
                        d.isSafari)() && (navigator.appVersion.match(e) || navigator.userAgent.match(e)) && this.bi.enterRestrictedMode(!0),
                        this.bi.enqueueAndForget( () => this.shutdown())
                    }
                    ,
                    this.window.addEventListener("pagehide", this.Fi))
                }
                ss() {
                    this.Fi && (this.window.removeEventListener("pagehide", this.Fi),
                    this.Fi = null)
                }
                ts(e) {
                    var t;
                    try {
                        let r = null !== (null == (t = this.ki) ? void 0 : t.getItem(this.es(e)));
                        return y(l1, `Client '${e}' ${r ? "is" : "is not"} zombied in LocalStorage`),
                        r
                    } catch (e) {
                        return v(l1, "Failed to get zombied client id.", e),
                        !1
                    }
                }
                ns() {
                    if (this.ki)
                        try {
                            this.ki.setItem(this.es(this.clientId), String(Date.now()))
                        } catch (e) {
                            v("Failed to set zombie client id.", e)
                        }
                }
                _s() {
                    if (this.ki)
                        try {
                            this.ki.removeItem(this.es(this.clientId))
                        } catch (e) {}
                }
                es(e) {
                    return `firestore_zombie_${this.persistenceKey}_${e}`
                }
            }
            function ra(e, t) {
                let r = e.projectId;
                return e.isDefaultDatabase || (r += "." + e.database),
                "firestore/" + t + "/" + r + "/"
            }
            class l5 {
                constructor(e, t, r, n) {
                    this.targetId = e,
                    this.fromCache = t,
                    this.ls = r,
                    this.hs = n
                }
                static Ps(e, t) {
                    let r = e2()
                      , n = e2();
                    for (let e of t.docChanges)
                        switch (e.type) {
                        case 0:
                            r = r.add(e.doc.key);
                            break;
                        case 1:
                            n = n.add(e.doc.key)
                        }
                    return new l5(e,t.fromCache,r,n)
                }
            }
            class l4 {
                constructor() {
                    this._documentReadCount = 0
                }
                get documentReadCount() {
                    return this._documentReadCount
                }
                incrementDocumentReadCount(e) {
                    this._documentReadCount += e
                }
            }
            class l8 {
                constructor() {
                    this.Ts = !1,
                    this.Is = !1,
                    this.Es = 100,
                    this.ds = (0,
                    d.isSafari)() ? 8 : F((0,
                    d.getUA)()) > 0 ? 6 : 4
                }
                initialize(e, t) {
                    this.As = e,
                    this.indexManager = t,
                    this.Ts = !0
                }
                getDocumentsMatchingQuery(e, t, r, n) {
                    let i = {
                        result: null
                    };
                    return this.Rs(e, t).next(e => {
                        i.result = e
                    }
                    ).next( () => {
                        if (!i.result)
                            return this.Vs(e, t, n, r).next(e => {
                                i.result = e
                            }
                            )
                    }
                    ).next( () => {
                        if (i.result)
                            return;
                        let r = new l4;
                        return this.fs(e, t, r).next(n => {
                            if (i.result = n,
                            this.Is)
                                return this.gs(e, t, r, n.size)
                        }
                        )
                    }
                    ).next( () => i.result)
                }
                gs(e, t, r, n) {
                    return r.documentReadCount < this.Es ? (g() <= c.LogLevel.DEBUG && y("QueryEngine", "SDK will not create cache indexes for query:", eW(t), "since it only creates cache indexes for collection contains", "more than or equal to", this.Es, "documents"),
                    s2.resolve()) : (g() <= c.LogLevel.DEBUG && y("QueryEngine", "Query:", eW(t), "scans", r.documentReadCount, "local documents and returns", n, "documents as results."),
                    r.documentReadCount > this.ds * n ? (g() <= c.LogLevel.DEBUG && y("QueryEngine", "The SDK decides to create cache indexes for query:", eW(t), "as using cache indexes may help improve performance."),
                    this.indexManager.createTargetIndexes(e, ej(t))) : s2.resolve())
                }
                Rs(e, t) {
                    if (eV(t))
                        return s2.resolve(null);
                    let r = ej(t);
                    return this.indexManager.getIndexType(e, r).next(n => 0 === n ? null : (null !== t.limit && 1 === n && (r = ej(t = e$(t, null, "F"))),
                    this.indexManager.getDocumentsMatchingTarget(e, r).next(n => {
                        let i = e2(...n);
                        return this.As.getDocuments(e, i).next(n => this.indexManager.getMinOffset(e, r).next(r => {
                            let s = this.ps(t, n);
                            return this.ys(t, s, i, r.readTime) ? this.Rs(e, e$(t, null, "F")) : this.ws(e, s, t, r)
                        }
                        ))
                    }
                    )))
                }
                Vs(e, t, r, n) {
                    return eV(t) || n.isEqual(sz.min()) ? s2.resolve(null) : this.As.getDocuments(e, r).next(i => {
                        let s = this.ps(t, i);
                        return this.ys(t, s, r, n) ? s2.resolve(null) : (g() <= c.LogLevel.DEBUG && y("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), eW(t)),
                        this.ws(e, s, t, R(n, -1)).next(e => e))
                    }
                    )
                }
                ps(e, t) {
                    let r = new a7(eX(e));
                    return t.forEach( (t, n) => {
                        eJ(e, n) && (r = r.add(n))
                    }
                    ),
                    r
                }
                ys(e, t, r, n) {
                    if (null === e.limit)
                        return !1;
                    if (r.size !== t.size)
                        return !0;
                    let i = "F" === e.limitType ? t.last() : t.first();
                    return !!i && (i.hasPendingWrites || i.version.compareTo(n) > 0)
                }
                fs(e, t, r) {
                    return g() <= c.LogLevel.DEBUG && y("QueryEngine", "Using full collection scan to execute query:", eW(t)),
                    this.As.getDocumentsMatchingQuery(e, t, sZ.min(), r)
                }
                ws(e, t, r, n) {
                    return this.As.getDocumentsMatchingQuery(e, r, n).next(e => (t.forEach(t => {
                        e = e.insert(t.key, t)
                    }
                    ),
                    e))
                }
            }
            let l7 = "LocalStore";
            class l9 {
                constructor(e, t, r, n) {
                    this.persistence = e,
                    this.bs = t,
                    this.serializer = n,
                    this.Ss = new a5(C),
                    this.Ds = new oM(e => eO(e),eR),
                    this.vs = new Map,
                    this.Cs = e.getRemoteDocumentCache(),
                    this.ai = e.getTargetCache(),
                    this.ci = e.getBundleCache(),
                    this.Fs(r)
                }
                Fs(e) {
                    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e),
                    this.indexManager = this.persistence.getIndexManager(e),
                    this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager),
                    this.localDocuments = new lU(this.Cs,this.mutationQueue,this.documentOverlayCache,this.indexManager),
                    this.Cs.setIndexManager(this.indexManager),
                    this.bs.initialize(this.localDocuments, this.indexManager)
                }
                collectGarbage(e) {
                    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", t => e.collect(t, this.Ss))
                }
            }
            async function ro(e, t) {
                return await e.persistence.runTransaction("Handle user change", "readonly", r => {
                    let n;
                    return e.mutationQueue.getAllMutationBatches(r).next(i => (n = i,
                    e.Fs(t),
                    e.mutationQueue.getAllMutationBatches(r))).next(t => {
                        let i = []
                          , s = []
                          , a = e2();
                        for (let e of n)
                            for (let t of (i.push(e.batchId),
                            e.mutations))
                                a = a.add(t.key);
                        for (let e of t)
                            for (let t of (s.push(e.batchId),
                            e.mutations))
                                a = a.add(t.key);
                        return e.localDocuments.getDocuments(r, a).next(e => ({
                            Ms: e,
                            removedBatchIds: i,
                            addedBatchIds: s
                        }))
                    }
                    )
                }
                )
            }
            function rl(e) {
                return e.persistence.runTransaction("Get last remote snapshot version", "readonly", t => e.ai.getLastRemoteSnapshotVersion(t))
            }
            function ru(e, t, r) {
                let n = e2()
                  , i = e2();
                return r.forEach(e => n = n.add(e)),
                t.getEntries(e, n).next(e => {
                    let n = oP;
                    return r.forEach( (r, s) => {
                        let a = e.get(r);
                        s.isFoundDocument() !== a.isFoundDocument() && (i = i.add(r)),
                        s.isNoDocument() && s.version.isEqual(sz.min()) ? (t.removeEntry(r, s.readTime),
                        n = n.insert(r, s)) : !a.isValidDocument() || s.version.compareTo(a.version) > 0 || 0 === s.version.compareTo(a.version) && a.hasPendingWrites ? (t.addEntry(s),
                        n = n.insert(r, s)) : y(l7, "Ignoring outdated watch update for ", r, ". Current version:", a.version, " Watch version:", s.version)
                    }
                    ),
                    {
                        xs: n,
                        Os: i
                    }
                }
                )
            }
            function rh(e, t) {
                return e.persistence.runTransaction("Allocate target", "readwrite", r => {
                    let n;
                    return e.ai.getTargetData(r, t).next(i => i ? (n = i,
                    s2.resolve(n)) : e.ai.allocateTargetId(r).next(i => (n = new lu(t,i,"TargetPurposeListen",r.currentSequenceNumber),
                    e.ai.addTargetData(r, n).next( () => n))))
                }
                ).then(r => {
                    let n = e.Ss.get(r.targetId);
                    return (null === n || r.snapshotVersion.compareTo(n.snapshotVersion) > 0) && (e.Ss = e.Ss.insert(r.targetId, r),
                    e.Ds.set(t, r.targetId)),
                    r
                }
                )
            }
            async function rc(e, t, r) {
                let n = e.Ss.get(t);
                try {
                    r || await e.persistence.runTransaction("Release target", r ? "readwrite" : "readwrite-primary", t => e.persistence.referenceDelegate.removeTarget(t, n))
                } catch (e) {
                    if (!B(e))
                        throw e;
                    y(l7, `Failed to update sequence numbers for target ${t}: ${e}`)
                }
                e.Ss = e.Ss.remove(t),
                e.Ds.delete(n.target)
            }
            function rd(e, t, r) {
                let n = sz.min()
                  , i = e2();
                return e.persistence.runTransaction("Execute query", "readwrite", s => (function(e, t, r) {
                    let n = e.Ds.get(r);
                    return void 0 !== n ? s2.resolve(e.Ss.get(n)) : e.ai.getTargetData(t, r)
                }
                )(e, s, ej(t)).next(t => {
                    if (t)
                        return n = t.lastLimboFreeSnapshotVersion,
                        e.ai.getMatchingKeysForTargetId(s, t.targetId).next(e => {
                            i = e
                        }
                        )
                }
                ).next( () => e.bs.getDocumentsMatchingQuery(s, t, r ? n : sz.min(), r ? i : e2())).next(r => (rg(e, eY(t), r),
                {
                    documents: r,
                    Ns: i
                })))
            }
            function rf(e, t) {
                let r = e.ai
                  , n = e.Ss.get(t);
                return n ? Promise.resolve(n.target) : e.persistence.runTransaction("Get target data", "readonly", e => r.Rt(e, t).next(e => e ? e.target : null))
            }
            function rp(e, t) {
                let r = e.vs.get(t) || sz.min();
                return e.persistence.runTransaction("Get new document changes", "readonly", n => e.Cs.getAllFromCollectionGroup(n, t, R(r, -1), Number.MAX_SAFE_INTEGER)).then(r => (rg(e, t, r),
                r))
            }
            function rg(e, t, r) {
                let n = e.vs.get(t) || sz.min();
                r.forEach( (e, t) => {
                    t.readTime.compareTo(n) > 0 && (n = t.readTime)
                }
                ),
                e.vs.set(t, n)
            }
            async function rm(e, t, r, n) {
                let i = e2()
                  , s = oP;
                for (let e of r) {
                    let r = t.Bs(e.metadata.name);
                    e.document && (i = i.add(r));
                    let n = t.Ls(e);
                    n.setReadTime(t.ks(e.metadata.readTime)),
                    s = s.insert(r, n)
                }
                let a = e.Cs.newChangeBuffer({
                    trackRemovals: !0
                })
                  , o = await rh(e, ej(eB(s$.fromString(`__bundle__/docs/${n}`))));
                return e.persistence.runTransaction("Apply bundle documents", "readwrite", t => ru(t, a, s).next(e => (a.apply(t),
                e)).next(r => e.ai.removeMatchingKeysForTargetId(t, o.targetId).next( () => e.ai.addMatchingKeys(t, i, o.targetId)).next( () => e.localDocuments.getLocalViewOfDocuments(t, r.xs, r.Os)).next( () => r.xs)))
            }
            async function ry(e, t, r=e2()) {
                let n = await rh(e, ej(tK(t.bundledQuery)));
                return e.persistence.runTransaction("Save named query", "readwrite", i => {
                    let s = ty(t.readTime);
                    if (n.snapshotVersion.compareTo(s) >= 0)
                        return e.ci.saveNamedQuery(i, t);
                    let a = n.withResumeToken(or.EMPTY_BYTE_STRING, s);
                    return e.Ss = e.Ss.insert(a.targetId, a),
                    e.ai.updateTargetData(i, a).next( () => e.ai.removeMatchingKeysForTargetId(i, n.targetId)).next( () => e.ai.addMatchingKeys(i, r, n.targetId)).next( () => e.ci.saveNamedQuery(i, t))
                }
                )
            }
            let ue = "firestore_clients";
            function rv(e, t) {
                return `${ue}_${e}_${t}`
            }
            let ut = "firestore_mutations";
            function rw(e, t, r) {
                let n = `${ut}_${e}_${r}`;
                return t.isAuthenticated() && (n += `_${t.uid}`),
                n
            }
            let ur = "firestore_targets";
            function rb(e, t) {
                return `${ur}_${e}_${t}`
            }
            let un = "SharedClientState";
            class ui {
                constructor(e, t, r, n) {
                    this.user = e,
                    this.batchId = t,
                    this.state = r,
                    this.error = n
                }
                static qs(e, t, r) {
                    let n = JSON.parse(r), i, s = "object" == typeof n && -1 !== ["pending", "acknowledged", "rejected"].indexOf(n.state) && (void 0 === n.error || "object" == typeof n.error);
                    return s && n.error && (s = "string" == typeof n.error.message && "string" == typeof n.error.code) && (i = new sk(n.error.code,n.error.message)),
                    s ? new ui(e,t,n.state,i) : (v(un, `Failed to parse mutation state for ID '${t}': ${r}`),
                    null)
                }
                Qs() {
                    let e = {
                        state: this.state,
                        updateTimeMs: Date.now()
                    };
                    return this.error && (e.error = {
                        code: this.error.code,
                        message: this.error.message
                    }),
                    JSON.stringify(e)
                }
            }
            class us {
                constructor(e, t, r) {
                    this.targetId = e,
                    this.state = t,
                    this.error = r
                }
                static qs(e, t) {
                    let r = JSON.parse(t), n, i = "object" == typeof r && -1 !== ["not-current", "current", "rejected"].indexOf(r.state) && (void 0 === r.error || "object" == typeof r.error);
                    return i && r.error && (i = "string" == typeof r.error.message && "string" == typeof r.error.code) && (n = new sk(r.error.code,r.error.message)),
                    i ? new us(e,r.state,n) : (v(un, `Failed to parse target state for ID '${e}': ${t}`),
                    null)
                }
                Qs() {
                    let e = {
                        state: this.state,
                        updateTimeMs: Date.now()
                    };
                    return this.error && (e.error = {
                        code: this.error.code,
                        message: this.error.message
                    }),
                    JSON.stringify(e)
                }
            }
            class ua {
                constructor(e, t) {
                    this.clientId = e,
                    this.activeTargetIds = t
                }
                static qs(e, t) {
                    let r = JSON.parse(t)
                      , n = "object" == typeof r && r.activeTargetIds instanceof Array
                      , i = oV;
                    for (let e = 0; n && e < r.activeTargetIds.length; ++e)
                        n = z(r.activeTargetIds[e]),
                        i = i.add(r.activeTargetIds[e]);
                    return n ? new ua(e,i) : (v(un, `Failed to parse client data for instance '${e}': ${t}`),
                    null)
                }
            }
            class uo {
                constructor(e, t) {
                    this.clientId = e,
                    this.onlineState = t
                }
                static qs(e) {
                    let t = JSON.parse(e);
                    return "object" == typeof t && -1 !== ["Unknown", "Online", "Offline"].indexOf(t.onlineState) && "string" == typeof t.clientId ? new uo(t.clientId,t.onlineState) : (v(un, `Failed to parse online state: ${e}`),
                    null)
                }
            }
            class ul {
                constructor() {
                    this.activeTargetIds = oV
                }
                $s(e) {
                    this.activeTargetIds = this.activeTargetIds.add(e)
                }
                Us(e) {
                    this.activeTargetIds = this.activeTargetIds.delete(e)
                }
                Qs() {
                    return JSON.stringify({
                        activeTargetIds: this.activeTargetIds.toArray(),
                        updateTimeMs: Date.now()
                    })
                }
            }
            class uu {
                constructor(e, t, r, n, i) {
                    var s, a, o;
                    this.window = e,
                    this.bi = t,
                    this.persistenceKey = r,
                    this.Ks = n,
                    this.syncEngine = null,
                    this.onlineStateHandler = null,
                    this.sequenceNumberHandler = null,
                    this.Ws = this.Gs.bind(this),
                    this.zs = new a5(C),
                    this.started = !1,
                    this.js = [];
                    let l = r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                    this.storage = this.window.localStorage,
                    this.currentUser = i,
                    this.Hs = rv(this.persistenceKey, this.Ks),
                    this.Js = (s = this.persistenceKey,
                    `firestore_sequence_number_${s}`),
                    this.zs = this.zs.insert(this.Ks, new ul),
                    this.Ys = RegExp(`^${ue}_${l}_([^_]*)$`),
                    this.Zs = RegExp(`^${ut}_${l}_(\\d+)(?:_(.*))?$`),
                    this.Xs = RegExp(`^${ur}_${l}_(\\d+)$`),
                    this.eo = (a = this.persistenceKey,
                    `firestore_online_state_${a}`),
                    this.no = (o = this.persistenceKey,
                    `firestore_bundle_loaded_v2_${o}`),
                    this.window.addEventListener("storage", this.Ws)
                }
                static C(e) {
                    return !(!e || !e.localStorage)
                }
                async start() {
                    for (let e of (await this.syncEngine.us())) {
                        if (e === this.Ks)
                            continue;
                        let t = this.getItem(rv(this.persistenceKey, e));
                        if (t) {
                            let r = ua.qs(e, t);
                            r && (this.zs = this.zs.insert(r.clientId, r))
                        }
                    }
                    this.ro();
                    let e = this.storage.getItem(this.eo);
                    if (e) {
                        let t = this.io(e);
                        t && this.so(t)
                    }
                    for (let e of this.js)
                        this.Gs(e);
                    this.js = [],
                    this.window.addEventListener("pagehide", () => this.shutdown()),
                    this.started = !0
                }
                writeSequenceNumber(e) {
                    this.setItem(this.Js, JSON.stringify(e))
                }
                getAllActiveQueryTargets() {
                    return this.oo(this.zs)
                }
                isActiveQueryTarget(e) {
                    let t = !1;
                    return this.zs.forEach( (r, n) => {
                        n.activeTargetIds.has(e) && (t = !0)
                    }
                    ),
                    t
                }
                addPendingMutation(e) {
                    this._o(e, "pending")
                }
                updateMutationState(e, t, r) {
                    this._o(e, t, r),
                    this.ao(e)
                }
                addLocalQueryTarget(e, t=!0) {
                    let r = "not-current";
                    if (this.isActiveQueryTarget(e)) {
                        let t = this.storage.getItem(rb(this.persistenceKey, e));
                        if (t) {
                            let n = us.qs(e, t);
                            n && (r = n.state)
                        }
                    }
                    return t && this.uo.$s(e),
                    this.ro(),
                    r
                }
                removeLocalQueryTarget(e) {
                    this.uo.Us(e),
                    this.ro()
                }
                isLocalQueryTarget(e) {
                    return this.uo.activeTargetIds.has(e)
                }
                clearQueryState(e) {
                    this.removeItem(rb(this.persistenceKey, e))
                }
                updateQueryState(e, t, r) {
                    this.co(e, t, r)
                }
                handleUserChange(e, t, r) {
                    t.forEach(e => {
                        this.ao(e)
                    }
                    ),
                    this.currentUser = e,
                    r.forEach(e => {
                        this.addPendingMutation(e)
                    }
                    )
                }
                setOnlineState(e) {
                    this.lo(e)
                }
                notifyBundleLoaded(e) {
                    this.ho(e)
                }
                shutdown() {
                    this.started && (this.window.removeEventListener("storage", this.Ws),
                    this.removeItem(this.Hs),
                    this.started = !1)
                }
                getItem(e) {
                    let t = this.storage.getItem(e);
                    return y(un, "READ", e, t),
                    t
                }
                setItem(e, t) {
                    y(un, "SET", e, t),
                    this.storage.setItem(e, t)
                }
                removeItem(e) {
                    y(un, "REMOVE", e),
                    this.storage.removeItem(e)
                }
                Gs(e) {
                    if (e.storageArea === this.storage) {
                        if (y(un, "EVENT", e.key, e.newValue),
                        e.key === this.Hs)
                            return void v("Received WebStorage notification for local change. Another client might have garbage-collected our state");
                        this.bi.enqueueRetryable(async () => {
                            if (this.started) {
                                if (null !== e.key) {
                                    if (this.Ys.test(e.key)) {
                                        if (null == e.newValue) {
                                            let t = this.Po(e.key);
                                            return this.To(t, null)
                                        }
                                        {
                                            let t = this.Io(e.key, e.newValue);
                                            if (t)
                                                return this.To(t.clientId, t)
                                        }
                                    } else if (this.Zs.test(e.key)) {
                                        if (null !== e.newValue) {
                                            let t = this.Eo(e.key, e.newValue);
                                            if (t)
                                                return this.Ao(t)
                                        }
                                    } else if (this.Xs.test(e.key)) {
                                        if (null !== e.newValue) {
                                            let t = this.Ro(e.key, e.newValue);
                                            if (t)
                                                return this.Vo(t)
                                        }
                                    } else if (e.key === this.eo) {
                                        if (null !== e.newValue) {
                                            let t = this.io(e.newValue);
                                            if (t)
                                                return this.so(t)
                                        }
                                    } else if (e.key === this.Js) {
                                        let t = function(e) {
                                            let t = an.le;
                                            if (null != e)
                                                try {
                                                    let r = JSON.parse(e);
                                                    _("number" == typeof r, 30636, {
                                                        mo: e
                                                    }),
                                                    t = r
                                                } catch (e) {
                                                    v(un, "Failed to read sequence number from WebStorage", e)
                                                }
                                            return t
                                        }(e.newValue);
                                        t !== an.le && this.sequenceNumberHandler(t)
                                    } else if (e.key === this.no) {
                                        let t = this.fo(e.newValue);
                                        await Promise.all(t.map(e => this.syncEngine.po(e)))
                                    }
                                }
                            } else
                                this.js.push(e)
                        }
                        )
                    }
                }
                get uo() {
                    return this.zs.get(this.Ks)
                }
                ro() {
                    this.setItem(this.Hs, this.uo.Qs())
                }
                _o(e, t, r) {
                    let n = new ui(this.currentUser,e,t,r)
                      , i = rw(this.persistenceKey, this.currentUser, e);
                    this.setItem(i, n.Qs())
                }
                ao(e) {
                    let t = rw(this.persistenceKey, this.currentUser, e);
                    this.removeItem(t)
                }
                lo(e) {
                    let t = {
                        clientId: this.Ks,
                        onlineState: e
                    };
                    this.storage.setItem(this.eo, JSON.stringify(t))
                }
                co(e, t, r) {
                    let n = rb(this.persistenceKey, e)
                      , i = new us(e,t,r);
                    this.setItem(n, i.Qs())
                }
                ho(e) {
                    let t = JSON.stringify(Array.from(e));
                    this.setItem(this.no, t)
                }
                Po(e) {
                    let t = this.Ys.exec(e);
                    return t ? t[1] : null
                }
                Io(e, t) {
                    let r = this.Po(e);
                    return ua.qs(r, t)
                }
                Eo(e, t) {
                    let r = this.Zs.exec(e)
                      , n = Number(r[1])
                      , i = void 0 !== r[2] ? r[2] : null;
                    return ui.qs(new sC(i), n, t)
                }
                Ro(e, t) {
                    let r = Number(this.Xs.exec(e)[1]);
                    return us.qs(r, t)
                }
                io(e) {
                    return uo.qs(e)
                }
                fo(e) {
                    return JSON.parse(e)
                }
                async Ao(e) {
                    if (e.user.uid === this.currentUser.uid)
                        return this.syncEngine.yo(e.batchId, e.state, e.error);
                    y(un, `Ignoring mutation for non-active user ${e.user.uid}`)
                }
                Vo(e) {
                    return this.syncEngine.wo(e.targetId, e.state, e.error)
                }
                To(e, t) {
                    let r = t ? this.zs.insert(e, t) : this.zs.remove(e)
                      , n = this.oo(this.zs)
                      , i = this.oo(r)
                      , s = []
                      , a = [];
                    return i.forEach(e => {
                        n.has(e) || s.push(e)
                    }
                    ),
                    n.forEach(e => {
                        i.has(e) || a.push(e)
                    }
                    ),
                    this.syncEngine.bo(s, a).then( () => {
                        this.zs = r
                    }
                    )
                }
                so(e) {
                    this.zs.get(e.clientId) && this.onlineStateHandler(e.onlineState)
                }
                oo(e) {
                    let t = oV;
                    return e.forEach( (e, r) => {
                        t = t.unionWith(r.activeTargetIds)
                    }
                    ),
                    t
                }
            }
            class uh {
                constructor() {
                    this.So = new ul,
                    this.Do = {},
                    this.onlineStateHandler = null,
                    this.sequenceNumberHandler = null
                }
                addPendingMutation(e) {}
                updateMutationState(e, t, r) {}
                addLocalQueryTarget(e, t=!0) {
                    return t && this.So.$s(e),
                    this.Do[e] || "not-current"
                }
                updateQueryState(e, t, r) {
                    this.Do[e] = t
                }
                removeLocalQueryTarget(e) {
                    this.So.Us(e)
                }
                isLocalQueryTarget(e) {
                    return this.So.activeTargetIds.has(e)
                }
                clearQueryState(e) {
                    delete this.Do[e]
                }
                getAllActiveQueryTargets() {
                    return this.So.activeTargetIds
                }
                isActiveQueryTarget(e) {
                    return this.So.activeTargetIds.has(e)
                }
                start() {
                    return this.So = new ul,
                    Promise.resolve()
                }
                handleUserChange(e, t, r) {}
                setOnlineState(e) {}
                shutdown() {}
                writeSequenceNumber(e) {}
                notifyBundleLoaded(e) {}
            }
            class uc {
                vo(e) {}
                shutdown() {}
            }
            let ud = "ConnectivityMonitor";
            class uf {
                constructor() {
                    this.Co = () => this.Fo(),
                    this.Mo = () => this.xo(),
                    this.Oo = [],
                    this.No()
                }
                vo(e) {
                    this.Oo.push(e)
                }
                shutdown() {
                    window.removeEventListener("online", this.Co),
                    window.removeEventListener("offline", this.Mo)
                }
                No() {
                    window.addEventListener("online", this.Co),
                    window.addEventListener("offline", this.Mo)
                }
                Fo() {
                    for (let e of (y(ud, "Network connectivity changed: AVAILABLE"),
                    this.Oo))
                        e(0)
                }
                xo() {
                    for (let e of (y(ud, "Network connectivity changed: UNAVAILABLE"),
                    this.Oo))
                        e(1)
                }
                static C() {
                    return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener
                }
            }
            let up = null;
            function rE() {
                return null === up ? up = 0x10000000 + Math.round(0x80000000 * Math.random()) : up++,
                "0x" + up.toString(16)
            }
            let ug = "RestConnection"
              , um = {
                BatchGetDocuments: "batchGet",
                Commit: "commit",
                RunQuery: "runQuery",
                RunAggregationQuery: "runAggregationQuery"
            };
            class uy {
                get Bo() {
                    return !1
                }
                constructor(e) {
                    this.databaseInfo = e,
                    this.databaseId = e.databaseId;
                    let t = e.ssl ? "https" : "http"
                      , r = encodeURIComponent(this.databaseId.projectId)
                      , n = encodeURIComponent(this.databaseId.database);
                    this.Lo = t + "://" + e.host,
                    this.ko = `projects/${r}/databases/${n}`,
                    this.qo = this.databaseId.database === ou ? `project_id=${r}` : `project_id=${r}&database_id=${n}`
                }
                Qo(e, t, r, n, i) {
                    let s = rE()
                      , a = this.$o(e, t.toUriEncodedString());
                    y(ug, `Sending RPC '${e}' ${s}:`, a, r);
                    let o = {
                        "google-cloud-resource-prefix": this.ko,
                        "x-goog-request-params": this.qo
                    };
                    this.Uo(o, n, i);
                    let {host: l} = new URL(a)
                      , u = (0,
                    d.isCloudWorkstation)(l);
                    return this.Ko(e, a, o, r, u).then(t => (y(ug, `Received RPC '${e}' ${s}: `, t),
                    t), t => {
                        throw w(ug, `RPC '${e}' ${s} failed with error: `, t, "url: ", a, "request:", r),
                        t
                    }
                    )
                }
                Wo(e, t, r, n, i, s) {
                    return this.Qo(e, t, r, n, i)
                }
                Uo(e, t, r) {
                    e["X-Goog-Api-Client"] = "gl-js/ fire/" + sx,
                    e["Content-Type"] = "text/plain",
                    this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId),
                    t && t.headers.forEach( (t, r) => e[r] = t),
                    r && r.headers.forEach( (t, r) => e[r] = t)
                }
                $o(e, t) {
                    let r = um[e];
                    return `${this.Lo}/v1/${t}:${r}`
                }
                terminate() {}
            }
            class uv {
                constructor(e) {
                    this.Go = e.Go,
                    this.zo = e.zo
                }
                jo(e) {
                    this.Ho = e
                }
                Jo(e) {
                    this.Yo = e
                }
                Zo(e) {
                    this.Xo = e
                }
                onMessage(e) {
                    this.e_ = e
                }
                close() {
                    this.zo()
                }
                send(e) {
                    this.Go(e)
                }
                t_() {
                    this.Ho()
                }
                n_() {
                    this.Yo()
                }
                r_(e) {
                    this.Xo(e)
                }
                i_(e) {
                    this.e_(e)
                }
            }
            let uw = "WebChannelConnection";
            class ub extends uy {
                constructor(e) {
                    super(e),
                    this.forceLongPolling = e.forceLongPolling,
                    this.autoDetectLongPolling = e.autoDetectLongPolling,
                    this.useFetchStreams = e.useFetchStreams,
                    this.longPollingOptions = e.longPollingOptions
                }
                Ko(e, t, r, n, i) {
                    let s = rE();
                    return new Promise( (i, a) => {
                        let o = new p.XhrIo;
                        o.setWithCredentials(!0),
                        o.listenOnce(p.EventType.COMPLETE, () => {
                            try {
                                switch (o.getLastErrorCode()) {
                                case p.ErrorCode.NO_ERROR:
                                    let t = o.getResponseJson();
                                    y(uw, `XHR for RPC '${e}' ${s} received:`, JSON.stringify(t)),
                                    i(t);
                                    break;
                                case p.ErrorCode.TIMEOUT:
                                    y(uw, `RPC '${e}' ${s} timed out`),
                                    a(new sk(sD.DEADLINE_EXCEEDED,"Request time out"));
                                    break;
                                case p.ErrorCode.HTTP_ERROR:
                                    let r = o.getStatus();
                                    if (y(uw, `RPC '${e}' ${s} failed with status:`, r, "response text:", o.getResponseText()),
                                    r > 0) {
                                        let e = o.getResponseJson();
                                        Array.isArray(e) && (e = e[0]);
                                        let t = null == e ? void 0 : e.error;
                                        if (t && t.status && t.message) {
                                            let e = function(e) {
                                                let t = e.toLowerCase().replace(/_/g, "-");
                                                return Object.values(sD).indexOf(t) >= 0 ? t : sD.UNKNOWN
                                            }(t.status);
                                            a(new sk(e,t.message))
                                        } else
                                            a(new sk(sD.UNKNOWN,"Server responded with status " + o.getStatus()))
                                    } else
                                        a(new sk(sD.UNAVAILABLE,"Connection failed."));
                                    break;
                                default:
                                    E(9055, {
                                        s_: e,
                                        streamId: s,
                                        o_: o.getLastErrorCode(),
                                        __: o.getLastError()
                                    })
                                }
                            } finally {
                                y(uw, `RPC '${e}' ${s} completed.`)
                            }
                        }
                        );
                        let l = JSON.stringify(n);
                        y(uw, `RPC '${e}' ${s} sending request:`, n),
                        o.send(t, "POST", l, r, 15)
                    }
                    )
                }
                a_(e, t, r) {
                    let i = rE()
                      , s = [this.Lo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"]
                      , a = (0,
                    p.createWebChannelTransport)()
                      , o = (0,
                    p.getStatEventTarget)()
                      , l = {
                        httpSessionIdParam: "gsessionid",
                        initMessageHeaders: {},
                        messageUrlParams: {
                            database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
                        },
                        sendRawJson: !0,
                        supportsCrossDomainXhr: !0,
                        internalChannelParams: {
                            forwardChannelRequestTimeoutMs: 6e5
                        },
                        forceLongPolling: this.forceLongPolling,
                        detectBufferingProxy: this.autoDetectLongPolling
                    }
                      , u = this.longPollingOptions.timeoutSeconds;
                    void 0 !== u && (l.longPollingTimeout = Math.round(1e3 * u)),
                    this.useFetchStreams && (l.useFetchStreams = !0),
                    this.Uo(l.initMessageHeaders, t, r),
                    l.encodeInitMessageHeaders = !0;
                    let h = s.join("");
                    y(uw, `Creating RPC '${e}' stream ${i}: ${h}`, l);
                    let c = a.createWebChannel(h, l)
                      , d = !1
                      , f = !1
                      , g = new uv({
                        Go: t => {
                            f ? y(uw, `Not sending because RPC '${e}' stream ${i} is closed:`, t) : (d || (y(uw, `Opening RPC '${e}' stream ${i} transport.`),
                            c.open(),
                            d = !0),
                            y(uw, `RPC '${e}' stream ${i} sending:`, t),
                            c.send(t))
                        }
                        ,
                        zo: () => c.close()
                    })
                      , m = (e, t, r) => {
                        e.listen(t, e => {
                            try {
                                r(e)
                            } catch (e) {
                                setTimeout( () => {
                                    throw e
                                }
                                , 0)
                            }
                        }
                        )
                    }
                    ;
                    return m(c, p.WebChannel.EventType.OPEN, () => {
                        f || (y(uw, `RPC '${e}' stream ${i} transport opened.`),
                        g.t_())
                    }
                    ),
                    m(c, p.WebChannel.EventType.CLOSE, () => {
                        f || (f = !0,
                        y(uw, `RPC '${e}' stream ${i} transport closed`),
                        g.r_())
                    }
                    ),
                    m(c, p.WebChannel.EventType.ERROR, t => {
                        f || (f = !0,
                        w(uw, `RPC '${e}' stream ${i} transport errored. Name:`, t.name, "Message:", t.message),
                        g.r_(new sk(sD.UNAVAILABLE,"The operation could not be completed")))
                    }
                    ),
                    m(c, p.WebChannel.EventType.MESSAGE, t => {
                        var r;
                        if (!f) {
                            let s = t.data[0];
                            _(!!s, 16349);
                            let a = (null == s ? void 0 : s.error) || (null == (r = s[0]) ? void 0 : r.error);
                            if (a) {
                                y(uw, `RPC '${e}' stream ${i} received error:`, a);
                                let t = a.status
                                  , r = function(e) {
                                    let t = n[e];
                                    if (void 0 !== t)
                                        return tu(t)
                                }(t)
                                  , s = a.message;
                                void 0 === r && (r = sD.INTERNAL,
                                s = "Unknown error status: " + t + " with message " + a.message),
                                f = !0,
                                g.r_(new sk(r,s)),
                                c.close()
                            } else
                                y(uw, `RPC '${e}' stream ${i} received:`, s),
                                g.i_(s)
                        }
                    }
                    ),
                    m(o, p.Event.STAT_EVENT, t => {
                        t.stat === p.Stat.PROXY ? y(uw, `RPC '${e}' stream ${i} detected buffering proxy`) : t.stat === p.Stat.NOPROXY && y(uw, `RPC '${e}' stream ${i} detected no buffering proxy`)
                    }
                    ),
                    setTimeout( () => {
                        g.n_()
                    }
                    , 0),
                    g
                }
            }
            function rI() {
                return "undefined" != typeof window ? window : null
            }
            function r_() {
                return "undefined" != typeof document ? document : null
            }
            function rT(e) {
                return new ll(e,!0)
            }
            class uE {
                constructor(e, t, r=1e3, n=1.5, i=6e4) {
                    this.bi = e,
                    this.timerId = t,
                    this.u_ = r,
                    this.c_ = n,
                    this.l_ = i,
                    this.h_ = 0,
                    this.P_ = null,
                    this.T_ = Date.now(),
                    this.reset()
                }
                reset() {
                    this.h_ = 0
                }
                I_() {
                    this.h_ = this.l_
                }
                E_(e) {
                    this.cancel();
                    let t = Math.floor(this.h_ + this.d_())
                      , r = Math.max(0, Date.now() - this.T_)
                      , n = Math.max(0, t - r);
                    n > 0 && y("ExponentialBackoff", `Backing off for ${n} ms (base delay: ${this.h_} ms, delay with jitter: ${t} ms, last attempt: ${r} ms ago)`),
                    this.P_ = this.bi.enqueueAfterDelay(this.timerId, n, () => (this.T_ = Date.now(),
                    e())),
                    this.h_ *= this.c_,
                    this.h_ < this.u_ && (this.h_ = this.u_),
                    this.h_ > this.l_ && (this.h_ = this.l_)
                }
                A_() {
                    null !== this.P_ && (this.P_.skipDelay(),
                    this.P_ = null)
                }
                cancel() {
                    null !== this.P_ && (this.P_.cancel(),
                    this.P_ = null)
                }
                d_() {
                    return (Math.random() - .5) * this.h_
                }
            }
            let uI = "PersistentStream";
            class u_ {
                constructor(e, t, r, n, i, s, a, o) {
                    this.bi = e,
                    this.R_ = r,
                    this.V_ = n,
                    this.connection = i,
                    this.authCredentialsProvider = s,
                    this.appCheckCredentialsProvider = a,
                    this.listener = o,
                    this.state = 0,
                    this.m_ = 0,
                    this.f_ = null,
                    this.g_ = null,
                    this.stream = null,
                    this.p_ = 0,
                    this.y_ = new uE(e,t)
                }
                w_() {
                    return 1 === this.state || 5 === this.state || this.b_()
                }
                b_() {
                    return 2 === this.state || 3 === this.state
                }
                start() {
                    this.p_ = 0,
                    4 !== this.state ? this.auth() : this.S_()
                }
                async stop() {
                    this.w_() && await this.close(0)
                }
                D_() {
                    this.state = 0,
                    this.y_.reset()
                }
                v_() {
                    this.b_() && null === this.f_ && (this.f_ = this.bi.enqueueAfterDelay(this.R_, 6e4, () => this.C_()))
                }
                F_(e) {
                    this.M_(),
                    this.stream.send(e)
                }
                async C_() {
                    if (this.b_())
                        return this.close(0)
                }
                M_() {
                    this.f_ && (this.f_.cancel(),
                    this.f_ = null)
                }
                x_() {
                    this.g_ && (this.g_.cancel(),
                    this.g_ = null)
                }
                async close(e, t) {
                    this.M_(),
                    this.x_(),
                    this.y_.cancel(),
                    this.m_++,
                    4 !== e ? this.y_.reset() : t && t.code === sD.RESOURCE_EXHAUSTED ? (v(t.toString()),
                    v("Using maximum backoff delay to prevent overloading the backend."),
                    this.y_.I_()) : t && t.code === sD.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(),
                    this.appCheckCredentialsProvider.invalidateToken()),
                    null !== this.stream && (this.O_(),
                    this.stream.close(),
                    this.stream = null),
                    this.state = e,
                    await this.listener.Zo(t)
                }
                O_() {}
                auth() {
                    this.state = 1;
                    let e = this.N_(this.m_)
                      , t = this.m_;
                    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then( ([e,r]) => {
                        this.m_ === t && this.B_(e, r)
                    }
                    , t => {
                        e( () => {
                            let e = new sk(sD.UNKNOWN,"Fetching auth token failed: " + t.message);
                            return this.L_(e)
                        }
                        )
                    }
                    )
                }
                B_(e, t) {
                    let r = this.N_(this.m_);
                    this.stream = this.k_(e, t),
                    this.stream.jo( () => {
                        r( () => this.listener.jo())
                    }
                    ),
                    this.stream.Jo( () => {
                        r( () => (this.state = 2,
                        this.g_ = this.bi.enqueueAfterDelay(this.V_, 1e4, () => (this.b_() && (this.state = 3),
                        Promise.resolve())),
                        this.listener.Jo()))
                    }
                    ),
                    this.stream.Zo(e => {
                        r( () => this.L_(e))
                    }
                    ),
                    this.stream.onMessage(e => {
                        r( () => 1 == ++this.p_ ? this.q_(e) : this.onNext(e))
                    }
                    )
                }
                S_() {
                    this.state = 5,
                    this.y_.E_(async () => {
                        this.state = 0,
                        this.start()
                    }
                    )
                }
                L_(e) {
                    return y(uI, `close with error: ${e}`),
                    this.stream = null,
                    this.close(4, e)
                }
                N_(e) {
                    return t => {
                        this.bi.enqueueAndForget( () => this.m_ === e ? t() : (y(uI, "stream callback skipped by getCloseGuardedDispatcher."),
                        Promise.resolve()))
                    }
                }
            }
            class uT extends u_ {
                constructor(e, t, r, n, i, s) {
                    super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, r, n, s),
                    this.serializer = i
                }
                k_(e, t) {
                    return this.connection.a_("Listen", e, t)
                }
                q_(e) {
                    return this.onNext(e)
                }
                onNext(e) {
                    this.y_.reset();
                    let t = function(e, t) {
                        let r;
                        if ("targetChange"in t) {
                            var n, i;
                            t.targetChange;
                            let s = "NO_CHANGE" === (n = t.targetChange.targetChangeType || "NO_CHANGE") ? 0 : "ADD" === n ? 1 : "REMOVE" === n ? 2 : "CURRENT" === n ? 3 : "RESET" === n ? 4 : E(39313, {
                                state: n
                            })
                              , a = t.targetChange.targetIds || []
                              , o = (i = t.targetChange.resumeToken,
                            e.useProto3Json ? (_(void 0 === i || "string" == typeof i, 58123),
                            or.fromBase64String(i || "")) : (_(void 0 === i || i instanceof l.Buffer || i instanceof Uint8Array, 16193),
                            or.fromUint8Array(i || new Uint8Array)))
                              , u = t.targetChange.cause;
                            r = new lr(s,a,o,u && new sk(void 0 === u.code ? sD.UNKNOWN : tu(u.code),u.message || "") || null)
                        } else if ("documentChange"in t) {
                            t.documentChange;
                            let n = t.documentChange;
                            n.document,
                            n.document.name,
                            n.document.updateTime;
                            let i = tI(e, n.document.name)
                              , s = ty(n.document.updateTime)
                              , a = n.document.createTime ? ty(n.document.createTime) : sz.min()
                              , o = new ov({
                                mapValue: {
                                    fields: n.document.fields
                                }
                            })
                              , l = ow.newFoundDocument(i, s, a, o);
                            r = new le(n.targetIds || [],n.removedTargetIds || [],l.key,l)
                        } else if ("documentDelete"in t) {
                            t.documentDelete;
                            let n = t.documentDelete;
                            n.document;
                            let i = tI(e, n.document)
                              , s = n.readTime ? ty(n.readTime) : sz.min()
                              , a = ow.newNoDocument(i, s);
                            r = new le([],n.removedTargetIds || [],a.key,a)
                        } else if ("documentRemove"in t) {
                            t.documentRemove;
                            let n = t.documentRemove;
                            n.document;
                            let i = tI(e, n.document);
                            r = new le([],n.removedTargetIds || [],i,null)
                        } else {
                            if (!("filter"in t))
                                return E(11601, {
                                    Vt: t
                                });
                            {
                                t.filter;
                                let e = t.filter;
                                e.targetId;
                                let {count: n=0, unchangedNames: i} = e
                                  , s = new o6(n,i);
                                r = new lt(e.targetId,s)
                            }
                        }
                        return r
                    }(this.serializer, e)
                      , r = function(e) {
                        if (!("targetChange"in e))
                            return sz.min();
                        let t = e.targetChange;
                        return t.targetIds && t.targetIds.length ? sz.min() : t.readTime ? ty(t.readTime) : sz.min()
                    }(e);
                    return this.listener.Q_(t, r)
                }
                U_(e) {
                    let t = {};
                    t.database = tS(this.serializer),
                    t.addTarget = function(e, t) {
                        let r, n = t.target;
                        if ((r = eM(n) ? {
                            documents: tN(e, n)
                        } : {
                            query: tO(e, n).gt
                        }).targetId = t.targetId,
                        t.resumeToken.approximateByteSize() > 0) {
                            r.resumeToken = tm(e, t.resumeToken);
                            let n = tp(e, t.expectedCount);
                            null !== n && (r.expectedCount = n)
                        } else if (t.snapshotVersion.compareTo(sz.min()) > 0) {
                            r.readTime = tg(e, t.snapshotVersion.toTimestamp());
                            let n = tp(e, t.expectedCount);
                            null !== n && (r.expectedCount = n)
                        }
                        return r
                    }(this.serializer, e);
                    let r = function(e, t) {
                        let r = function(e) {
                            switch (e) {
                            case "TargetPurposeListen":
                                return null;
                            case "TargetPurposeExistenceFilterMismatch":
                                return "existence-filter-mismatch";
                            case "TargetPurposeExistenceFilterMismatchBloom":
                                return "existence-filter-mismatch-bloom";
                            case "TargetPurposeLimboResolution":
                                return "limbo-document";
                            default:
                                return E(28987, {
                                    purpose: e
                                })
                            }
                        }(t.purpose);
                        return null == r ? null : {
                            "goog-listen-tags": r
                        }
                    }(this.serializer, e);
                    r && (t.labels = r),
                    this.F_(t)
                }
                K_(e) {
                    let t = {};
                    t.database = tS(this.serializer),
                    t.removeTarget = e,
                    this.F_(t)
                }
            }
            class uS extends u_ {
                constructor(e, t, r, n, i, s) {
                    super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, r, n, s),
                    this.serializer = i
                }
                get W_() {
                    return this.p_ > 0
                }
                start() {
                    this.lastStreamToken = void 0,
                    super.start()
                }
                O_() {
                    this.W_ && this.G_([])
                }
                k_(e, t) {
                    return this.connection.a_("Write", e, t)
                }
                q_(e) {
                    return _(!!e.streamToken, 31322),
                    this.lastStreamToken = e.streamToken,
                    _(!e.writeResults || 0 === e.writeResults.length, 55816),
                    this.listener.z_()
                }
                onNext(e) {
                    var t, r;
                    _(!!e.streamToken, 12678),
                    this.lastStreamToken = e.streamToken,
                    this.y_.reset();
                    let n = (t = e.writeResults,
                    r = e.commitTime,
                    t && t.length > 0 ? (_(void 0 !== r, 14353),
                    t.map(e => {
                        let t;
                        return (t = e.updateTime ? ty(e.updateTime) : ty(r)).isEqual(sz.min()) && (t = ty(r)),
                        new o$(t,e.transformResults || [])
                    }
                    )) : [])
                      , i = ty(e.commitTime);
                    return this.listener.j_(i, n)
                }
                H_() {
                    let e = {};
                    e.database = tS(this.serializer),
                    this.F_(e)
                }
                G_(e) {
                    let t = {
                        streamToken: this.lastStreamToken,
                        writes: e.map(e => tD(this.serializer, e))
                    };
                    this.F_(t)
                }
            }
            class uC {
            }
            class ux extends uC {
                constructor(e, t, r, n) {
                    super(),
                    this.authCredentials = e,
                    this.appCheckCredentials = t,
                    this.connection = r,
                    this.serializer = n,
                    this.J_ = !1
                }
                Y_() {
                    if (this.J_)
                        throw new sk(sD.FAILED_PRECONDITION,"The client has already been terminated.")
                }
                Qo(e, t, r, n) {
                    return this.Y_(),
                    Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then( ([i,s]) => this.connection.Qo(e, tw(t, r), n, i, s)).catch(e => {
                        throw "FirebaseError" === e.name ? (e.code === sD.UNAUTHENTICATED && (this.authCredentials.invalidateToken(),
                        this.appCheckCredentials.invalidateToken()),
                        e) : new sk(sD.UNKNOWN,e.toString())
                    }
                    )
                }
                Wo(e, t, r, n, i) {
                    return this.Y_(),
                    Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then( ([s,a]) => this.connection.Wo(e, tw(t, r), n, s, a, i)).catch(e => {
                        throw "FirebaseError" === e.name ? (e.code === sD.UNAUTHENTICATED && (this.authCredentials.invalidateToken(),
                        this.appCheckCredentials.invalidateToken()),
                        e) : new sk(sD.UNKNOWN,e.toString())
                    }
                    )
                }
                terminate() {
                    this.J_ = !0,
                    this.connection.terminate()
                }
            }
            class uA {
                constructor(e, t) {
                    this.asyncQueue = e,
                    this.onlineStateHandler = t,
                    this.state = "Unknown",
                    this.Z_ = 0,
                    this.X_ = null,
                    this.ea = !0
                }
                ta() {
                    0 === this.Z_ && (this.na("Unknown"),
                    this.X_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.X_ = null,
                    this.ra("Backend didn't respond within 10 seconds."),
                    this.na("Offline"),
                    Promise.resolve())))
                }
                ia(e) {
                    "Online" === this.state ? this.na("Unknown") : (this.Z_++,
                    this.Z_ >= 1 && (this.sa(),
                    this.ra(`Connection failed 1 times. Most recent error: ${e.toString()}`),
                    this.na("Offline")))
                }
                set(e) {
                    this.sa(),
                    this.Z_ = 0,
                    "Online" === e && (this.ea = !1),
                    this.na(e)
                }
                na(e) {
                    e !== this.state && (this.state = e,
                    this.onlineStateHandler(e))
                }
                ra(e) {
                    let t = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
                    this.ea ? (v(t),
                    this.ea = !1) : y("OnlineStateTracker", t)
                }
                sa() {
                    null !== this.X_ && (this.X_.cancel(),
                    this.X_ = null)
                }
            }
            let uD = "RemoteStore";
            class uk {
                constructor(e, t, r, n, i) {
                    this.localStore = e,
                    this.datastore = t,
                    this.asyncQueue = r,
                    this.remoteSyncer = {},
                    this.oa = [],
                    this._a = new Map,
                    this.aa = new Set,
                    this.ua = [],
                    this.ca = i,
                    this.ca.vo(e => {
                        r.enqueueAndForget(async () => {
                            rR(this) && (y(uD, "Restarting streams for network reachability change."),
                            await async function(e) {
                                e.aa.add(4),
                                await rC(e),
                                e.la.set("Unknown"),
                                e.aa.delete(4),
                                await rS(e)
                            }(this))
                        }
                        )
                    }
                    ),
                    this.la = new uA(r,n)
                }
            }
            async function rS(e) {
                if (rR(e))
                    for (let t of e.ua)
                        await t(!0)
            }
            async function rC(e) {
                for (let t of e.ua)
                    await t(!1)
            }
            function rx(e, t) {
                e._a.has(t.targetId) || (e._a.set(t.targetId, t),
                rO(e) ? rN(e) : rW(e).b_() && rD(e, t))
            }
            function rA(e, t) {
                let r = rW(e);
                e._a.delete(t),
                r.b_() && rk(e, t),
                0 === e._a.size && (r.b_() ? r.v_() : rR(e) && e.la.set("Unknown"))
            }
            function rD(e, t) {
                if (e.ha.Ke(t.targetId),
                t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(sz.min()) > 0) {
                    let r = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;
                    t = t.withExpectedCount(r)
                }
                rW(e).U_(t)
            }
            function rk(e, t) {
                e.ha.Ke(t),
                rW(e).K_(t)
            }
            function rN(e) {
                e.ha = new li({
                    getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t),
                    Rt: t => e._a.get(t) || null,
                    Pt: () => e.datastore.serializer.databaseId
                }),
                rW(e).start(),
                e.la.ta()
            }
            function rO(e) {
                return rR(e) && !rW(e).w_() && e._a.size > 0
            }
            function rR(e) {
                return 0 === e.aa.size
            }
            async function rM(e) {
                e.la.set("Online")
            }
            async function rP(e) {
                e._a.forEach( (t, r) => {
                    rD(e, t)
                }
                )
            }
            async function rL(e, t) {
                e.ha = void 0,
                rO(e) ? (e.la.ia(t),
                rN(e)) : e.la.set("Unknown")
            }
            async function rF(e, t, r) {
                if (e.la.set("Online"),
                t instanceof lr && 2 === t.state && t.cause)
                    try {
                        await async function(e, t) {
                            let r = t.cause;
                            for (let n of t.targetIds)
                                e._a.has(n) && (await e.remoteSyncer.rejectListen(n, r),
                                e._a.delete(n),
                                e.ha.removeTarget(n))
                        }(e, t)
                    } catch (r) {
                        y(uD, "Failed to remove targets %s: %s ", t.targetIds.join(","), r),
                        await rB(e, r)
                    }
                else if (t instanceof le ? e.ha.Xe(t) : t instanceof lt ? e.ha.ot(t) : e.ha.nt(t),
                !r.isEqual(sz.min()))
                    try {
                        let t = await rl(e.localStore);
                        r.compareTo(t) >= 0 && await function(e, t) {
                            let r = e.ha.It(t);
                            return r.targetChanges.forEach( (r, n) => {
                                if (r.resumeToken.approximateByteSize() > 0) {
                                    let i = e._a.get(n);
                                    i && e._a.set(n, i.withResumeToken(r.resumeToken, t))
                                }
                            }
                            ),
                            r.targetMismatches.forEach( (t, r) => {
                                let n = e._a.get(t);
                                if (!n)
                                    return;
                                e._a.set(t, n.withResumeToken(or.EMPTY_BYTE_STRING, n.snapshotVersion)),
                                rk(e, t);
                                let i = new lu(n.target,t,r,n.sequenceNumber);
                                rD(e, i)
                            }
                            ),
                            e.remoteSyncer.applyRemoteEvent(r)
                        }(e, r)
                    } catch (t) {
                        y(uD, "Failed to raise snapshot:", t),
                        await rB(e, t)
                    }
            }
            async function rB(e, t, r) {
                if (!B(t))
                    throw t;
                e.aa.add(1),
                await rC(e),
                e.la.set("Offline"),
                r || (r = () => rl(e.localStore)),
                e.asyncQueue.enqueueRetryable(async () => {
                    y(uD, "Retrying IndexedDB access"),
                    await r(),
                    e.aa.delete(1),
                    await rS(e)
                }
                )
            }
            function rV(e, t) {
                return t().catch(r => rB(e, r, t))
            }
            async function rU(e) {
                var t;
                let r = rJ(e)
                  , n = e.oa.length > 0 ? e.oa[e.oa.length - 1].batchId : -1;
                for (; rR(t = e) && t.oa.length < 10; )
                    try {
                        let t = await function(e, t) {
                            return e.persistence.runTransaction("Get next mutation batch", "readonly", r => (void 0 === t && (t = -1),
                            e.mutationQueue.getNextMutationBatchAfterBatchId(r, t)))
                        }(e.localStore, n);
                        if (null === t) {
                            0 === e.oa.length && r.v_();
                            break
                        }
                        n = t.batchId,
                        function(e, t) {
                            e.oa.push(t);
                            let r = rJ(e);
                            r.b_() && r.W_ && r.G_(t.mutations)
                        }(e, t)
                    } catch (t) {
                        await rB(e, t)
                    }
                rq(e) && rj(e)
            }
            function rq(e) {
                return rR(e) && !rJ(e).w_() && e.oa.length > 0
            }
            function rj(e) {
                rJ(e).start()
            }
            async function rz(e) {
                rJ(e).H_()
            }
            async function rQ(e) {
                let t = rJ(e);
                for (let r of e.oa)
                    t.G_(r.mutations)
            }
            async function rK(e, t, r) {
                let n = e.oa.shift()
                  , i = o0.from(n, t, r);
                await rV(e, () => e.remoteSyncer.applySuccessfulWrite(i)),
                await rU(e)
            }
            async function r$(e, t) {
                t && rJ(e).W_ && await async function(e, t) {
                    var r;
                    if (tl(r = t.code) && r !== sD.ABORTED) {
                        let r = e.oa.shift();
                        rJ(e).D_(),
                        await rV(e, () => e.remoteSyncer.rejectFailedWrite(r.batchId, t)),
                        await rU(e)
                    }
                }(e, t),
                rq(e) && rj(e)
            }
            async function rG(e, t) {
                e.asyncQueue.verifyOperationInProgress(),
                y(uD, "RemoteStore received new credentials");
                let r = rR(e);
                e.aa.add(3),
                await rC(e),
                r && e.la.set("Unknown"),
                await e.remoteSyncer.handleCredentialChange(t),
                e.aa.delete(3),
                await rS(e)
            }
            async function rH(e, t) {
                t ? (e.aa.delete(2),
                await rS(e)) : t || (e.aa.add(2),
                await rC(e),
                e.la.set("Unknown"))
            }
            function rW(e) {
                var t, r, n;
                return e.Pa || (t = e.datastore,
                r = e.asyncQueue,
                n = {
                    jo: rM.bind(null, e),
                    Jo: rP.bind(null, e),
                    Zo: rL.bind(null, e),
                    Q_: rF.bind(null, e)
                },
                t.Y_(),
                e.Pa = new uT(r,t.connection,t.authCredentials,t.appCheckCredentials,t.serializer,n),
                e.ua.push(async t => {
                    t ? (e.Pa.D_(),
                    rO(e) ? rN(e) : e.la.set("Unknown")) : (await e.Pa.stop(),
                    e.ha = void 0)
                }
                )),
                e.Pa
            }
            function rJ(e) {
                var t, r, n;
                return e.Ta || (t = e.datastore,
                r = e.asyncQueue,
                n = {
                    jo: () => Promise.resolve(),
                    Jo: rz.bind(null, e),
                    Zo: r$.bind(null, e),
                    z_: rQ.bind(null, e),
                    j_: rK.bind(null, e)
                },
                t.Y_(),
                e.Ta = new uS(r,t.connection,t.authCredentials,t.appCheckCredentials,t.serializer,n),
                e.ua.push(async t => {
                    t ? (e.Ta.D_(),
                    await rU(e)) : (await e.Ta.stop(),
                    e.oa.length > 0 && (y(uD, `Stopping write stream with ${e.oa.length} pending writes`),
                    e.oa = []))
                }
                )),
                e.Ta
            }
            class uN {
                constructor(e, t, r, n, i) {
                    this.asyncQueue = e,
                    this.timerId = t,
                    this.targetTimeMs = r,
                    this.op = n,
                    this.removalCallback = i,
                    this.deferred = new sN,
                    this.then = this.deferred.promise.then.bind(this.deferred.promise),
                    this.deferred.promise.catch(e => {}
                    )
                }
                get promise() {
                    return this.deferred.promise
                }
                static createAndSchedule(e, t, r, n, i) {
                    let s = new uN(e,t,Date.now() + r,n,i);
                    return s.start(r),
                    s
                }
                start(e) {
                    this.timerHandle = setTimeout( () => this.handleDelayElapsed(), e)
                }
                skipDelay() {
                    return this.handleDelayElapsed()
                }
                cancel(e) {
                    null !== this.timerHandle && (this.clearTimeout(),
                    this.deferred.reject(new sk(sD.CANCELLED,"Operation cancelled" + (e ? ": " + e : ""))))
                }
                handleDelayElapsed() {
                    this.asyncQueue.enqueueAndForget( () => null !== this.timerHandle ? (this.clearTimeout(),
                    this.op().then(e => this.deferred.resolve(e))) : Promise.resolve())
                }
                clearTimeout() {
                    null !== this.timerHandle && (this.removalCallback(this),
                    clearTimeout(this.timerHandle),
                    this.timerHandle = null)
                }
            }
            function rY(e, t) {
                if (v("AsyncQueue", `${t}: ${e}`),
                B(e))
                    return new sk(sD.UNAVAILABLE,`${t}: ${e}`);
                throw e
            }
            class uO {
                static emptySet(e) {
                    return new uO(e.comparator)
                }
                constructor(e) {
                    this.comparator = e ? (t, r) => e(t, r) || sW.comparator(t.key, r.key) : (e, t) => sW.comparator(e.key, t.key),
                    this.keyedMap = eZ(),
                    this.sortedSet = new a5(this.comparator)
                }
                has(e) {
                    return null != this.keyedMap.get(e)
                }
                get(e) {
                    return this.keyedMap.get(e)
                }
                first() {
                    return this.sortedSet.minKey()
                }
                last() {
                    return this.sortedSet.maxKey()
                }
                isEmpty() {
                    return this.sortedSet.isEmpty()
                }
                indexOf(e) {
                    let t = this.keyedMap.get(e);
                    return t ? this.sortedSet.indexOf(t) : -1
                }
                get size() {
                    return this.sortedSet.size
                }
                forEach(e) {
                    this.sortedSet.inorderTraversal( (t, r) => (e(t),
                    !1))
                }
                add(e) {
                    let t = this.delete(e.key);
                    return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null))
                }
                delete(e) {
                    let t = this.get(e);
                    return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this
                }
                isEqual(e) {
                    if (!(e instanceof uO) || this.size !== e.size)
                        return !1;
                    let t = this.sortedSet.getIterator()
                      , r = e.sortedSet.getIterator();
                    for (; t.hasNext(); ) {
                        let e = t.getNext().key
                          , n = r.getNext().key;
                        if (!e.isEqual(n))
                            return !1
                    }
                    return !0
                }
                toString() {
                    let e = [];
                    return this.forEach(t => {
                        e.push(t.toString())
                    }
                    ),
                    0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)"
                }
                copy(e, t) {
                    let r = new uO;
                    return r.comparator = this.comparator,
                    r.keyedMap = e,
                    r.sortedSet = t,
                    r
                }
            }
            class uR {
                constructor() {
                    this.Ia = new a5(sW.comparator)
                }
                track(e) {
                    let t = e.doc.key
                      , r = this.Ia.get(t);
                    r ? 0 !== e.type && 3 === r.type ? this.Ia = this.Ia.insert(t, e) : 3 === e.type && 1 !== r.type ? this.Ia = this.Ia.insert(t, {
                        type: r.type,
                        doc: e.doc
                    }) : 2 === e.type && 2 === r.type ? this.Ia = this.Ia.insert(t, {
                        type: 2,
                        doc: e.doc
                    }) : 2 === e.type && 0 === r.type ? this.Ia = this.Ia.insert(t, {
                        type: 0,
                        doc: e.doc
                    }) : 1 === e.type && 0 === r.type ? this.Ia = this.Ia.remove(t) : 1 === e.type && 2 === r.type ? this.Ia = this.Ia.insert(t, {
                        type: 1,
                        doc: r.doc
                    }) : 0 === e.type && 1 === r.type ? this.Ia = this.Ia.insert(t, {
                        type: 2,
                        doc: e.doc
                    }) : E(63341, {
                        Vt: e,
                        Ea: r
                    }) : this.Ia = this.Ia.insert(t, e)
                }
                da() {
                    let e = [];
                    return this.Ia.inorderTraversal( (t, r) => {
                        e.push(r)
                    }
                    ),
                    e
                }
            }
            class uM {
                constructor(e, t, r, n, i, s, a, o, l) {
                    this.query = e,
                    this.docs = t,
                    this.oldDocs = r,
                    this.docChanges = n,
                    this.mutatedKeys = i,
                    this.fromCache = s,
                    this.syncStateChanged = a,
                    this.excludesMetadataChanges = o,
                    this.hasCachedResults = l
                }
                static fromInitialDocuments(e, t, r, n, i) {
                    let s = [];
                    return t.forEach(e => {
                        s.push({
                            type: 0,
                            doc: e
                        })
                    }
                    ),
                    new uM(e,t,uO.emptySet(t),s,r,n,!0,!1,i)
                }
                get hasPendingWrites() {
                    return !this.mutatedKeys.isEmpty()
                }
                isEqual(e) {
                    if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && eG(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs)))
                        return !1;
                    let t = this.docChanges
                      , r = e.docChanges;
                    if (t.length !== r.length)
                        return !1;
                    for (let e = 0; e < t.length; e++)
                        if (t[e].type !== r[e].type || !t[e].doc.isEqual(r[e].doc))
                            return !1;
                    return !0
                }
            }
            class uP {
                constructor() {
                    this.Aa = void 0,
                    this.Ra = []
                }
                Va() {
                    return this.Ra.some(e => e.ma())
                }
            }
            class uL {
                constructor() {
                    this.queries = rX(),
                    this.onlineState = "Unknown",
                    this.fa = new Set
                }
                terminate() {
                    !function(e, t) {
                        let r = e.queries;
                        e.queries = rX(),
                        r.forEach( (e, r) => {
                            for (let e of r.Ra)
                                e.onError(t)
                        }
                        )
                    }(this, new sk(sD.ABORTED,"Firestore shutting down"))
                }
            }
            function rX() {
                return new oM(e => eH(e),eG)
            }
            async function rZ(e, t) {
                let r = 3
                  , n = t.query
                  , i = e.queries.get(n);
                i ? !i.Va() && t.ma() && (r = 2) : (i = new uP,
                r = +!t.ma());
                try {
                    switch (r) {
                    case 0:
                        i.Aa = await e.onListen(n, !0);
                        break;
                    case 1:
                        i.Aa = await e.onListen(n, !1);
                        break;
                    case 2:
                        await e.onFirstRemoteStoreListen(n)
                    }
                } catch (r) {
                    let e = rY(r, `Initialization of query '${eW(t.query)}' failed`);
                    return void t.onError(e)
                }
                e.queries.set(n, i),
                i.Ra.push(t),
                t.ga(e.onlineState),
                i.Aa && t.pa(i.Aa) && r6(e)
            }
            async function r0(e, t) {
                let r = t.query
                  , n = 3
                  , i = e.queries.get(r);
                if (i) {
                    let e = i.Ra.indexOf(t);
                    e >= 0 && (i.Ra.splice(e, 1),
                    0 === i.Ra.length ? n = +!t.ma() : !i.Va() && t.ma() && (n = 2))
                }
                switch (n) {
                case 0:
                    return e.queries.delete(r),
                    e.onUnlisten(r, !0);
                case 1:
                    return e.queries.delete(r),
                    e.onUnlisten(r, !1);
                case 2:
                    return e.onLastRemoteStoreUnlisten(r);
                default:
                    return
                }
            }
            function r1(e, t) {
                let r = !1;
                for (let n of t) {
                    let t = n.query
                      , i = e.queries.get(t);
                    if (i) {
                        for (let e of i.Ra)
                            e.pa(n) && (r = !0);
                        i.Aa = n
                    }
                }
                r && r6(e)
            }
            function r2(e, t, r) {
                let n = e.queries.get(t);
                if (n)
                    for (let e of n.Ra)
                        e.onError(r);
                e.queries.delete(t)
            }
            function r6(e) {
                e.fa.forEach(e => {
                    e.next()
                }
                )
            }
            (a = s || (s = {})).ya = "default",
            a.Cache = "cache";
            class uF {
                constructor(e, t, r) {
                    this.query = e,
                    this.wa = t,
                    this.ba = !1,
                    this.Sa = null,
                    this.onlineState = "Unknown",
                    this.options = r || {}
                }
                pa(e) {
                    if (!this.options.includeMetadataChanges) {
                        let t = [];
                        for (let r of e.docChanges)
                            3 !== r.type && t.push(r);
                        e = new uM(e.query,e.docs,e.oldDocs,t,e.mutatedKeys,e.fromCache,e.syncStateChanged,!0,e.hasCachedResults)
                    }
                    let t = !1;
                    return this.ba ? this.Da(e) && (this.wa.next(e),
                    t = !0) : this.va(e, this.onlineState) && (this.Ca(e),
                    t = !0),
                    this.Sa = e,
                    t
                }
                onError(e) {
                    this.wa.error(e)
                }
                ga(e) {
                    this.onlineState = e;
                    let t = !1;
                    return this.Sa && !this.ba && this.va(this.Sa, e) && (this.Ca(this.Sa),
                    t = !0),
                    t
                }
                va(e, t) {
                    return !(e.fromCache && this.ma()) || (!this.options.Fa || "Offline" === t) && (!e.docs.isEmpty() || e.hasCachedResults || "Offline" === t)
                }
                Da(e) {
                    if (e.docChanges.length > 0)
                        return !0;
                    let t = this.Sa && this.Sa.hasPendingWrites !== e.hasPendingWrites;
                    return !(!e.syncStateChanged && !t) && !0 === this.options.includeMetadataChanges
                }
                Ca(e) {
                    e = uM.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults),
                    this.ba = !0,
                    this.wa.next(e)
                }
                ma() {
                    return this.options.source !== s.Cache
                }
            }
            class uB {
                constructor(e, t) {
                    this.Ma = e,
                    this.byteLength = t
                }
                xa() {
                    return "metadata"in this.Ma
                }
            }
            class uV {
                constructor(e) {
                    this.serializer = e
                }
                Bs(e) {
                    return tI(this.serializer, e)
                }
                Ls(e) {
                    return e.metadata.exists ? tA(this.serializer, e.document, !1) : ow.newNoDocument(this.Bs(e.metadata.name), this.ks(e.metadata.readTime))
                }
                ks(e) {
                    return ty(e)
                }
            }
            class uU {
                constructor(e, t, r) {
                    this.Oa = e,
                    this.localStore = t,
                    this.serializer = r,
                    this.queries = [],
                    this.documents = [],
                    this.collectionGroups = new Set,
                    this.progress = r3(e)
                }
                Na(e) {
                    this.progress.bytesLoaded += e.byteLength;
                    let t = this.progress.documentsLoaded;
                    if (e.Ma.namedQuery)
                        this.queries.push(e.Ma.namedQuery);
                    else if (e.Ma.documentMetadata) {
                        this.documents.push({
                            metadata: e.Ma.documentMetadata
                        }),
                        e.Ma.documentMetadata.exists || ++t;
                        let r = s$.fromString(e.Ma.documentMetadata.name);
                        this.collectionGroups.add(r.get(r.length - 2))
                    } else
                        e.Ma.document && (this.documents[this.documents.length - 1].document = e.Ma.document,
                        ++t);
                    return t !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = t,
                    Object.assign({}, this.progress)) : null
                }
                Ba(e) {
                    let t = new Map
                      , r = new uV(this.serializer);
                    for (let n of e)
                        if (n.metadata.queries) {
                            let e = r.Bs(n.metadata.name);
                            for (let r of n.metadata.queries) {
                                let n = (t.get(r) || e2()).add(e);
                                t.set(r, n)
                            }
                        }
                    return t
                }
                async complete() {
                    let e = await rm(this.localStore, new uV(this.serializer), this.documents, this.Oa.id)
                      , t = this.Ba(this.documents);
                    for (let e of this.queries)
                        await ry(this.localStore, e, t.get(e.name));
                    return this.progress.taskState = "Success",
                    {
                        progress: this.progress,
                        La: this.collectionGroups,
                        ka: e
                    }
                }
            }
            function r3(e) {
                return {
                    taskState: "Running",
                    documentsLoaded: 0,
                    bytesLoaded: 0,
                    totalDocuments: e.totalDocuments,
                    totalBytes: e.totalBytes
                }
            }
            class uq {
                constructor(e) {
                    this.key = e
                }
            }
            class uj {
                constructor(e) {
                    this.key = e
                }
            }
            class uz {
                constructor(e, t) {
                    this.query = e,
                    this.qa = t,
                    this.Qa = null,
                    this.hasCachedResults = !1,
                    this.current = !1,
                    this.$a = e2(),
                    this.mutatedKeys = e2(),
                    this.Ua = eX(e),
                    this.Ka = new uO(this.Ua)
                }
                get Wa() {
                    return this.qa
                }
                Ga(e, t) {
                    let r = t ? t.za : new uR
                      , n = t ? t.Ka : this.Ka
                      , i = t ? t.mutatedKeys : this.mutatedKeys
                      , s = n
                      , a = !1
                      , o = "F" === this.query.limitType && n.size === this.query.limit ? n.last() : null
                      , l = "L" === this.query.limitType && n.size === this.query.limit ? n.first() : null;
                    if (e.inorderTraversal( (e, t) => {
                        let u = n.get(e)
                          , h = eJ(this.query, t) ? t : null
                          , c = !!u && this.mutatedKeys.has(u.key)
                          , d = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations)
                          , f = !1;
                        u && h ? u.data.isEqual(h.data) ? c !== d && (r.track({
                            type: 3,
                            doc: h
                        }),
                        f = !0) : this.ja(u, h) || (r.track({
                            type: 2,
                            doc: h
                        }),
                        f = !0,
                        (o && this.Ua(h, o) > 0 || l && 0 > this.Ua(h, l)) && (a = !0)) : !u && h ? (r.track({
                            type: 0,
                            doc: h
                        }),
                        f = !0) : u && !h && (r.track({
                            type: 1,
                            doc: u
                        }),
                        f = !0,
                        (o || l) && (a = !0)),
                        f && (h ? (s = s.add(h),
                        i = d ? i.add(e) : i.delete(e)) : (s = s.delete(e),
                        i = i.delete(e)))
                    }
                    ),
                    null !== this.query.limit)
                        for (; s.size > this.query.limit; ) {
                            let e = "F" === this.query.limitType ? s.last() : s.first();
                            s = s.delete(e.key),
                            i = i.delete(e.key),
                            r.track({
                                type: 1,
                                doc: e
                            })
                        }
                    return {
                        Ka: s,
                        za: r,
                        ys: a,
                        mutatedKeys: i
                    }
                }
                ja(e, t) {
                    return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations
                }
                applyChanges(e, t, r, n) {
                    let i = this.Ka;
                    this.Ka = e.Ka,
                    this.mutatedKeys = e.mutatedKeys;
                    let s = e.za.da();
                    s.sort( (e, t) => (function(e, t) {
                        let r = e => {
                            switch (e) {
                            case 0:
                                return 1;
                            case 2:
                            case 3:
                                return 2;
                            case 1:
                                return 0;
                            default:
                                return E(20277, {
                                    Vt: e
                                })
                            }
                        }
                        ;
                        return r(e) - r(t)
                    }
                    )(e.type, t.type) || this.Ua(e.doc, t.doc)),
                    this.Ha(r),
                    n = null != n && n;
                    let a = t && !n ? this.Ja() : []
                      , o = 0 === this.$a.size && this.current && !n ? 1 : 0
                      , l = o !== this.Qa;
                    return (this.Qa = o,
                    0 !== s.length || l) ? {
                        snapshot: new uM(this.query,e.Ka,i,s,e.mutatedKeys,0 === o,l,!1,!!r && r.resumeToken.approximateByteSize() > 0),
                        Ya: a
                    } : {
                        Ya: a
                    }
                }
                ga(e) {
                    return this.current && "Offline" === e ? (this.current = !1,
                    this.applyChanges({
                        Ka: this.Ka,
                        za: new uR,
                        mutatedKeys: this.mutatedKeys,
                        ys: !1
                    }, !1)) : {
                        Ya: []
                    }
                }
                Za(e) {
                    return !this.qa.has(e) && !!this.Ka.has(e) && !this.Ka.get(e).hasLocalMutations
                }
                Ha(e) {
                    e && (e.addedDocuments.forEach(e => this.qa = this.qa.add(e)),
                    e.modifiedDocuments.forEach(e => {}
                    ),
                    e.removedDocuments.forEach(e => this.qa = this.qa.delete(e)),
                    this.current = e.current)
                }
                Ja() {
                    if (!this.current)
                        return [];
                    let e = this.$a;
                    this.$a = e2(),
                    this.Ka.forEach(e => {
                        this.Za(e.key) && (this.$a = this.$a.add(e.key))
                    }
                    );
                    let t = [];
                    return e.forEach(e => {
                        this.$a.has(e) || t.push(new uj(e))
                    }
                    ),
                    this.$a.forEach(r => {
                        e.has(r) || t.push(new uq(r))
                    }
                    ),
                    t
                }
                Xa(e) {
                    this.qa = e.Ns,
                    this.$a = e2();
                    let t = this.Ga(e.documents);
                    return this.applyChanges(t, !0)
                }
                eu() {
                    return uM.fromInitialDocuments(this.query, this.Ka, this.mutatedKeys, 0 === this.Qa, this.hasCachedResults)
                }
            }
            let uQ = "SyncEngine";
            class uK {
                constructor(e, t, r) {
                    this.query = e,
                    this.targetId = t,
                    this.view = r
                }
            }
            class u$ {
                constructor(e) {
                    this.key = e,
                    this.tu = !1
                }
            }
            class uG {
                constructor(e, t, r, n, i, s) {
                    this.localStore = e,
                    this.remoteStore = t,
                    this.eventManager = r,
                    this.sharedClientState = n,
                    this.currentUser = i,
                    this.maxConcurrentLimboResolutions = s,
                    this.nu = {},
                    this.ru = new oM(e => eH(e),eG),
                    this.iu = new Map,
                    this.su = new Set,
                    this.ou = new a5(sW.comparator),
                    this._u = new Map,
                    this.au = new lQ,
                    this.uu = {},
                    this.cu = new Map,
                    this.lu = lD.ir(),
                    this.onlineState = "Unknown",
                    this.hu = void 0
                }
                get isPrimaryClient() {
                    return !0 === this.hu
                }
            }
            async function r5(e, t, r=!0) {
                let n, i = nC(e), s = i.ru.get(t);
                return s ? (i.sharedClientState.addLocalQueryTarget(s.targetId),
                n = s.view.eu()) : n = await r8(i, t, r, !0),
                n
            }
            async function r4(e, t) {
                let r = nC(e);
                await r8(r, t, !0, !1)
            }
            async function r8(e, t, r, n) {
                let i, s = await rh(e.localStore, ej(t)), a = s.targetId, o = e.sharedClientState.addLocalQueryTarget(a, r);
                return n && (i = await r7(e, t, a, "current" === o, s.resumeToken)),
                e.isPrimaryClient && r && rx(e.remoteStore, s),
                i
            }
            async function r7(e, t, r, n, i) {
                e.Pu = (t, r, n) => (async function(e, t, r, n) {
                    let i = t.view.Ga(r);
                    i.ys && (i = await rd(e.localStore, t.query, !1).then( ({documents: e}) => t.view.Ga(e, i)));
                    let s = n && n.targetChanges.get(t.targetId)
                      , a = n && null != n.targetMismatches.get(t.targetId)
                      , o = t.view.applyChanges(i, e.isPrimaryClient, s, a);
                    return nd(e, t.targetId, o.Ya),
                    o.snapshot
                }
                )(e, t, r, n);
                let s = await rd(e.localStore, t, !0)
                  , a = new uz(t,s.Ns)
                  , o = a.Ga(s.documents)
                  , l = o9.createSynthesizedTargetChangeForCurrentChange(r, n && "Offline" !== e.onlineState, i)
                  , u = a.applyChanges(o, e.isPrimaryClient, l);
                nd(e, r, u.Ya);
                let h = new uK(t,r,a);
                return e.ru.set(t, h),
                e.iu.has(r) ? e.iu.get(r).push(t) : e.iu.set(r, [t]),
                u.snapshot
            }
            async function r9(e, t, r) {
                let n = e.ru.get(t)
                  , i = e.iu.get(n.targetId);
                if (i.length > 1)
                    return e.iu.set(n.targetId, i.filter(e => !eG(e, t))),
                    void e.ru.delete(t);
                e.isPrimaryClient ? (e.sharedClientState.removeLocalQueryTarget(n.targetId),
                e.sharedClientState.isActiveQueryTarget(n.targetId) || await rc(e.localStore, n.targetId, !1).then( () => {
                    e.sharedClientState.clearQueryState(n.targetId),
                    r && rA(e.remoteStore, n.targetId),
                    nh(e, n.targetId)
                }
                ).catch(L)) : (nh(e, n.targetId),
                await rc(e.localStore, n.targetId, !0))
            }
            async function ne(e, t) {
                let r = e.ru.get(t)
                  , n = e.iu.get(r.targetId);
                e.isPrimaryClient && 1 === n.length && (e.sharedClientState.removeLocalQueryTarget(r.targetId),
                rA(e.remoteStore, r.targetId))
            }
            async function nt(e, t, r) {
                let n = nx(e);
                try {
                    var i;
                    let e, s = await function(e, t) {
                        let r, n, i = sj.now(), s = t.reduce( (e, t) => e.add(t.key), e2());
                        return e.persistence.runTransaction("Locally write mutations", "readwrite", a => {
                            let o = oP
                              , l = e2();
                            return e.Cs.getEntries(a, s).next(e => {
                                (o = e).forEach( (e, t) => {
                                    t.isValidDocument() || (l = l.add(e))
                                }
                                )
                            }
                            ).next( () => e.localDocuments.getOverlayedDocuments(a, o)).next(n => {
                                r = n;
                                let s = [];
                                for (let e of t) {
                                    let t = function(e, t) {
                                        let r = null;
                                        for (let n of e.fieldTransforms) {
                                            let e = t.data.field(n.field)
                                              , i = e4(n.transform, e || null);
                                            null != i && (null === r && (r = ov.empty()),
                                            r.set(n.field, i))
                                        }
                                        return r || null
                                    }(e, r.get(e.key).overlayedDocument);
                                    null != t && s.push(new oJ(e.key,t,function e(t) {
                                        let r = [];
                                        return H(t.fields, (t, n) => {
                                            let i = new sH([t]);
                                            if (ey(n)) {
                                                let t = e(n.mapValue).fields;
                                                if (0 === t.length)
                                                    r.push(i);
                                                else
                                                    for (let e of t)
                                                        r.push(i.child(e))
                                            } else
                                                r.push(i)
                                        }
                                        ),
                                        new oe(r)
                                    }(t.value.mapValue),oG.exists(!0)))
                                }
                                return e.mutationQueue.addMutationBatch(a, i, s, t)
                            }
                            ).next(t => {
                                n = t;
                                let i = t.applyToLocalDocumentSet(r, l);
                                return e.documentOverlayCache.saveOverlays(a, t.batchId, i)
                            }
                            )
                        }
                        ).then( () => ({
                            batchId: n.batchId,
                            changes: e0(r)
                        }))
                    }(n.localStore, t);
                    n.sharedClientState.addPendingMutation(s.batchId),
                    i = s.batchId,
                    (e = n.uu[n.currentUser.toKey()]) || (e = new a5(C)),
                    e = e.insert(i, r),
                    n.uu[n.currentUser.toKey()] = e,
                    await np(n, s.changes),
                    await rU(n.remoteStore)
                } catch (t) {
                    let e = rY(t, "Failed to persist write");
                    r.reject(e)
                }
            }
            async function nr(e, t) {
                try {
                    let r = await function(e, t) {
                        let r = t.snapshotVersion
                          , n = e.Ss;
                        return e.persistence.runTransaction("Apply remote event", "readwrite-primary", i => {
                            let s = e.Cs.newChangeBuffer({
                                trackRemovals: !0
                            });
                            n = e.Ss;
                            let a = [];
                            t.targetChanges.forEach( (s, o) => {
                                var l;
                                let u = n.get(o);
                                if (!u)
                                    return;
                                a.push(e.ai.removeMatchingKeys(i, s.removedDocuments, o).next( () => e.ai.addMatchingKeys(i, s.addedDocuments, o)));
                                let h = u.withSequenceNumber(i.currentSequenceNumber);
                                null !== t.targetMismatches.get(o) ? h = h.withResumeToken(or.EMPTY_BYTE_STRING, sz.min()).withLastLimboFreeSnapshotVersion(sz.min()) : s.resumeToken.approximateByteSize() > 0 && (h = h.withResumeToken(s.resumeToken, r)),
                                n = n.insert(o, h),
                                l = h,
                                (0 === u.resumeToken.approximateByteSize() || l.snapshotVersion.toMicroseconds() - u.snapshotVersion.toMicroseconds() >= 3e8 || s.addedDocuments.size + s.modifiedDocuments.size + s.removedDocuments.size > 0) && a.push(e.ai.updateTargetData(i, h))
                            }
                            );
                            let o = oP
                              , l = e2();
                            if (t.documentUpdates.forEach(r => {
                                t.resolvedLimboDocuments.has(r) && a.push(e.persistence.referenceDelegate.updateLimboDocument(i, r))
                            }
                            ),
                            a.push(ru(i, s, t.documentUpdates).next(e => {
                                o = e.xs,
                                l = e.Os
                            }
                            )),
                            !r.isEqual(sz.min())) {
                                let t = e.ai.getLastRemoteSnapshotVersion(i).next(t => e.ai.setTargetsMetadata(i, i.currentSequenceNumber, r));
                                a.push(t)
                            }
                            return s2.waitFor(a).next( () => s.apply(i)).next( () => e.localDocuments.getLocalViewOfDocuments(i, o, l)).next( () => o)
                        }
                        ).then(t => (e.Ss = n,
                        t))
                    }(e.localStore, t);
                    t.targetChanges.forEach( (t, r) => {
                        let n = e._u.get(r);
                        n && (_(t.addedDocuments.size + t.modifiedDocuments.size + t.removedDocuments.size <= 1, 22616),
                        t.addedDocuments.size > 0 ? n.tu = !0 : t.modifiedDocuments.size > 0 ? _(n.tu, 14607) : t.removedDocuments.size > 0 && (_(n.tu, 42227),
                        n.tu = !1))
                    }
                    ),
                    await np(e, r, t)
                } catch (e) {
                    await L(e)
                }
            }
            function nn(e, t, r) {
                var n;
                if (e.isPrimaryClient && 0 === r || !e.isPrimaryClient && 1 === r) {
                    let r, i = [];
                    e.ru.forEach( (e, r) => {
                        let n = r.view.ga(t);
                        n.snapshot && i.push(n.snapshot)
                    }
                    ),
                    (n = e.eventManager).onlineState = t,
                    r = !1,
                    n.queries.forEach( (e, n) => {
                        for (let e of n.Ra)
                            e.ga(t) && (r = !0)
                    }
                    ),
                    r && r6(n),
                    i.length && e.nu.Q_(i),
                    e.onlineState = t,
                    e.isPrimaryClient && e.sharedClientState.setOnlineState(t)
                }
            }
            async function ni(e, t, r) {
                e.sharedClientState.updateQueryState(t, "rejected", r);
                let n = e._u.get(t)
                  , i = n && n.key;
                if (i) {
                    let r = new a5(sW.comparator);
                    r = r.insert(i, ow.newNoDocument(i, sz.min()));
                    let n = e2().add(i)
                      , s = new o7(sz.min(),new Map,new a5(C),r,n);
                    await nr(e, s),
                    e.ou = e.ou.remove(i),
                    e._u.delete(t),
                    nf(e)
                } else
                    await rc(e.localStore, t, !1).then( () => nh(e, t, r)).catch(L)
            }
            async function ns(e, t) {
                var r;
                let n = t.batch.batchId;
                try {
                    let i = await (r = e.localStore,
                    r.persistence.runTransaction("Acknowledge batch", "readwrite-primary", e => {
                        let n = t.batch.keys()
                          , i = r.Cs.newChangeBuffer({
                            trackRemovals: !0
                        });
                        return (function(e, t, r, n) {
                            let i = r.batch
                              , s = i.keys()
                              , a = s2.resolve();
                            return s.forEach(e => {
                                a = a.next( () => n.getEntry(t, e)).next(t => {
                                    let s = r.docVersions.get(e);
                                    _(null !== s, 48541),
                                    0 > t.version.compareTo(s) && (i.applyToRemoteDocument(t, r),
                                    t.isValidDocument() && (t.setReadTime(r.commitVersion),
                                    n.addEntry(t)))
                                }
                                )
                            }
                            ),
                            a.next( () => e.mutationQueue.removeMutationBatch(t, i))
                        }
                        )(r, e, t, i).next( () => i.apply(e)).next( () => r.mutationQueue.performConsistencyCheck(e)).next( () => r.documentOverlayCache.removeOverlaysForBatchId(e, n, t.batch.batchId)).next( () => r.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, function(e) {
                            let t = e2();
                            for (let r = 0; r < e.mutationResults.length; ++r)
                                e.mutationResults[r].transformResults.length > 0 && (t = t.add(e.batch.mutations[r].key));
                            return t
                        }(t))).next( () => r.localDocuments.getDocuments(e, n))
                    }
                    ));
                    nu(e, n, null),
                    nl(e, n),
                    e.sharedClientState.updateMutationState(n, "acknowledged"),
                    await np(e, i)
                } catch (e) {
                    await L(e)
                }
            }
            async function na(e, t, r) {
                var n;
                try {
                    let i = await (n = e.localStore,
                    n.persistence.runTransaction("Reject batch", "readwrite-primary", e => {
                        let r;
                        return n.mutationQueue.lookupMutationBatch(e, t).next(t => (_(null !== t, 37113),
                        r = t.keys(),
                        n.mutationQueue.removeMutationBatch(e, t))).next( () => n.mutationQueue.performConsistencyCheck(e)).next( () => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t)).next( () => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, r)).next( () => n.localDocuments.getDocuments(e, r))
                    }
                    ));
                    nu(e, t, r),
                    nl(e, t),
                    e.sharedClientState.updateMutationState(t, "rejected", r),
                    await np(e, i)
                } catch (e) {
                    await L(e)
                }
            }
            async function no(e, t) {
                var r;
                rR(e.remoteStore) || y(uQ, "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
                try {
                    let n = await (r = e.localStore).persistence.runTransaction("Get highest unacknowledged batch id", "readonly", e => r.mutationQueue.getHighestUnacknowledgedBatchId(e));
                    if (-1 === n)
                        return void t.resolve();
                    let i = e.cu.get(n) || [];
                    i.push(t),
                    e.cu.set(n, i)
                } catch (r) {
                    let e = rY(r, "Initialization of waitForPendingWrites() operation failed");
                    t.reject(e)
                }
            }
            function nl(e, t) {
                (e.cu.get(t) || []).forEach(e => {
                    e.resolve()
                }
                ),
                e.cu.delete(t)
            }
            function nu(e, t, r) {
                let n = e.uu[e.currentUser.toKey()];
                if (n) {
                    let i = n.get(t);
                    i && (r ? i.reject(r) : i.resolve(),
                    n = n.remove(t)),
                    e.uu[e.currentUser.toKey()] = n
                }
            }
            function nh(e, t, r=null) {
                for (let n of (e.sharedClientState.removeLocalQueryTarget(t),
                e.iu.get(t)))
                    e.ru.delete(n),
                    r && e.nu.Tu(n, r);
                e.iu.delete(t),
                e.isPrimaryClient && e.au.Ur(t).forEach(t => {
                    e.au.containsKey(t) || nc(e, t)
                }
                )
            }
            function nc(e, t) {
                e.su.delete(t.path.canonicalString());
                let r = e.ou.get(t);
                null !== r && (rA(e.remoteStore, r),
                e.ou = e.ou.remove(t),
                e._u.delete(r),
                nf(e))
            }
            function nd(e, t, r) {
                for (let n of r)
                    n instanceof uq ? (e.au.addReference(n.key, t),
                    function(e, t) {
                        let r = t.key
                          , n = r.path.canonicalString();
                        e.ou.get(r) || e.su.has(n) || (y(uQ, "New document in limbo: " + r),
                        e.su.add(n),
                        nf(e))
                    }(e, n)) : n instanceof uj ? (y(uQ, "Document no longer in limbo: " + n.key),
                    e.au.removeReference(n.key, t),
                    e.au.containsKey(n.key) || nc(e, n.key)) : E(19791, {
                        Iu: n
                    })
            }
            function nf(e) {
                for (; e.su.size > 0 && e.ou.size < e.maxConcurrentLimboResolutions; ) {
                    let t = e.su.values().next().value;
                    e.su.delete(t);
                    let r = new sW(s$.fromString(t))
                      , n = e.lu.next();
                    e._u.set(n, new u$(r)),
                    e.ou = e.ou.insert(r, n),
                    rx(e.remoteStore, new lu(ej(eB(r.path)),n,"TargetPurposeLimboResolution",an.le))
                }
            }
            async function np(e, t, r) {
                let n = []
                  , i = []
                  , s = [];
                e.ru.isEmpty() || (e.ru.forEach( (a, o) => {
                    s.push(e.Pu(o, t, r).then(t => {
                        var s;
                        if ((t || r) && e.isPrimaryClient) {
                            let n = t ? !t.fromCache : null == (s = null == r ? void 0 : r.targetChanges.get(o.targetId)) ? void 0 : s.current;
                            e.sharedClientState.updateQueryState(o.targetId, n ? "current" : "not-current")
                        }
                        if (t) {
                            n.push(t);
                            let e = l5.Ps(o.targetId, t);
                            i.push(e)
                        }
                    }
                    ))
                }
                ),
                await Promise.all(s),
                e.nu.Q_(n),
                await async function(e, t) {
                    try {
                        await e.persistence.runTransaction("notifyLocalViewChanges", "readwrite", r => s2.forEach(t, t => s2.forEach(t.ls, n => e.persistence.referenceDelegate.addReference(r, t.targetId, n)).next( () => s2.forEach(t.hs, n => e.persistence.referenceDelegate.removeReference(r, t.targetId, n)))))
                    } catch (e) {
                        if (!B(e))
                            throw e;
                        y(l7, "Failed to update sequence numbers: " + e)
                    }
                    for (let r of t) {
                        let t = r.targetId;
                        if (!r.fromCache) {
                            let r = e.Ss.get(t)
                              , n = r.snapshotVersion
                              , i = r.withLastLimboFreeSnapshotVersion(n);
                            e.Ss = e.Ss.insert(t, i)
                        }
                    }
                }(e.localStore, i))
            }
            async function ng(e, t) {
                if (!e.currentUser.isEqual(t)) {
                    y(uQ, "User change. New user:", t.toKey());
                    let r = await ro(e.localStore, t);
                    e.currentUser = t,
                    e.cu.forEach(e => {
                        e.forEach(e => {
                            e.reject(new sk(sD.CANCELLED,"'waitForPendingWrites' promise is rejected due to a user change."))
                        }
                        )
                    }
                    ),
                    e.cu.clear(),
                    e.sharedClientState.handleUserChange(t, r.removedBatchIds, r.addedBatchIds),
                    await np(e, r.Ms)
                }
            }
            function nm(e, t) {
                let r = e._u.get(t);
                if (r && r.tu)
                    return e2().add(r.key);
                {
                    let r = e2()
                      , n = e.iu.get(t);
                    if (!n)
                        return r;
                    for (let t of n) {
                        let n = e.ru.get(t);
                        r = r.unionWith(n.view.Wa)
                    }
                    return r
                }
            }
            async function ny(e, t) {
                let r = await rd(e.localStore, t.query, !0)
                  , n = t.view.Xa(r);
                return e.isPrimaryClient && nd(e, t.targetId, n.Ya),
                n
            }
            async function nv(e, t) {
                return rp(e.localStore, t).then(t => np(e, t))
            }
            async function nw(e, t, r, n) {
                var i;
                let s = await function(e, t) {
                    let r = e.mutationQueue;
                    return e.persistence.runTransaction("Lookup mutation documents", "readonly", n => r.Hn(n, t).next(t => t ? e.localDocuments.getDocuments(n, t) : s2.resolve(null)))
                }(e.localStore, t);
                null !== s ? ("pending" === r ? await rU(e.remoteStore) : "acknowledged" === r || "rejected" === r ? (nu(e, t, n || null),
                nl(e, t),
                i = e.localStore,
                i.mutationQueue.Xn(t)) : E(6720, "Unknown batchState", {
                    Eu: r
                }),
                await np(e, s)) : y(uQ, "Cannot apply mutation batch with id: " + t)
            }
            async function nb(e, t) {
                if (nC(e),
                nx(e),
                !0 === t && !0 !== e.hu) {
                    let t = e.sharedClientState.getAllActiveQueryTargets()
                      , r = await nE(e, t.toArray());
                    for (let t of (e.hu = !0,
                    await rH(e.remoteStore, !0),
                    r))
                        rx(e.remoteStore, t)
                } else if (!1 === t && !1 !== e.hu) {
                    let t = []
                      , r = Promise.resolve();
                    e.iu.forEach( (n, i) => {
                        e.sharedClientState.isLocalQueryTarget(i) ? t.push(i) : r = r.then( () => (nh(e, i),
                        rc(e.localStore, i, !0))),
                        rA(e.remoteStore, i)
                    }
                    ),
                    await r,
                    await nE(e, t),
                    e._u.forEach( (t, r) => {
                        rA(e.remoteStore, r)
                    }
                    ),
                    e.au.Kr(),
                    e._u = new Map,
                    e.ou = new a5(sW.comparator),
                    e.hu = !1,
                    await rH(e.remoteStore, !1)
                }
            }
            async function nE(e, t, r) {
                let n = []
                  , i = [];
                for (let r of t) {
                    let t, s = e.iu.get(r);
                    if (s && 0 !== s.length)
                        for (let r of (t = await rh(e.localStore, ej(s[0])),
                        s)) {
                            let t = e.ru.get(r)
                              , n = await ny(e, t);
                            n.snapshot && i.push(n.snapshot)
                        }
                    else {
                        let n = await rf(e.localStore, r);
                        t = await rh(e.localStore, n),
                        await r7(e, nI(n), r, !1, t.resumeToken)
                    }
                    n.push(t)
                }
                return e.nu.Q_(i),
                n
            }
            function nI(e) {
                var t, r, n, i, s;
                return t = e.path,
                r = e.collectionGroup,
                n = e.orderBy,
                i = e.filters,
                s = e.limit,
                new oR(t,r,n,i,s,"F",e.startAt,e.endAt)
            }
            function n_(e) {
                return e.localStore.persistence.us()
            }
            async function nT(e, t, r, n) {
                if (e.hu)
                    return void y(uQ, "Ignoring unexpected query state notification.");
                let i = e.iu.get(t);
                if (i && i.length > 0)
                    switch (r) {
                    case "current":
                    case "not-current":
                        {
                            let n = await rp(e.localStore, eY(i[0]))
                              , s = o7.createSynthesizedRemoteEventForCurrentChange(t, "current" === r, or.EMPTY_BYTE_STRING);
                            await np(e, n, s);
                            break
                        }
                    case "rejected":
                        await rc(e.localStore, t, !0),
                        nh(e, t, n);
                        break;
                    default:
                        E(64155, r)
                    }
            }
            async function nS(e, t, r) {
                let n = nC(e);
                if (n.hu) {
                    for (let e of t) {
                        if (n.iu.has(e) && n.sharedClientState.isActiveQueryTarget(e)) {
                            y(uQ, "Adding an already active target " + e);
                            continue
                        }
                        let t = await rf(n.localStore, e)
                          , r = await rh(n.localStore, t);
                        await r7(n, nI(t), r.targetId, !1, r.resumeToken),
                        rx(n.remoteStore, r)
                    }
                    for (let e of r)
                        n.iu.has(e) && await rc(n.localStore, e, !1).then( () => {
                            rA(n.remoteStore, e),
                            nh(n, e)
                        }
                        ).catch(L)
                }
            }
            function nC(e) {
                return e.remoteStore.remoteSyncer.applyRemoteEvent = nr.bind(null, e),
                e.remoteStore.remoteSyncer.getRemoteKeysForTarget = nm.bind(null, e),
                e.remoteStore.remoteSyncer.rejectListen = ni.bind(null, e),
                e.nu.Q_ = r1.bind(null, e.eventManager),
                e.nu.Tu = r2.bind(null, e.eventManager),
                e
            }
            function nx(e) {
                return e.remoteStore.remoteSyncer.applySuccessfulWrite = ns.bind(null, e),
                e.remoteStore.remoteSyncer.rejectFailedWrite = na.bind(null, e),
                e
            }
            class uH {
                constructor() {
                    this.kind = "memory",
                    this.synchronizeTabs = !1
                }
                async initialize(e) {
                    this.serializer = rT(e.databaseInfo.databaseId),
                    this.sharedClientState = this.Au(e),
                    this.persistence = this.Ru(e),
                    await this.persistence.start(),
                    this.localStore = this.Vu(e),
                    this.gcScheduler = this.mu(e, this.localStore),
                    this.indexBackfillerScheduler = this.fu(e, this.localStore)
                }
                mu(e, t) {
                    return null
                }
                fu(e, t) {
                    return null
                }
                Vu(e) {
                    var t, r;
                    return t = this.persistence,
                    r = new l8,
                    new l9(t,r,e.initialUser,this.serializer)
                }
                Ru(e) {
                    return new lJ(lX.Ei,this.serializer)
                }
                Au(e) {
                    return new uh
                }
                async terminate() {
                    var e, t;
                    null == (e = this.gcScheduler) || e.stop(),
                    null == (t = this.indexBackfillerScheduler) || t.stop(),
                    this.sharedClientState.shutdown(),
                    await this.persistence.shutdown()
                }
            }
            uH.provider = {
                build: () => new uH
            };
            class uW extends uH {
                constructor(e) {
                    super(),
                    this.cacheSizeBytes = e
                }
                mu(e, t) {
                    return _(this.persistence.referenceDelegate instanceof lZ, 46915),
                    new lR(this.persistence.referenceDelegate.garbageCollector,e.asyncQueue,t)
                }
                Ru(e) {
                    let t = void 0 !== this.cacheSizeBytes ? lx.withCacheSize(this.cacheSizeBytes) : lx.DEFAULT;
                    return new lJ(e => lZ.Ei(e, t),this.serializer)
                }
            }
            class uJ extends uH {
                constructor(e, t, r) {
                    super(),
                    this.gu = e,
                    this.cacheSizeBytes = t,
                    this.forceOwnership = r,
                    this.kind = "persistent",
                    this.synchronizeTabs = !1
                }
                async initialize(e) {
                    await super.initialize(e),
                    await this.gu.initialize(this, e),
                    await nx(this.gu.syncEngine),
                    await rU(this.gu.remoteStore),
                    await this.persistence.Ki( () => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(),
                    this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(),
                    Promise.resolve()))
                }
                Vu(e) {
                    var t, r;
                    return t = this.persistence,
                    r = new l8,
                    new l9(t,r,e.initialUser,this.serializer)
                }
                mu(e, t) {
                    return new lR(this.persistence.referenceDelegate.garbageCollector,e.asyncQueue,t)
                }
                fu(e, t) {
                    let r = new ar(t,this.persistence);
                    return new at(e.asyncQueue,r)
                }
                Ru(e) {
                    let t = ra(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey)
                      , r = void 0 !== this.cacheSizeBytes ? lx.withCacheSize(this.cacheSizeBytes) : lx.DEFAULT;
                    return new l3(this.synchronizeTabs,t,e.clientId,r,e.asyncQueue,rI(),r_(),this.serializer,this.sharedClientState,!!this.forceOwnership)
                }
                Au(e) {
                    return new uh
                }
            }
            class uY extends uJ {
                constructor(e, t) {
                    super(e, t, !1),
                    this.gu = e,
                    this.cacheSizeBytes = t,
                    this.synchronizeTabs = !0
                }
                async initialize(e) {
                    await super.initialize(e);
                    let t = this.gu.syncEngine;
                    this.sharedClientState instanceof uu && (this.sharedClientState.syncEngine = {
                        yo: nw.bind(null, t),
                        wo: nT.bind(null, t),
                        bo: nS.bind(null, t),
                        us: n_.bind(null, t),
                        po: nv.bind(null, t)
                    },
                    await this.sharedClientState.start()),
                    await this.persistence.Ki(async e => {
                        await nb(this.gu.syncEngine, e),
                        this.gcScheduler && (e && !this.gcScheduler.started ? this.gcScheduler.start() : e || this.gcScheduler.stop()),
                        this.indexBackfillerScheduler && (e && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : e || this.indexBackfillerScheduler.stop())
                    }
                    )
                }
                Au(e) {
                    let t = rI();
                    if (!uu.C(t))
                        throw new sk(sD.UNIMPLEMENTED,"IndexedDB persistence is only available on platforms that support LocalStorage.");
                    let r = ra(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey);
                    return new uu(t,e.asyncQueue,r,e.clientId,e.initialUser)
                }
            }
            class uX {
                async initialize(e, t) {
                    this.localStore || (this.localStore = e.localStore,
                    this.sharedClientState = e.sharedClientState,
                    this.datastore = this.createDatastore(t),
                    this.remoteStore = this.createRemoteStore(t),
                    this.eventManager = this.createEventManager(t),
                    this.syncEngine = this.createSyncEngine(t, !e.synchronizeTabs),
                    this.sharedClientState.onlineStateHandler = e => nn(this.syncEngine, e, 1),
                    this.remoteStore.remoteSyncer.handleCredentialChange = ng.bind(null, this.syncEngine),
                    await rH(this.remoteStore, this.syncEngine.isPrimaryClient))
                }
                createEventManager(e) {
                    return new uL
                }
                createDatastore(e) {
                    var t;
                    let r = rT(e.databaseInfo.databaseId)
                      , n = new ub(e.databaseInfo);
                    return t = e.authCredentials,
                    new ux(t,e.appCheckCredentials,n,r)
                }
                createRemoteStore(e) {
                    var t, r;
                    return t = this.localStore,
                    r = this.datastore,
                    new uk(t,r,e.asyncQueue,e => nn(this.syncEngine, e, 0),uf.C() ? new uf : new uc)
                }
                createSyncEngine(e, t) {
                    return function(e, t, r, n, i, s, a) {
                        let o = new uG(e,t,r,n,i,s);
                        return a && (o.hu = !0),
                        o
                    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t)
                }
                async terminate() {
                    var e, t;
                    await async function(e) {
                        y(uD, "RemoteStore shutting down."),
                        e.aa.add(5),
                        await rC(e),
                        e.ca.shutdown(),
                        e.la.set("Unknown")
                    }(this.remoteStore),
                    null == (e = this.datastore) || e.terminate(),
                    null == (t = this.eventManager) || t.terminate()
                }
            }
            function nA(e, t=10240) {
                let r = 0;
                return {
                    async read() {
                        if (r < e.byteLength) {
                            let n = {
                                value: e.slice(r, r + t),
                                done: !1
                            };
                            return r += t,
                            n
                        }
                        return {
                            done: !0
                        }
                    },
                    async cancel() {},
                    releaseLock() {},
                    closed: Promise.resolve()
                }
            }
            uX.provider = {
                build: () => new uX
            };
            class uZ {
                constructor(e) {
                    this.observer = e,
                    this.muted = !1
                }
                next(e) {
                    this.muted || this.observer.next && this.pu(this.observer.next, e)
                }
                error(e) {
                    this.muted || (this.observer.error ? this.pu(this.observer.error, e) : v("Uncaught Error in snapshot listener:", e.toString()))
                }
                yu() {
                    this.muted = !0
                }
                pu(e, t) {
                    setTimeout( () => {
                        this.muted || e(t)
                    }
                    , 0)
                }
            }
            class u0 {
                constructor(e, t) {
                    this.wu = e,
                    this.serializer = t,
                    this.metadata = new sN,
                    this.buffer = new Uint8Array,
                    this.bu = new TextDecoder("utf-8"),
                    this.Su().then(e => {
                        e && e.xa() ? this.metadata.resolve(e.Ma.metadata) : this.metadata.reject(Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(null == e ? void 0 : e.Ma)}`))
                    }
                    , e => this.metadata.reject(e))
                }
                close() {
                    return this.wu.cancel()
                }
                async getMetadata() {
                    return this.metadata.promise
                }
                async du() {
                    return await this.getMetadata(),
                    this.Su()
                }
                async Su() {
                    let e = await this.Du();
                    if (null === e)
                        return null;
                    let t = this.bu.decode(e)
                      , r = Number(t);
                    return isNaN(r) && this.vu(`length string (${t}) is not valid number`),
                    new uB(JSON.parse(await this.Cu(r)),e.length + r)
                }
                Fu() {
                    return this.buffer.findIndex(e => 123 === e)
                }
                async Du() {
                    for (; 0 > this.Fu() && !await this.Mu(); )
                        ;
                    if (0 === this.buffer.length)
                        return null;
                    let e = this.Fu();
                    e < 0 && this.vu("Reached the end of bundle when a length string is expected.");
                    let t = this.buffer.slice(0, e);
                    return this.buffer = this.buffer.slice(e),
                    t
                }
                async Cu(e) {
                    for (; this.buffer.length < e; )
                        await this.Mu() && this.vu("Reached the end of bundle when more is expected.");
                    let t = this.bu.decode(this.buffer.slice(0, e));
                    return this.buffer = this.buffer.slice(e),
                    t
                }
                vu(e) {
                    throw this.wu.cancel(),
                    Error(`Invalid bundle format: ${e}`)
                }
                async Mu() {
                    let e = await this.wu.read();
                    if (!e.done) {
                        let t = new Uint8Array(this.buffer.length + e.value.length);
                        t.set(this.buffer),
                        t.set(e.value, this.buffer.length),
                        this.buffer = t
                    }
                    return e.done
                }
            }
            class u1 {
                constructor(e) {
                    this.datastore = e,
                    this.readVersions = new Map,
                    this.mutations = [],
                    this.committed = !1,
                    this.lastTransactionError = null,
                    this.writtenDocs = new Set
                }
                async lookup(e) {
                    if (this.ensureCommitNotCalled(),
                    this.mutations.length > 0)
                        throw this.lastTransactionError = new sk(sD.INVALID_ARGUMENT,"Firestore transactions require all reads to be executed before all writes."),
                        this.lastTransactionError;
                    let t = await async function(e, t) {
                        let r = {
                            documents: t.map(t => tE(e.serializer, t))
                        }
                          , n = await e.Wo("BatchGetDocuments", e.serializer.databaseId, s$.emptyPath(), r, t.length)
                          , i = new Map;
                        n.forEach(t => {
                            var r;
                            let n = (r = e.serializer,
                            "found"in t ? function(e, t) {
                                _(!!t.found, 43571),
                                t.found.name,
                                t.found.updateTime;
                                let r = tI(e, t.found.name)
                                  , n = ty(t.found.updateTime)
                                  , i = t.found.createTime ? ty(t.found.createTime) : sz.min()
                                  , s = new ov({
                                    mapValue: {
                                        fields: t.found.fields
                                    }
                                });
                                return ow.newFoundDocument(r, n, i, s)
                            }(r, t) : "missing"in t ? function(e, t) {
                                _(!!t.missing, 3894),
                                _(!!t.readTime, 22933);
                                let r = tI(e, t.missing)
                                  , n = ty(t.readTime);
                                return ow.newNoDocument(r, n)
                            }(r, t) : E(7234, {
                                result: t
                            }));
                            i.set(n.key.toString(), n)
                        }
                        );
                        let s = [];
                        return t.forEach(e => {
                            let t = i.get(e.toString());
                            _(!!t, 55234, {
                                key: e
                            }),
                            s.push(t)
                        }
                        ),
                        s
                    }(this.datastore, e);
                    return t.forEach(e => this.recordVersion(e)),
                    t
                }
                set(e, t) {
                    this.write(t.toMutation(e, this.precondition(e))),
                    this.writtenDocs.add(e.toString())
                }
                update(e, t) {
                    try {
                        this.write(t.toMutation(e, this.preconditionForUpdate(e)))
                    } catch (e) {
                        this.lastTransactionError = e
                    }
                    this.writtenDocs.add(e.toString())
                }
                delete(e) {
                    this.write(new oY(e,this.precondition(e))),
                    this.writtenDocs.add(e.toString())
                }
                async commit() {
                    if (this.ensureCommitNotCalled(),
                    this.lastTransactionError)
                        throw this.lastTransactionError;
                    let e = this.readVersions;
                    this.mutations.forEach(t => {
                        e.delete(t.key.toString())
                    }
                    ),
                    e.forEach( (e, t) => {
                        let r = sW.fromPath(t);
                        this.mutations.push(new oX(r,this.precondition(r)))
                    }
                    ),
                    await async function(e, t) {
                        let r = {
                            writes: t.map(t => tD(e.serializer, t))
                        };
                        await e.Qo("Commit", e.serializer.databaseId, s$.emptyPath(), r)
                    }(this.datastore, this.mutations),
                    this.committed = !0
                }
                recordVersion(e) {
                    let t;
                    if (e.isFoundDocument())
                        t = e.version;
                    else {
                        if (!e.isNoDocument())
                            throw E(50498, {
                                xu: e.constructor.name
                            });
                        t = sz.min()
                    }
                    let r = this.readVersions.get(e.key.toString());
                    if (r) {
                        if (!t.isEqual(r))
                            throw new sk(sD.ABORTED,"Document version changed between two reads.")
                    } else
                        this.readVersions.set(e.key.toString(), t)
                }
                precondition(e) {
                    let t = this.readVersions.get(e.toString());
                    return !this.writtenDocs.has(e.toString()) && t ? t.isEqual(sz.min()) ? oG.exists(!1) : oG.updateTime(t) : oG.none()
                }
                preconditionForUpdate(e) {
                    let t = this.readVersions.get(e.toString());
                    if (!this.writtenDocs.has(e.toString()) && t) {
                        if (t.isEqual(sz.min()))
                            throw new sk(sD.INVALID_ARGUMENT,"Can't update a document that doesn't exist.");
                        return oG.updateTime(t)
                    }
                    return oG.exists(!0)
                }
                write(e) {
                    this.ensureCommitNotCalled(),
                    this.mutations.push(e)
                }
                ensureCommitNotCalled() {}
            }
            class u2 {
                constructor(e, t, r, n, i) {
                    this.asyncQueue = e,
                    this.datastore = t,
                    this.options = r,
                    this.updateFunction = n,
                    this.deferred = i,
                    this.Ou = r.maxAttempts,
                    this.y_ = new uE(this.asyncQueue,"transaction_retry")
                }
                Nu() {
                    this.Ou -= 1,
                    this.Bu()
                }
                Bu() {
                    this.y_.E_(async () => {
                        let e = new u1(this.datastore)
                          , t = this.Lu(e);
                        t && t.then(t => {
                            this.asyncQueue.enqueueAndForget( () => e.commit().then( () => {
                                this.deferred.resolve(t)
                            }
                            ).catch(e => {
                                this.ku(e)
                            }
                            ))
                        }
                        ).catch(e => {
                            this.ku(e)
                        }
                        )
                    }
                    )
                }
                Lu(e) {
                    try {
                        let t = this.updateFunction(e);
                        return !q(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")),
                        null)
                    } catch (e) {
                        return this.deferred.reject(e),
                        null
                    }
                }
                ku(e) {
                    this.Ou > 0 && this.qu(e) ? (this.Ou -= 1,
                    this.asyncQueue.enqueueAndForget( () => (this.Bu(),
                    Promise.resolve()))) : this.deferred.reject(e)
                }
                qu(e) {
                    if ("FirebaseError" === e.name) {
                        let t = e.code;
                        return "aborted" === t || "failed-precondition" === t || "already-exists" === t || !tl(t)
                    }
                    return !1
                }
            }
            let u6 = "FirestoreClient";
            class u3 {
                constructor(e, t, r, n, i) {
                    this.authCredentials = e,
                    this.appCheckCredentials = t,
                    this.asyncQueue = r,
                    this.databaseInfo = n,
                    this.user = sC.UNAUTHENTICATED,
                    this.clientId = sq.newId(),
                    this.authCredentialListener = () => Promise.resolve(),
                    this.appCheckCredentialListener = () => Promise.resolve(),
                    this._uninitializedComponentsProvider = i,
                    this.authCredentials.start(r, async e => {
                        y(u6, "Received user=", e.uid),
                        await this.authCredentialListener(e),
                        this.user = e
                    }
                    ),
                    this.appCheckCredentials.start(r, e => (y(u6, "Received new app check token=", e),
                    this.appCheckCredentialListener(e, this.user)))
                }
                get configuration() {
                    return {
                        asyncQueue: this.asyncQueue,
                        databaseInfo: this.databaseInfo,
                        clientId: this.clientId,
                        authCredentials: this.authCredentials,
                        appCheckCredentials: this.appCheckCredentials,
                        initialUser: this.user,
                        maxConcurrentLimboResolutions: 100
                    }
                }
                setCredentialChangeListener(e) {
                    this.authCredentialListener = e
                }
                setAppCheckTokenChangeListener(e) {
                    this.appCheckCredentialListener = e
                }
                terminate() {
                    this.asyncQueue.enterRestrictedMode();
                    let e = new sN;
                    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
                        try {
                            this._onlineComponents && await this._onlineComponents.terminate(),
                            this._offlineComponents && await this._offlineComponents.terminate(),
                            this.authCredentials.shutdown(),
                            this.appCheckCredentials.shutdown(),
                            e.resolve()
                        } catch (r) {
                            let t = rY(r, "Failed to shutdown persistence");
                            e.reject(t)
                        }
                    }
                    ),
                    e.promise
                }
            }
            async function nD(e, t) {
                e.asyncQueue.verifyOperationInProgress(),
                y(u6, "Initializing OfflineComponentProvider");
                let r = e.configuration;
                await t.initialize(r);
                let n = r.initialUser;
                e.setCredentialChangeListener(async e => {
                    n.isEqual(e) || (await ro(t.localStore, e),
                    n = e)
                }
                ),
                t.persistence.setDatabaseDeletedListener( () => e.terminate()),
                e._offlineComponents = t
            }
            async function nk(e, t) {
                e.asyncQueue.verifyOperationInProgress();
                let r = await nN(e);
                y(u6, "Initializing OnlineComponentProvider"),
                await t.initialize(r, e.configuration),
                e.setCredentialChangeListener(e => rG(t.remoteStore, e)),
                e.setAppCheckTokenChangeListener( (e, r) => rG(t.remoteStore, r)),
                e._onlineComponents = t
            }
            async function nN(e) {
                if (!e._offlineComponents)
                    if (e._uninitializedComponentsProvider) {
                        y(u6, "Using user provided OfflineComponentProvider");
                        try {
                            await nD(e, e._uninitializedComponentsProvider._offline)
                        } catch (t) {
                            if (!("FirebaseError" === t.name ? t.code === sD.FAILED_PRECONDITION || t.code === sD.UNIMPLEMENTED : !("undefined" != typeof DOMException && t instanceof DOMException) || 22 === t.code || 20 === t.code || 11 === t.code))
                                throw t;
                            w("Error using user provided cache. Falling back to memory cache: " + t),
                            await nD(e, new uH)
                        }
                    } else
                        y(u6, "Using default OfflineComponentProvider"),
                        await nD(e, new uW(void 0));
                return e._offlineComponents
            }
            async function nO(e) {
                return e._onlineComponents || (e._uninitializedComponentsProvider ? (y(u6, "Using user provided OnlineComponentProvider"),
                await nk(e, e._uninitializedComponentsProvider._online)) : (y(u6, "Using default OnlineComponentProvider"),
                await nk(e, new uX))),
                e._onlineComponents
            }
            function nR(e) {
                return nN(e).then(e => e.persistence)
            }
            function nM(e) {
                return nN(e).then(e => e.localStore)
            }
            function nP(e) {
                return nO(e).then(e => e.remoteStore)
            }
            function nL(e) {
                return nO(e).then(e => e.syncEngine)
            }
            function nF(e) {
                return nO(e).then(e => e.datastore)
            }
            async function nB(e) {
                let t = await nO(e)
                  , r = t.eventManager;
                return r.onListen = r5.bind(null, t.syncEngine),
                r.onUnlisten = r9.bind(null, t.syncEngine),
                r.onFirstRemoteStoreListen = r4.bind(null, t.syncEngine),
                r.onLastRemoteStoreUnlisten = ne.bind(null, t.syncEngine),
                r
            }
            function nV(e, t, r={}) {
                let n = new sN;
                return e.asyncQueue.enqueueAndForget(async () => (function(e, t, r, n, i) {
                    let s = new uZ({
                        next: o => {
                            s.yu(),
                            t.enqueueAndForget( () => r0(e, a));
                            let l = o.docs.has(r);
                            !l && o.fromCache ? i.reject(new sk(sD.UNAVAILABLE,"Failed to get document because the client is offline.")) : l && o.fromCache && n && "server" === n.source ? i.reject(new sk(sD.UNAVAILABLE,'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(o)
                        }
                        ,
                        error: e => i.reject(e)
                    })
                      , a = new uF(eB(r.path),s,{
                        includeMetadataChanges: !0,
                        Fa: !0
                    });
                    return rZ(e, a)
                }
                )(await nB(e), e.asyncQueue, t, r, n)),
                n.promise
            }
            function nU(e, t, r={}) {
                let n = new sN;
                return e.asyncQueue.enqueueAndForget(async () => (function(e, t, r, n, i) {
                    let s = new uZ({
                        next: r => {
                            s.yu(),
                            t.enqueueAndForget( () => r0(e, a)),
                            r.fromCache && "server" === n.source ? i.reject(new sk(sD.UNAVAILABLE,'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(r)
                        }
                        ,
                        error: e => i.reject(e)
                    })
                      , a = new uF(r,s,{
                        includeMetadataChanges: !0,
                        Fa: !0
                    });
                    return rZ(e, a)
                }
                )(await nB(e), e.asyncQueue, t, r, n)),
                n.promise
            }
            function nq(e) {
                let t = {};
                return void 0 !== e.timeoutSeconds && (t.timeoutSeconds = e.timeoutSeconds),
                t
            }
            let u5 = new Map;
            function nj(e, t, r) {
                if (!r)
                    throw new sk(sD.INVALID_ARGUMENT,`Function ${e}() cannot be called with an empty ${t}.`)
            }
            function nz(e, t, r, n) {
                if (!0 === t && !0 === n)
                    throw new sk(sD.INVALID_ARGUMENT,`${e} and ${r} cannot be used together.`)
            }
            function nQ(e) {
                if (!sW.isDocumentKey(e))
                    throw new sk(sD.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)
            }
            function nK(e) {
                if (sW.isDocumentKey(e))
                    throw new sk(sD.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)
            }
            function n$(e) {
                if (void 0 === e)
                    return "undefined";
                if (null === e)
                    return "null";
                if ("string" == typeof e)
                    return e.length > 20 && (e = `${e.substring(0, 20)}...`),
                    JSON.stringify(e);
                if ("number" == typeof e || "boolean" == typeof e)
                    return "" + e;
                if ("object" == typeof e) {
                    if (e instanceof Array)
                        return "an array";
                    {
                        var t;
                        let r = (t = e).constructor ? t.constructor.name : null;
                        return r ? `a custom ${r} object` : "an object"
                    }
                }
                return "function" == typeof e ? "a function" : E(12329, {
                    type: typeof e
                })
            }
            function nG(e, t) {
                if ("_delegate"in e && (e = e._delegate),
                !(e instanceof t)) {
                    if (t.name === e.constructor.name)
                        throw new sk(sD.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
                    {
                        let r = n$(e);
                        throw new sk(sD.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${r}`)
                    }
                }
                return e
            }
            function nH(e, t) {
                if (t <= 0)
                    throw new sk(sD.INVALID_ARGUMENT,`Function ${e}() requires a positive number, but it was: ${t}.`)
            }
            let u4 = "firestore.googleapis.com";
            class u8 {
                constructor(e) {
                    var t, r;
                    if (void 0 === e.host) {
                        if (void 0 !== e.ssl)
                            throw new sk(sD.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");
                        this.host = u4,
                        this.ssl = !0
                    } else
                        this.host = e.host,
                        this.ssl = null == (t = e.ssl) || t;
                    if (this.isUsingEmulator = void 0 !== e.emulatorOptions,
                    this.credentials = e.credentials,
                    this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties,
                    this.localCache = e.localCache,
                    void 0 === e.cacheSizeBytes)
                        this.cacheSizeBytes = 0x2800000;
                    else {
                        if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576)
                            throw new sk(sD.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");
                        this.cacheSizeBytes = e.cacheSizeBytes
                    }
                    nz("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling),
                    this.experimentalForceLongPolling = !!e.experimentalForceLongPolling,
                    this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : void 0 === e.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling,
                    this.experimentalLongPollingOptions = nq(null != (r = e.experimentalLongPollingOptions) ? r : {}),
                    function(e) {
                        if (void 0 !== e.timeoutSeconds) {
                            if (isNaN(e.timeoutSeconds))
                                throw new sk(sD.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);
                            if (e.timeoutSeconds < 5)
                                throw new sk(sD.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);
                            if (e.timeoutSeconds > 30)
                                throw new sk(sD.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`)
                        }
                    }(this.experimentalLongPollingOptions),
                    this.useFetchStreams = !!e.useFetchStreams
                }
                isEqual(e) {
                    var t, r;
                    return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && (t = this.experimentalLongPollingOptions,
                    r = e.experimentalLongPollingOptions,
                    t.timeoutSeconds === r.timeoutSeconds) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams
                }
            }
            class u7 {
                constructor(e, t, r, n) {
                    this._authCredentials = e,
                    this._appCheckCredentials = t,
                    this._databaseId = r,
                    this._app = n,
                    this.type = "firestore-lite",
                    this._persistenceKey = "(lite)",
                    this._settings = new u8({}),
                    this._settingsFrozen = !1,
                    this._emulatorOptions = {},
                    this._terminateTask = "notTerminated"
                }
                get app() {
                    if (!this._app)
                        throw new sk(sD.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");
                    return this._app
                }
                get _initialized() {
                    return this._settingsFrozen
                }
                get _terminated() {
                    return "notTerminated" !== this._terminateTask
                }
                _setSettings(e) {
                    if (this._settingsFrozen)
                        throw new sk(sD.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
                    this._settings = new u8(e),
                    this._emulatorOptions = e.emulatorOptions || {},
                    void 0 !== e.credentials && (this._authCredentials = function(e) {
                        if (!e)
                            return new sR;
                        switch (e.type) {
                        case "firstParty":
                            return new sF(e.sessionIndex || "0",e.iamToken || null,e.authTokenFactory || null);
                        case "provider":
                            return e.client;
                        default:
                            throw new sk(sD.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")
                        }
                    }(e.credentials))
                }
                _getSettings() {
                    return this._settings
                }
                _getEmulatorOptions() {
                    return this._emulatorOptions
                }
                _freezeSettings() {
                    return this._settingsFrozen = !0,
                    (0,
                    d.updateEmulatorBanner)("Firestore", this._settings.isUsingEmulator),
                    this._settings
                }
                _delete() {
                    return "notTerminated" === this._terminateTask && (this._terminateTask = this._terminate()),
                    this._terminateTask
                }
                async _restart() {
                    "notTerminated" === this._terminateTask ? await this._terminate() : this._terminateTask = "notTerminated"
                }
                toJSON() {
                    return {
                        app: this._app,
                        databaseId: this._databaseId,
                        settings: this._settings
                    }
                }
                _terminate() {
                    return function(e) {
                        let t = u5.get(e);
                        t && (y("ComponentProvider", "Removing Datastore"),
                        u5.delete(e),
                        t.terminate())
                    }(this),
                    Promise.resolve()
                }
            }
            function nW(e, t, r, n={}) {
                var i;
                e = nG(e, u7);
                let s = (0,
                d.isCloudWorkstation)(t)
                  , a = e._getSettings()
                  , o = Object.assign(Object.assign({}, a), {
                    emulatorOptions: e._getEmulatorOptions()
                })
                  , l = `${t}:${r}`;
                a.host !== u4 && a.host !== l && w("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.");
                let u = Object.assign(Object.assign({}, a), {
                    host: l,
                    ssl: s,
                    emulatorOptions: n
                });
                if (!(0,
                d.deepEqual)(u, o) && (e._setSettings(u),
                s && ((0,
                d.pingServer)(`https://${l}`),
                (0,
                d.updateEmulatorBanner)("Firestore", !0)),
                n.mockUserToken)) {
                    let t, r;
                    if ("string" == typeof n.mockUserToken)
                        t = n.mockUserToken,
                        r = sC.MOCK_USER;
                    else {
                        t = (0,
                        d.createMockUserToken)(n.mockUserToken, null == (i = e._app) ? void 0 : i.options.projectId);
                        let s = n.mockUserToken.sub || n.mockUserToken.user_id;
                        if (!s)
                            throw new sk(sD.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");
                        r = new sC(s)
                    }
                    e._authCredentials = new sM(new sO(t,r))
                }
            }
            class u9 {
                constructor(e, t, r) {
                    this.converter = t,
                    this._query = r,
                    this.type = "query",
                    this.firestore = e
                }
                withConverter(e) {
                    return new u9(this.firestore,e,this._query)
                }
            }
            class he {
                constructor(e, t, r) {
                    this.converter = t,
                    this._key = r,
                    this.type = "document",
                    this.firestore = e
                }
                get _path() {
                    return this._key.path
                }
                get id() {
                    return this._key.path.lastSegment()
                }
                get path() {
                    return this._key.path.canonicalString()
                }
                get parent() {
                    return new ht(this.firestore,this.converter,this._key.path.popLast())
                }
                withConverter(e) {
                    return new he(this.firestore,e,this._key)
                }
            }
            class ht extends u9 {
                constructor(e, t, r) {
                    super(e, t, eB(r)),
                    this._path = r,
                    this.type = "collection"
                }
                get id() {
                    return this._query.path.lastSegment()
                }
                get path() {
                    return this._query.path.canonicalString()
                }
                get parent() {
                    let e = this._path.popLast();
                    return e.isEmpty() ? null : new he(this.firestore,null,new sW(e))
                }
                withConverter(e) {
                    return new ht(this.firestore,e,this._path)
                }
            }
            function nJ(e, t, ...r) {
                if (e = (0,
                d.getModularInstance)(e),
                nj("collection", "path", t),
                e instanceof u7) {
                    let n = s$.fromString(t, ...r);
                    return nK(n),
                    new ht(e,null,n)
                }
                {
                    if (!(e instanceof he || e instanceof ht))
                        throw new sk(sD.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
                    let n = e._path.child(s$.fromString(t, ...r));
                    return nK(n),
                    new ht(e.firestore,null,n)
                }
            }
            function nY(e, t) {
                if (e = nG(e, u7),
                nj("collectionGroup", "collection id", t),
                t.indexOf("/") >= 0)
                    throw new sk(sD.INVALID_ARGUMENT,`Invalid collection ID '${t}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
                return new u9(e,null,new oR(s$.emptyPath(),t))
            }
            function nX(e, t, ...r) {
                if (e = (0,
                d.getModularInstance)(e),
                1 == arguments.length && (t = sq.newId()),
                nj("doc", "path", t),
                e instanceof u7) {
                    let n = s$.fromString(t, ...r);
                    return nQ(n),
                    new he(e,null,new sW(n))
                }
                {
                    if (!(e instanceof he || e instanceof ht))
                        throw new sk(sD.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
                    let n = e._path.child(s$.fromString(t, ...r));
                    return nQ(n),
                    new he(e.firestore,e instanceof ht ? e.converter : null,new sW(n))
                }
            }
            function nZ(e, t) {
                return e = (0,
                d.getModularInstance)(e),
                t = (0,
                d.getModularInstance)(t),
                (e instanceof he || e instanceof ht) && (t instanceof he || t instanceof ht) && e.firestore === t.firestore && e.path === t.path && e.converter === t.converter
            }
            function n0(e, t) {
                return e = (0,
                d.getModularInstance)(e),
                t = (0,
                d.getModularInstance)(t),
                e instanceof u9 && t instanceof u9 && e.firestore === t.firestore && eG(e._query, t._query) && e.converter === t.converter
            }
            let hr = "AsyncQueue";
            class hn {
                constructor(e=Promise.resolve()) {
                    this.Qu = [],
                    this.$u = !1,
                    this.Uu = [],
                    this.Ku = null,
                    this.Wu = !1,
                    this.Gu = !1,
                    this.zu = [],
                    this.y_ = new uE(this,"async_queue_retry"),
                    this.ju = () => {
                        let e = r_();
                        e && y(hr, "Visibility state changed to " + e.visibilityState),
                        this.y_.A_()
                    }
                    ,
                    this.Hu = e;
                    let t = r_();
                    t && "function" == typeof t.addEventListener && t.addEventListener("visibilitychange", this.ju)
                }
                get isShuttingDown() {
                    return this.$u
                }
                enqueueAndForget(e) {
                    this.enqueue(e)
                }
                enqueueAndForgetEvenWhileRestricted(e) {
                    this.Ju(),
                    this.Yu(e)
                }
                enterRestrictedMode(e) {
                    if (!this.$u) {
                        this.$u = !0,
                        this.Gu = e || !1;
                        let t = r_();
                        t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.ju)
                    }
                }
                enqueue(e) {
                    if (this.Ju(),
                    this.$u)
                        return new Promise( () => {}
                        );
                    let t = new sN;
                    return this.Yu( () => this.$u && this.Gu ? Promise.resolve() : (e().then(t.resolve, t.reject),
                    t.promise)).then( () => t.promise)
                }
                enqueueRetryable(e) {
                    this.enqueueAndForget( () => (this.Qu.push(e),
                    this.Zu()))
                }
                async Zu() {
                    if (0 !== this.Qu.length) {
                        try {
                            await this.Qu[0](),
                            this.Qu.shift(),
                            this.y_.reset()
                        } catch (e) {
                            if (!B(e))
                                throw e;
                            y(hr, "Operation failed with retryable error: " + e)
                        }
                        this.Qu.length > 0 && this.y_.E_( () => this.Zu())
                    }
                }
                Yu(e) {
                    let t = this.Hu.then( () => (this.Wu = !0,
                    e().catch(e => {
                        throw this.Ku = e,
                        this.Wu = !1,
                        v("INTERNAL UNHANDLED ERROR: ", n1(e)),
                        e
                    }
                    ).then(e => (this.Wu = !1,
                    e))));
                    return this.Hu = t,
                    t
                }
                enqueueAfterDelay(e, t, r) {
                    this.Ju(),
                    this.zu.indexOf(e) > -1 && (t = 0);
                    let n = uN.createAndSchedule(this, e, t, r, e => this.Xu(e));
                    return this.Uu.push(n),
                    n
                }
                Ju() {
                    this.Ku && E(47125, {
                        ec: n1(this.Ku)
                    })
                }
                verifyOperationInProgress() {}
                async tc() {
                    let e;
                    do
                        e = this.Hu,
                        await e;
                    while (e !== this.Hu)
                }
                nc(e) {
                    for (let t of this.Uu)
                        if (t.timerId === e)
                            return !0;
                    return !1
                }
                rc(e) {
                    return this.tc().then( () => {
                        for (let t of (this.Uu.sort( (e, t) => e.targetTimeMs - t.targetTimeMs),
                        this.Uu))
                            if (t.skipDelay(),
                            "all" !== e && t.timerId === e)
                                break;
                        return this.tc()
                    }
                    )
                }
                sc(e) {
                    this.zu.push(e)
                }
                Xu(e) {
                    let t = this.Uu.indexOf(e);
                    this.Uu.splice(t, 1)
                }
            }
            function n1(e) {
                let t = e.message || "";
                return e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + "\n" + e.stack),
                t
            }
            function n2(e) {
                if ("object" != typeof e || null === e)
                    return !1;
                for (let t of ["next", "error", "complete"])
                    if (t in e && "function" == typeof e[t])
                        return !0;
                return !1
            }
            class hi {
                constructor() {
                    this._progressObserver = {},
                    this._taskCompletionResolver = new sN,
                    this._lastProgress = {
                        taskState: "Running",
                        totalBytes: 0,
                        totalDocuments: 0,
                        bytesLoaded: 0,
                        documentsLoaded: 0
                    }
                }
                onProgress(e, t, r) {
                    this._progressObserver = {
                        next: e,
                        error: t,
                        complete: r
                    }
                }
                catch(e) {
                    return this._taskCompletionResolver.promise.catch(e)
                }
                then(e, t) {
                    return this._taskCompletionResolver.promise.then(e, t)
                }
                _completeWith(e) {
                    this._updateProgress(e),
                    this._progressObserver.complete && this._progressObserver.complete(),
                    this._taskCompletionResolver.resolve(e)
                }
                _failWith(e) {
                    this._lastProgress.taskState = "Error",
                    this._progressObserver.next && this._progressObserver.next(this._lastProgress),
                    this._progressObserver.error && this._progressObserver.error(e),
                    this._taskCompletionResolver.reject(e)
                }
                _updateProgress(e) {
                    this._lastProgress = e,
                    this._progressObserver.next && this._progressObserver.next(e)
                }
            }
            let hs = -1;
            class ha extends u7 {
                constructor(e, t, r, n) {
                    super(e, t, r, n),
                    this.type = "firestore",
                    this._queue = new hn,
                    this._persistenceKey = (null == n ? void 0 : n.name) || "[DEFAULT]"
                }
                async _terminate() {
                    if (this._firestoreClient) {
                        let e = this._firestoreClient.terminate();
                        this._queue = new hn(e),
                        this._firestoreClient = void 0,
                        await e
                    }
                }
            }
            function n6(e, t, r) {
                r || (r = ou);
                let n = (0,
                u._getProvider)(e, "firestore");
                if (n.isInitialized(r)) {
                    let e = n.getImmediate({
                        identifier: r
                    })
                      , i = n.getOptions(r);
                    if ((0,
                    d.deepEqual)(i, t))
                        return e;
                    throw new sk(sD.FAILED_PRECONDITION,"initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.")
                }
                if (void 0 !== t.cacheSizeBytes && void 0 !== t.localCache)
                    throw new sk(sD.INVALID_ARGUMENT,"cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes willbe deprecated. Instead, specify the cache size in the cache object");
                if (void 0 !== t.cacheSizeBytes && -1 !== t.cacheSizeBytes && t.cacheSizeBytes < 1048576)
                    throw new sk(sD.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");
                return t.host && (0,
                d.isCloudWorkstation)(t.host) && (0,
                d.pingServer)(t.host),
                n.initialize({
                    options: t,
                    instanceIdentifier: r
                })
            }
            function n3(e, t) {
                let r = "object" == typeof e ? e : (0,
                u.getApp)()
                  , n = "string" == typeof e ? e : t || ou
                  , i = (0,
                u._getProvider)(r, "firestore").getImmediate({
                    identifier: n
                });
                if (!i._initialized) {
                    let e = (0,
                    d.getDefaultEmulatorHostnameAndPort)("firestore");
                    e && nW(i, ...e)
                }
                return i
            }
            function n5(e) {
                if (e._terminated)
                    throw new sk(sD.FAILED_PRECONDITION,"The client has already been terminated.");
                return e._firestoreClient || n4(e),
                e._firestoreClient
            }
            function n4(e) {
                var t, r, n, i, s;
                let a = e._freezeSettings()
                  , o = (i = e._databaseId,
                s = (null == (t = e._app) ? void 0 : t.options.appId) || "",
                new ol(i,s,e._persistenceKey,a.host,a.ssl,a.experimentalForceLongPolling,a.experimentalAutoDetectLongPolling,nq(a.experimentalLongPollingOptions),a.useFetchStreams,a.isUsingEmulator));
                e._componentsProvider || (null == (r = a.localCache) ? void 0 : r._offlineComponentProvider) && (null == (n = a.localCache) ? void 0 : n._onlineComponentProvider) && (e._componentsProvider = {
                    _offline: a.localCache._offlineComponentProvider,
                    _online: a.localCache._onlineComponentProvider
                }),
                e._firestoreClient = new u3(e._authCredentials,e._appCheckCredentials,e._queue,o,e._componentsProvider && function(e) {
                    let t = null == e ? void 0 : e._online.build();
                    return {
                        _offline: null == e ? void 0 : e._offline.build(t),
                        _online: t
                    }
                }(e._componentsProvider))
            }
            function n8(e, t) {
                w("enableIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.");
                let r = e._freezeSettings();
                return n9(e, uX.provider, {
                    build: e => new uJ(e,r.cacheSizeBytes,null == t ? void 0 : t.forceOwnership)
                }),
                Promise.resolve()
            }
            async function n7(e) {
                w("enableMultiTabIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.");
                let t = e._freezeSettings();
                n9(e, uX.provider, {
                    build: e => new uY(e,t.cacheSizeBytes)
                })
            }
            function n9(e, t, r) {
                if ((e = nG(e, ha))._firestoreClient || e._terminated)
                    throw new sk(sD.FAILED_PRECONDITION,"Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
                if (e._componentsProvider || e._getSettings().localCache)
                    throw new sk(sD.FAILED_PRECONDITION,"SDK cache is already specified.");
                e._componentsProvider = {
                    _online: t,
                    _offline: r
                },
                n4(e)
            }
            function ie(e) {
                if (e._initialized && !e._terminated)
                    throw new sk(sD.FAILED_PRECONDITION,"Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
                let t = new sN;
                return e._queue.enqueueAndForgetEvenWhileRestricted(async () => {
                    try {
                        await async function(e) {
                            if (!s5.C())
                                return Promise.resolve();
                            await s5.delete(e + l6)
                        }(ra(e._databaseId, e._persistenceKey)),
                        t.resolve()
                    } catch (e) {
                        t.reject(e)
                    }
                }
                ),
                t.promise
            }
            function it(e) {
                var t = n5(e = nG(e, ha));
                let r = new sN;
                return t.asyncQueue.enqueueAndForget(async () => no(await nL(t), r)),
                r.promise
            }
            function ir(e) {
                var t;
                return (t = n5(e = nG(e, ha))).asyncQueue.enqueue(async () => {
                    let e = await nR(t)
                      , r = await nP(t);
                    return e.setNetworkEnabled(!0),
                    r.aa.delete(0),
                    rS(r)
                }
                )
            }
            function ii(e) {
                var t;
                return (t = n5(e = nG(e, ha))).asyncQueue.enqueue(async () => {
                    let e = await nR(t)
                      , r = await nP(t);
                    return e.setNetworkEnabled(!1),
                    async function(e) {
                        e.aa.add(0),
                        await rC(e),
                        e.la.set("Offline")
                    }(r)
                }
                )
            }
            function is(e) {
                return (0,
                u._removeServiceInstance)(e.app, "firestore", e._databaseId.database),
                e._delete()
            }
            function ia(e, t) {
                let r = n5(e = nG(e, ha))
                  , n = new hi;
                return function(e, t, r, n) {
                    var i;
                    let s = (i = rT(t),
                    new u0(function(e, t) {
                        if (e instanceof Uint8Array)
                            return nA(e, void 0);
                        if (e instanceof ArrayBuffer)
                            return nA(new Uint8Array(e), void 0);
                        if (e instanceof ReadableStream)
                            return e.getReader();
                        throw Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream")
                    }("string" == typeof r ? S().encode(r) : r),i));
                    e.asyncQueue.enqueueAndForget(async () => {
                        var t;
                        (async function(e, t, r) {
                            try {
                                var n;
                                let i = await t.getMetadata();
                                if (await function(e, t) {
                                    let r = ty(t.createTime);
                                    return e.persistence.runTransaction("hasNewerBundle", "readonly", r => e.ci.getBundleMetadata(r, t.id)).then(e => !!e && e.createTime.compareTo(r) >= 0)
                                }(e.localStore, i))
                                    return await t.close(),
                                    r._completeWith({
                                        taskState: "Success",
                                        documentsLoaded: i.totalDocuments,
                                        bytesLoaded: i.totalBytes,
                                        totalDocuments: i.totalDocuments,
                                        totalBytes: i.totalBytes
                                    }),
                                    Promise.resolve(new Set);
                                r._updateProgress(r3(i));
                                let s = new uU(i,e.localStore,t.serializer)
                                  , a = await t.du();
                                for (; a; ) {
                                    let e = await s.Na(a);
                                    e && r._updateProgress(e),
                                    a = await t.du()
                                }
                                let o = await s.complete();
                                return await np(e, o.ka, void 0),
                                await (n = e.localStore,
                                n.persistence.runTransaction("Save bundle", "readwrite", e => n.ci.saveBundleMetadata(e, i))),
                                r._completeWith(o.progress),
                                Promise.resolve(o.La)
                            } catch (e) {
                                return w(uQ, `Loading bundle failed with ${e}`),
                                r._failWith(e),
                                Promise.resolve(new Set)
                            }
                        }
                        )(t = await nL(e), s, n).then(e => {
                            t.sharedClientState.notifyBundleLoaded(e)
                        }
                        )
                    }
                    )
                }(r, e._databaseId, t, n),
                n
            }
            function io(e, t) {
                var r;
                return (r = n5(e = nG(e, ha)),
                r.asyncQueue.enqueue(async () => {
                    var e;
                    return e = await nM(r),
                    e.persistence.runTransaction("Get named query", "readonly", r => e.ci.getNamedQuery(r, t))
                }
                )).then(t => t ? new u9(e,null,t.query) : null)
            }
            class ho {
                constructor(e="count", t) {
                    this._internalFieldPath = t,
                    this.type = "AggregateField",
                    this.aggregateType = e
                }
            }
            class hl {
                constructor(e, t, r) {
                    this._userDataWriter = t,
                    this._data = r,
                    this.type = "AggregateQuerySnapshot",
                    this.query = e
                }
                data() {
                    return this._userDataWriter.convertObjectMap(this._data)
                }
            }
            class hu {
                constructor(e) {
                    this._byteString = e
                }
                static fromBase64String(e) {
                    try {
                        return new hu(or.fromBase64String(e))
                    } catch (e) {
                        throw new sk(sD.INVALID_ARGUMENT,"Failed to construct data from Base64 string: " + e)
                    }
                }
                static fromUint8Array(e) {
                    return new hu(or.fromUint8Array(e))
                }
                toBase64() {
                    return this._byteString.toBase64()
                }
                toUint8Array() {
                    return this._byteString.toUint8Array()
                }
                toString() {
                    return "Bytes(base64: " + this.toBase64() + ")"
                }
                isEqual(e) {
                    return this._byteString.isEqual(e._byteString)
                }
            }
            class hh {
                constructor(...e) {
                    for (let t = 0; t < e.length; ++t)
                        if (0 === e[t].length)
                            throw new sk(sD.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");
                    this._internalPath = new sH(e)
                }
                isEqual(e) {
                    return this._internalPath.isEqual(e._internalPath)
                }
            }
            function il() {
                return new hh(sQ)
            }
            class hc {
                constructor(e) {
                    this._methodName = e
                }
            }
            class hd {
                constructor(e, t) {
                    if (!isFinite(e) || e < -90 || e > 90)
                        throw new sk(sD.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: " + e);
                    if (!isFinite(t) || t < -180 || t > 180)
                        throw new sk(sD.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: " + t);
                    this._lat = e,
                    this._long = t
                }
                get latitude() {
                    return this._lat
                }
                get longitude() {
                    return this._long
                }
                isEqual(e) {
                    return this._lat === e._lat && this._long === e._long
                }
                toJSON() {
                    return {
                        latitude: this._lat,
                        longitude: this._long
                    }
                }
                _compareTo(e) {
                    return C(this._lat, e._lat) || C(this._long, e._long)
                }
            }
            class hf {
                constructor(e) {
                    this._values = (e || []).map(e => e)
                }
                toArray() {
                    return this._values.map(e => e)
                }
                isEqual(e) {
                    return function(e, t) {
                        if (e.length !== t.length)
                            return !1;
                        for (let r = 0; r < e.length; ++r)
                            if (e[r] !== t[r])
                                return !1;
                        return !0
                    }(this._values, e._values)
                }
            }
            let hp = /^__.*__$/;
            class hg {
                constructor(e, t, r) {
                    this.data = e,
                    this.fieldMask = t,
                    this.fieldTransforms = r
                }
                toMutation(e, t) {
                    return null !== this.fieldMask ? new oJ(e,this.data,this.fieldMask,t,this.fieldTransforms) : new oW(e,this.data,t,this.fieldTransforms)
                }
            }
            class hm {
                constructor(e, t, r) {
                    this.data = e,
                    this.fieldMask = t,
                    this.fieldTransforms = r
                }
                toMutation(e, t) {
                    return new oJ(e,this.data,this.fieldMask,t,this.fieldTransforms)
                }
            }
            function iu(e) {
                switch (e) {
                case 0:
                case 2:
                case 1:
                    return !0;
                case 3:
                case 4:
                    return !1;
                default:
                    throw E(40011, {
                        oc: e
                    })
                }
            }
            class hy {
                constructor(e, t, r, n, i, s) {
                    this.settings = e,
                    this.databaseId = t,
                    this.serializer = r,
                    this.ignoreUndefinedProperties = n,
                    void 0 === i && this._c(),
                    this.fieldTransforms = i || [],
                    this.fieldMask = s || []
                }
                get path() {
                    return this.settings.path
                }
                get oc() {
                    return this.settings.oc
                }
                ac(e) {
                    return new hy(Object.assign(Object.assign({}, this.settings), e),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)
                }
                uc(e) {
                    var t;
                    let r = null == (t = this.path) ? void 0 : t.child(e)
                      , n = this.ac({
                        path: r,
                        cc: !1
                    });
                    return n.lc(e),
                    n
                }
                hc(e) {
                    var t;
                    let r = null == (t = this.path) ? void 0 : t.child(e)
                      , n = this.ac({
                        path: r,
                        cc: !1
                    });
                    return n._c(),
                    n
                }
                Pc(e) {
                    return this.ac({
                        path: void 0,
                        cc: !0
                    })
                }
                Tc(e) {
                    return i_(e, this.settings.methodName, this.settings.Ic || !1, this.path, this.settings.Ec)
                }
                contains(e) {
                    return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field))
                }
                _c() {
                    if (this.path)
                        for (let e = 0; e < this.path.length; e++)
                            this.lc(this.path.get(e))
                }
                lc(e) {
                    if (0 === e.length)
                        throw this.Tc("Document fields must not be empty");
                    if (iu(this.oc) && hp.test(e))
                        throw this.Tc('Document fields cannot begin and end with "__"')
                }
            }
            class hv {
                constructor(e, t, r) {
                    this.databaseId = e,
                    this.ignoreUndefinedProperties = t,
                    this.serializer = r || rT(e)
                }
                dc(e, t, r, n=!1) {
                    return new hy({
                        oc: e,
                        methodName: t,
                        Ec: r,
                        path: sH.emptyPath(),
                        cc: !1,
                        Ic: n
                    },this.databaseId,this.serializer,this.ignoreUndefinedProperties)
                }
            }
            function ih(e) {
                let t = e._freezeSettings()
                  , r = rT(e._databaseId);
                return new hv(e._databaseId,!!t.ignoreUndefinedProperties,r)
            }
            function ic(e, t, r, n, i, s={}) {
                let a, o, l = e.dc(s.merge || s.mergeFields ? 2 : 0, t, r, i);
                ib("Data must be an object, but it was:", l, n);
                let u = iv(n, l);
                if (s.merge)
                    a = new oe(l.fieldMask),
                    o = l.fieldTransforms;
                else if (s.mergeFields) {
                    let e = [];
                    for (let n of s.mergeFields) {
                        let i = iE(t, n, r);
                        if (!l.contains(i))
                            throw new sk(sD.INVALID_ARGUMENT,`Field '${i}' is specified in your field mask but missing from your input data.`);
                        iT(e, i) || e.push(i)
                    }
                    a = new oe(e),
                    o = l.fieldTransforms.filter(e => a.covers(e.field))
                } else
                    a = null,
                    o = l.fieldTransforms;
                return new hg(new ov(u),a,o)
            }
            class hw extends hc {
                _toFieldTransform(e) {
                    if (2 !== e.oc)
                        throw 1 === e.oc ? e.Tc(`${this._methodName}() can only appear at the top level of your update data`) : e.Tc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
                    return e.fieldMask.push(e.path),
                    null
                }
                isEqual(e) {
                    return e instanceof hw
                }
            }
            function id(e, t, r) {
                return new hy({
                    oc: 3,
                    Ec: t.settings.Ec,
                    methodName: e._methodName,
                    cc: r
                },t.databaseId,t.serializer,t.ignoreUndefinedProperties)
            }
            class hb extends hc {
                _toFieldTransform(e) {
                    return new oK(e.path,new oq)
                }
                isEqual(e) {
                    return e instanceof hb
                }
            }
            class hE extends hc {
                constructor(e, t) {
                    super(e),
                    this.Ac = t
                }
                _toFieldTransform(e) {
                    let t = id(this, e, !0)
                      , r = new oj(this.Ac.map(e => iy(e, t)));
                    return new oK(e.path,r)
                }
                isEqual(e) {
                    return e instanceof hE && (0,
                    d.deepEqual)(this.Ac, e.Ac)
                }
            }
            class hI extends hc {
                constructor(e, t) {
                    super(e),
                    this.Ac = t
                }
                _toFieldTransform(e) {
                    let t = id(this, e, !0)
                      , r = new oz(this.Ac.map(e => iy(e, t)));
                    return new oK(e.path,r)
                }
                isEqual(e) {
                    return e instanceof hI && (0,
                    d.deepEqual)(this.Ac, e.Ac)
                }
            }
            class h_ extends hc {
                constructor(e, t) {
                    super(e),
                    this.Rc = t
                }
                _toFieldTransform(e) {
                    let t = new oQ(e.serializer,e5(e.serializer, this.Rc));
                    return new oK(e.path,t)
                }
                isEqual(e) {
                    return e instanceof h_ && this.Rc === e.Rc
                }
            }
            function ip(e, t, r, n) {
                let i = e.dc(1, t, r);
                ib("Data must be an object, but it was:", i, n);
                let s = []
                  , a = ov.empty();
                return H(n, (e, n) => {
                    let o = iI(t, e, r);
                    n = (0,
                    d.getModularInstance)(n);
                    let l = i.hc(o);
                    if (n instanceof hw)
                        s.push(o);
                    else {
                        let e = iy(n, l);
                        null != e && (s.push(o),
                        a.set(o, e))
                    }
                }
                ),
                new hm(a,new oe(s),i.fieldTransforms)
            }
            function ig(e, t, r, n, i, s) {
                let a = e.dc(1, t, r)
                  , o = [iE(t, n, r)]
                  , l = [i];
                if (s.length % 2 != 0)
                    throw new sk(sD.INVALID_ARGUMENT,`Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`);
                for (let e = 0; e < s.length; e += 2)
                    o.push(iE(t, s[e])),
                    l.push(s[e + 1]);
                let u = []
                  , h = ov.empty();
                for (let e = o.length - 1; e >= 0; --e)
                    if (!iT(u, o[e])) {
                        let t = o[e]
                          , r = l[e];
                        r = (0,
                        d.getModularInstance)(r);
                        let n = a.hc(t);
                        if (r instanceof hw)
                            u.push(t);
                        else {
                            let e = iy(r, n);
                            null != e && (u.push(t),
                            h.set(t, e))
                        }
                    }
                return new hm(h,new oe(u),a.fieldTransforms)
            }
            function im(e, t, r, n=!1) {
                return iy(r, e.dc(n ? 4 : 3, t))
            }
            function iy(e, t) {
                if (iw(e = (0,
                d.getModularInstance)(e)))
                    return ib("Unsupported field value:", t, e),
                    iv(e, t);
                if (e instanceof hc)
                    return function(e, t) {
                        if (!iu(t.oc))
                            throw t.Tc(`${e._methodName}() can only be used with update() and set()`);
                        if (!t.path)
                            throw t.Tc(`${e._methodName}() is not currently supported inside arrays`);
                        let r = e._toFieldTransform(t);
                        r && t.fieldTransforms.push(r)
                    }(e, t),
                    null;
                if (void 0 === e && t.ignoreUndefinedProperties)
                    return null;
                if (t.path && t.fieldMask.push(t.path),
                e instanceof Array) {
                    if (t.settings.cc && 4 !== t.oc)
                        throw t.Tc("Nested arrays are not supported");
                    let r = []
                      , n = 0;
                    for (let i of e) {
                        let e = iy(i, t.Pc(n));
                        null == e && (e = {
                            nullValue: "NULL_VALUE"
                        }),
                        r.push(e),
                        n++
                    }
                    return {
                        arrayValue: {
                            values: r
                        }
                    }
                }
                return function(e, t) {
                    if (null === (e = (0,
                    d.getModularInstance)(e)))
                        return {
                            nullValue: "NULL_VALUE"
                        };
                    if ("number" == typeof e)
                        return e5(t.serializer, e);
                    if ("boolean" == typeof e)
                        return {
                            booleanValue: e
                        };
                    if ("string" == typeof e)
                        return {
                            stringValue: e
                        };
                    if (e instanceof Date) {
                        let r = sj.fromDate(e);
                        return {
                            timestampValue: tg(t.serializer, r)
                        }
                    }
                    if (e instanceof sj) {
                        let r = new sj(e.seconds,1e3 * Math.floor(e.nanoseconds / 1e3));
                        return {
                            timestampValue: tg(t.serializer, r)
                        }
                    }
                    if (e instanceof hd)
                        return {
                            geoPointValue: {
                                latitude: e.latitude,
                                longitude: e.longitude
                            }
                        };
                    if (e instanceof hu)
                        return {
                            bytesValue: tm(t.serializer, e._byteString)
                        };
                    if (e instanceof he) {
                        let r = t.databaseId
                          , n = e.firestore._databaseId;
                        if (!n.isEqual(r))
                            throw t.Tc(`Document reference is for database ${n.projectId}/${n.database} but should be for database ${r.projectId}/${r.database}`);
                        return {
                            referenceValue: tv(e.firestore._databaseId || t.databaseId, e._key.path)
                        }
                    }
                    if (e instanceof hf)
                        return {
                            mapValue: {
                                fields: {
                                    [oc]: {
                                        stringValue: op
                                    },
                                    [og]: {
                                        arrayValue: {
                                            values: e.toArray().map(e => {
                                                if ("number" != typeof e)
                                                    throw t.Tc("VectorValues must only contain numeric values.");
                                                return e6(t.serializer, e)
                                            }
                                            )
                                        }
                                    }
                                }
                            }
                        };
                    throw t.Tc(`Unsupported field value: ${n$(e)}`)
                }(e, t)
            }
            function iv(e, t) {
                let r = {};
                return J(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : H(e, (e, n) => {
                    let i = iy(n, t.uc(e));
                    null != i && (r[e] = i)
                }
                ),
                {
                    mapValue: {
                        fields: r
                    }
                }
            }
            function iw(e) {
                return !("object" != typeof e || null === e || e instanceof Array || e instanceof Date || e instanceof sj || e instanceof hd || e instanceof hu || e instanceof he || e instanceof hc || e instanceof hf)
            }
            function ib(e, t, r) {
                if (!iw(r) || "object" != typeof r || null === r || Object.getPrototypeOf(r) !== Object.prototype && null !== Object.getPrototypeOf(r)) {
                    let n = n$(r);
                    throw "an object" === n ? t.Tc(e + " a custom object") : t.Tc(e + " " + n)
                }
            }
            function iE(e, t, r) {
                if ((t = (0,
                d.getModularInstance)(t))instanceof hh)
                    return t._internalPath;
                if ("string" == typeof t)
                    return iI(e, t);
                throw i_("Field path arguments must be of type string or ", e, !1, void 0, r)
            }
            let hT = RegExp("[~\\*/\\[\\]]");
            function iI(e, t, r) {
                if (t.search(hT) >= 0)
                    throw i_(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, r);
                try {
                    return new hh(...t.split("."))._internalPath
                } catch (n) {
                    throw i_(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, r)
                }
            }
            function i_(e, t, r, n, i) {
                let s = n && !n.isEmpty()
                  , a = void 0 !== i
                  , o = `Function ${t}() called with invalid data`;
                r && (o += " (via `toFirestore()`)"),
                o += ". ";
                let l = "";
                return (s || a) && (l += " (found",
                s && (l += ` in field ${n}`),
                a && (l += ` in document ${i}`),
                l += ")"),
                new sk(sD.INVALID_ARGUMENT,o + e + l)
            }
            function iT(e, t) {
                return e.some(e => e.isEqual(t))
            }
            class hS {
                constructor(e, t, r, n, i) {
                    this._firestore = e,
                    this._userDataWriter = t,
                    this._key = r,
                    this._document = n,
                    this._converter = i
                }
                get id() {
                    return this._key.path.lastSegment()
                }
                get ref() {
                    return new he(this._firestore,this._converter,this._key)
                }
                exists() {
                    return null !== this._document
                }
                data() {
                    if (this._document) {
                        if (this._converter) {
                            let e = new hC(this._firestore,this._userDataWriter,this._key,this._document,null);
                            return this._converter.fromFirestore(e)
                        }
                        return this._userDataWriter.convertValue(this._document.data.value)
                    }
                }
                get(e) {
                    if (this._document) {
                        let t = this._document.data.field(iS("DocumentSnapshot.get", e));
                        if (null !== t)
                            return this._userDataWriter.convertValue(t)
                    }
                }
            }
            class hC extends hS {
                data() {
                    return super.data()
                }
            }
            function iS(e, t) {
                return "string" == typeof t ? iI(e, t) : t instanceof hh ? t._internalPath : t._delegate._internalPath
            }
            function iC(e) {
                if ("L" === e.limitType && 0 === e.explicitOrderBy.length)
                    throw new sk(sD.UNIMPLEMENTED,"limitToLast() queries require specifying at least one orderBy() clause")
            }
            class hx {
            }
            class hA extends hx {
            }
            function ix(e, t, ...r) {
                let n = [];
                for (let i of (t instanceof hx && n.push(t),
                function(e) {
                    let t = e.filter(e => e instanceof hk).length
                      , r = e.filter(e => e instanceof hD).length;
                    if (t > 1 || t > 0 && r > 0)
                        throw new sk(sD.INVALID_ARGUMENT,"InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")
                }(n = n.concat(r)),
                n))
                    e = i._apply(e);
                return e
            }
            class hD extends hA {
                constructor(e, t, r) {
                    super(),
                    this._field = e,
                    this._op = t,
                    this._value = r,
                    this.type = "where"
                }
                static _create(e, t, r) {
                    return new hD(e,t,r)
                }
                _apply(e) {
                    let t = this._parse(e);
                    return iq(e._query, t),
                    new u9(e.firestore,e.converter,eK(e._query, t))
                }
                _parse(e) {
                    let t = ih(e.firestore);
                    return function(e, t, r, n, i, s, a) {
                        let o;
                        if (i.isKeyField()) {
                            if ("array-contains" === s || "array-contains-any" === s)
                                throw new sk(sD.INVALID_ARGUMENT,`Invalid Query. You can't perform '${s}' queries on documentId().`);
                            if ("in" === s || "not-in" === s) {
                                iU(a, s);
                                let t = [];
                                for (let r of a)
                                    t.push(iV(n, e, r));
                                o = {
                                    arrayValue: {
                                        values: t
                                    }
                                }
                            } else
                                o = iV(n, e, a)
                        } else
                            "in" !== s && "not-in" !== s && "array-contains-any" !== s || iU(a, s),
                            o = im(r, t, a, "in" === s || "not-in" === s);
                        return o_.create(i, s, o)
                    }(e._query, "where", t, e.firestore._databaseId, this._field, this._op, this._value)
                }
            }
            function iA(e, t, r) {
                let n = iS("where", e);
                return hD._create(n, t, r)
            }
            class hk extends hx {
                constructor(e, t) {
                    super(),
                    this.type = e,
                    this._queryConstraints = t
                }
                static _create(e, t) {
                    return new hk(e,t)
                }
                _parse(e) {
                    let t = this._queryConstraints.map(t => t._parse(e)).filter(e => e.getFilters().length > 0);
                    return 1 === t.length ? t[0] : oT.create(t, this._getOperator())
                }
                _apply(e) {
                    let t = this._parse(e);
                    return 0 === t.getFilters().length ? e : (function(e, t) {
                        let r = e;
                        for (let e of t.getFlattenedFilters())
                            iq(r, e),
                            r = eK(r, e)
                    }(e._query, t),
                    new u9(e.firestore,e.converter,eK(e._query, t)))
                }
                _getQueryConstraints() {
                    return this._queryConstraints
                }
                _getOperator() {
                    return "and" === this.type ? "and" : "or"
                }
            }
            function iD(...e) {
                return e.forEach(e => ij("or", e)),
                hk._create("or", e)
            }
            function ik(...e) {
                return e.forEach(e => ij("and", e)),
                hk._create("and", e)
            }
            class hN extends hA {
                constructor(e, t) {
                    super(),
                    this._field = e,
                    this._direction = t,
                    this.type = "orderBy"
                }
                static _create(e, t) {
                    return new hN(e,t)
                }
                _apply(e) {
                    let t = function(e, t, r) {
                        if (null !== e.startAt)
                            throw new sk(sD.INVALID_ARGUMENT,"Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
                        if (null !== e.endAt)
                            throw new sk(sD.INVALID_ARGUMENT,"Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
                        return new oE(t,r)
                    }(e._query, this._field, this._direction);
                    return new u9(e.firestore,e.converter,function(e, t) {
                        let r = e.explicitOrderBy.concat([t]);
                        return new oR(e.path,e.collectionGroup,r,e.filters.slice(),e.limit,e.limitType,e.startAt,e.endAt)
                    }(e._query, t))
                }
            }
            function iN(e, t="asc") {
                let r = iS("orderBy", e);
                return hN._create(r, t)
            }
            class hO extends hA {
                constructor(e, t, r) {
                    super(),
                    this.type = e,
                    this._limit = t,
                    this._limitType = r
                }
                static _create(e, t, r) {
                    return new hO(e,t,r)
                }
                _apply(e) {
                    return new u9(e.firestore,e.converter,e$(e._query, this._limit, this._limitType))
                }
            }
            function iO(e) {
                return nH("limit", e),
                hO._create("limit", e, "F")
            }
            function iR(e) {
                return nH("limitToLast", e),
                hO._create("limitToLast", e, "L")
            }
            class hR extends hA {
                constructor(e, t, r) {
                    super(),
                    this.type = e,
                    this._docOrFields = t,
                    this._inclusive = r
                }
                static _create(e, t, r) {
                    return new hR(e,t,r)
                }
                _apply(e) {
                    var t;
                    let r = iB(e, this.type, this._docOrFields, this._inclusive);
                    return new u9(e.firestore,e.converter,(t = e._query,
                    new oR(t.path,t.collectionGroup,t.explicitOrderBy.slice(),t.filters.slice(),t.limit,t.limitType,r,t.endAt)))
                }
            }
            function iM(...e) {
                return hR._create("startAt", e, !0)
            }
            function iP(...e) {
                return hR._create("startAfter", e, !1)
            }
            class hM extends hA {
                constructor(e, t, r) {
                    super(),
                    this.type = e,
                    this._docOrFields = t,
                    this._inclusive = r
                }
                static _create(e, t, r) {
                    return new hM(e,t,r)
                }
                _apply(e) {
                    var t;
                    let r = iB(e, this.type, this._docOrFields, this._inclusive);
                    return new u9(e.firestore,e.converter,(t = e._query,
                    new oR(t.path,t.collectionGroup,t.explicitOrderBy.slice(),t.filters.slice(),t.limit,t.limitType,t.startAt,r)))
                }
            }
            function iL(...e) {
                return hM._create("endBefore", e, !1)
            }
            function iF(...e) {
                return hM._create("endAt", e, !0)
            }
            function iB(e, t, r, n) {
                if (r[0] = (0,
                d.getModularInstance)(r[0]),
                r[0]instanceof hS)
                    return function(e, t, r, n, i) {
                        if (!n)
                            throw new sk(sD.NOT_FOUND,`Can't use a DocumentSnapshot that doesn't exist for ${r}().`);
                        let s = [];
                        for (let r of eq(e))
                            if (r.field.isKeyField())
                                s.push(ed(t, n.key));
                            else {
                                let e = n.data.field(r.field);
                                if (er(e))
                                    throw new sk(sD.INVALID_ARGUMENT,'Invalid query. You are trying to start or end a query using a document for which the field "' + r.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
                                if (null === e) {
                                    let e = r.field.canonicalString();
                                    throw new sk(sD.INVALID_ARGUMENT,`Invalid query. You are trying to start or end a query using a document for which the field '${e}' (used as the orderBy) does not exist.`)
                                }
                                s.push(e)
                            }
                        return new ob(s,i)
                    }(e._query, e.firestore._databaseId, t, r[0]._document, n);
                {
                    let i = ih(e.firestore);
                    return function(e, t, r, n, i, s) {
                        let a = e.explicitOrderBy;
                        if (i.length > a.length)
                            throw new sk(sD.INVALID_ARGUMENT,`Too many arguments provided to ${n}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
                        let o = [];
                        for (let s = 0; s < i.length; s++) {
                            let l = i[s];
                            if (a[s].field.isKeyField()) {
                                if ("string" != typeof l)
                                    throw new sk(sD.INVALID_ARGUMENT,`Invalid query. Expected a string for document ID in ${n}(), but got a ${typeof l}`);
                                if (!eU(e) && -1 !== l.indexOf("/"))
                                    throw new sk(sD.INVALID_ARGUMENT,`Invalid query. When querying a collection and ordering by documentId(), the value passed to ${n}() must be a plain document ID, but '${l}' contains a slash.`);
                                let r = e.path.child(s$.fromString(l));
                                if (!sW.isDocumentKey(r))
                                    throw new sk(sD.INVALID_ARGUMENT,`Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${n}() must result in a valid document path, but '${r}' is not because it contains an odd number of segments.`);
                                let i = new sW(r);
                                o.push(ed(t, i))
                            } else {
                                let e = im(r, n, l);
                                o.push(e)
                            }
                        }
                        return new ob(o,s)
                    }(e._query, e.firestore._databaseId, i, t, r, n)
                }
            }
            function iV(e, t, r) {
                if ("string" == typeof (r = (0,
                d.getModularInstance)(r))) {
                    if ("" === r)
                        throw new sk(sD.INVALID_ARGUMENT,"Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
                    if (!eU(t) && -1 !== r.indexOf("/"))
                        throw new sk(sD.INVALID_ARGUMENT,`Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${r}' contains a '/' character.`);
                    let n = t.path.child(s$.fromString(r));
                    if (!sW.isDocumentKey(n))
                        throw new sk(sD.INVALID_ARGUMENT,`Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${n}' is not because it has an odd number of segments (${n.length}).`);
                    return ed(e, new sW(n))
                }
                if (r instanceof he)
                    return ed(e, r._key);
                throw new sk(sD.INVALID_ARGUMENT,`Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${n$(r)}.`)
            }
            function iU(e, t) {
                if (!Array.isArray(e) || 0 === e.length)
                    throw new sk(sD.INVALID_ARGUMENT,`Invalid Query. A non-empty array is required for '${t.toString()}' filters.`)
            }
            function iq(e, t) {
                let r = function(e, t) {
                    for (let r of e)
                        for (let e of r.getFlattenedFilters())
                            if (t.indexOf(e.op) >= 0)
                                return e.op;
                    return null
                }(e.filters, function(e) {
                    switch (e) {
                    case "!=":
                        return ["!=", "not-in"];
                    case "array-contains-any":
                    case "in":
                        return ["not-in"];
                    case "not-in":
                        return ["array-contains-any", "in", "not-in", "!="];
                    default:
                        return []
                    }
                }(t.op));
                if (null !== r)
                    throw r === t.op ? new sk(sD.INVALID_ARGUMENT,`Invalid query. You cannot use more than one '${t.op.toString()}' filter.`) : new sk(sD.INVALID_ARGUMENT,`Invalid query. You cannot use '${t.op.toString()}' filters with '${r.toString()}' filters.`)
            }
            function ij(e, t) {
                if (!(t instanceof hD || t instanceof hk))
                    throw new sk(sD.INVALID_ARGUMENT,`Function ${e}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`)
            }
            class hP {
                convertValue(e, t="none") {
                    switch (es(e)) {
                    case 0:
                        return null;
                    case 1:
                        return e.booleanValue;
                    case 2:
                        return ee(e.integerValue || e.doubleValue);
                    case 3:
                        return this.convertTimestamp(e.timestampValue);
                    case 4:
                        return this.convertServerTimestamp(e, t);
                    case 5:
                        return e.stringValue;
                    case 6:
                        return this.convertBytes(et(e.bytesValue));
                    case 7:
                        return this.convertReference(e.referenceValue);
                    case 8:
                        return this.convertGeoPoint(e.geoPointValue);
                    case 9:
                        return this.convertArray(e.arrayValue, t);
                    case 11:
                        return this.convertObject(e.mapValue, t);
                    case 10:
                        return this.convertVectorValue(e.mapValue);
                    default:
                        throw E(62114, {
                            value: e
                        })
                    }
                }
                convertObject(e, t) {
                    return this.convertObjectMap(e.fields, t)
                }
                convertObjectMap(e, t="none") {
                    let r = {};
                    return H(e, (e, n) => {
                        r[e] = this.convertValue(n, t)
                    }
                    ),
                    r
                }
                convertVectorValue(e) {
                    var t, r, n;
                    return new hf(null == (n = null == (r = null == (t = e.fields) ? void 0 : t[og].arrayValue) ? void 0 : r.values) ? void 0 : n.map(e => ee(e.doubleValue)))
                }
                convertGeoPoint(e) {
                    return new hd(ee(e.latitude),ee(e.longitude))
                }
                convertArray(e, t) {
                    return (e.values || []).map(e => this.convertValue(e, t))
                }
                convertServerTimestamp(e, t) {
                    switch (t) {
                    case "previous":
                        let r = en(e);
                        return null == r ? null : this.convertValue(r, t);
                    case "estimate":
                        return this.convertTimestamp(ei(e));
                    default:
                        return null
                    }
                }
                convertTimestamp(e) {
                    let t = Z(e);
                    return new sj(t.seconds,t.nanos)
                }
                convertDocumentKey(e, t) {
                    let r = s$.fromString(e);
                    _(tF(r), 9688, {
                        name: e
                    });
                    let n = new oh(r.get(1),r.get(3))
                      , i = new sW(r.popFirst(5));
                    return n.isEqual(t) || v(`Document ${i} contains a document reference within a different database (${n.projectId}/${n.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`),
                    i
                }
            }
            function iz(e, t, r) {
                return e ? r && (r.merge || r.mergeFields) ? e.toFirestore(t, r) : e.toFirestore(t) : t
            }
            class hL extends hP {
                constructor(e) {
                    super(),
                    this.firestore = e
                }
                convertBytes(e) {
                    return new hu(e)
                }
                convertReference(e) {
                    let t = this.convertDocumentKey(e, this.firestore._databaseId);
                    return new he(this.firestore,null,t)
                }
            }
            function iQ(e) {
                return new ho("sum",iE("sum", e))
            }
            function iK(e) {
                return new ho("avg",iE("average", e))
            }
            function i$() {
                return new ho("count")
            }
            function iG(e, t) {
                var r, n;
                return e instanceof ho && t instanceof ho && e.aggregateType === t.aggregateType && (null == (r = e._internalFieldPath) ? void 0 : r.canonicalString()) === (null == (n = t._internalFieldPath) ? void 0 : n.canonicalString())
            }
            function iH(e, t) {
                return n0(e.query, t.query) && (0,
                d.deepEqual)(e.data(), t.data())
            }
            class hF {
                constructor(e, t) {
                    this.hasPendingWrites = e,
                    this.fromCache = t
                }
                isEqual(e) {
                    return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache
                }
            }
            class hB extends hS {
                constructor(e, t, r, n, i, s) {
                    super(e, t, r, n, s),
                    this._firestore = e,
                    this._firestoreImpl = e,
                    this.metadata = i
                }
                exists() {
                    return super.exists()
                }
                data(e={}) {
                    if (this._document) {
                        if (this._converter) {
                            let t = new hV(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);
                            return this._converter.fromFirestore(t, e)
                        }
                        return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps)
                    }
                }
                get(e, t={}) {
                    if (this._document) {
                        let r = this._document.data.field(iS("DocumentSnapshot.get", e));
                        if (null !== r)
                            return this._userDataWriter.convertValue(r, t.serverTimestamps)
                    }
                }
            }
            class hV extends hB {
                data(e={}) {
                    return super.data(e)
                }
            }
            class hU {
                constructor(e, t, r, n) {
                    this._firestore = e,
                    this._userDataWriter = t,
                    this._snapshot = n,
                    this.metadata = new hF(n.hasPendingWrites,n.fromCache),
                    this.query = r
                }
                get docs() {
                    let e = [];
                    return this.forEach(t => e.push(t)),
                    e
                }
                get size() {
                    return this._snapshot.docs.size
                }
                get empty() {
                    return 0 === this.size
                }
                forEach(e, t) {
                    this._snapshot.docs.forEach(r => {
                        e.call(t, new hV(this._firestore,this._userDataWriter,r.key,r,new hF(this._snapshot.mutatedKeys.has(r.key),this._snapshot.fromCache),this.query.converter))
                    }
                    )
                }
                docChanges(e={}) {
                    let t = !!e.includeMetadataChanges;
                    if (t && this._snapshot.excludesMetadataChanges)
                        throw new sk(sD.INVALID_ARGUMENT,"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
                    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t || (this._cachedChanges = function(e, t) {
                        if (e._snapshot.oldDocs.isEmpty()) {
                            let t = 0;
                            return e._snapshot.docChanges.map(r => {
                                let n = new hV(e._firestore,e._userDataWriter,r.doc.key,r.doc,new hF(e._snapshot.mutatedKeys.has(r.doc.key),e._snapshot.fromCache),e.query.converter);
                                return r.doc,
                                {
                                    type: "added",
                                    doc: n,
                                    oldIndex: -1,
                                    newIndex: t++
                                }
                            }
                            )
                        }
                        {
                            let r = e._snapshot.oldDocs;
                            return e._snapshot.docChanges.filter(e => t || 3 !== e.type).map(t => {
                                let n = new hV(e._firestore,e._userDataWriter,t.doc.key,t.doc,new hF(e._snapshot.mutatedKeys.has(t.doc.key),e._snapshot.fromCache),e.query.converter)
                                  , i = -1
                                  , s = -1;
                                return 0 !== t.type && (i = r.indexOf(t.doc.key),
                                r = r.delete(t.doc.key)),
                                1 !== t.type && (s = (r = r.add(t.doc)).indexOf(t.doc.key)),
                                {
                                    type: function(e) {
                                        switch (e) {
                                        case 0:
                                            return "added";
                                        case 2:
                                        case 3:
                                            return "modified";
                                        case 1:
                                            return "removed";
                                        default:
                                            return E(61501, {
                                                type: e
                                            })
                                        }
                                    }(t.type),
                                    doc: n,
                                    oldIndex: i,
                                    newIndex: s
                                }
                            }
                            )
                        }
                    }(this, t),
                    this._cachedChangesIncludeMetadataChanges = t),
                    this._cachedChanges
                }
            }
            function iW(e, t) {
                return e instanceof hB && t instanceof hB ? e._firestore === t._firestore && e._key.isEqual(t._key) && (null === e._document ? null === t._document : e._document.isEqual(t._document)) && e._converter === t._converter : e instanceof hU && t instanceof hU && e._firestore === t._firestore && n0(e.query, t.query) && e.metadata.isEqual(t.metadata) && e._snapshot.isEqual(t._snapshot)
            }
            function iJ(e) {
                e = nG(e, he);
                let t = nG(e.firestore, ha);
                return nV(n5(t), e._key).then(r => i9(t, e, r))
            }
            class hq extends hP {
                constructor(e) {
                    super(),
                    this.firestore = e
                }
                convertBytes(e) {
                    return new hu(e)
                }
                convertReference(e) {
                    let t = this.convertDocumentKey(e, this.firestore._databaseId);
                    return new he(this.firestore,null,t)
                }
            }
            function iY(e) {
                e = nG(e, he);
                let t = nG(e.firestore, ha)
                  , r = n5(t)
                  , n = new hq(t);
                return (function(e, t) {
                    let r = new sN;
                    return e.asyncQueue.enqueueAndForget(async () => (async function(e, t, r) {
                        try {
                            let n = await e.persistence.runTransaction("read document", "readonly", r => e.localDocuments.getDocument(r, t));
                            n.isFoundDocument() ? r.resolve(n) : n.isNoDocument() ? r.resolve(null) : r.reject(new sk(sD.UNAVAILABLE,"Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"))
                        } catch (n) {
                            let e = rY(n, `Failed to get document '${t} from cache`);
                            r.reject(e)
                        }
                    }
                    )(await nM(e), t, r)),
                    r.promise
                }
                )(r, e._key).then(r => new hB(t,n,e._key,r,new hF(null !== r && r.hasLocalMutations,!0),e.converter))
            }
            function iX(e) {
                e = nG(e, he);
                let t = nG(e.firestore, ha);
                return nV(n5(t), e._key, {
                    source: "server"
                }).then(r => i9(t, e, r))
            }
            function iZ(e) {
                e = nG(e, u9);
                let t = nG(e.firestore, ha)
                  , r = n5(t)
                  , n = new hq(t);
                return iC(e._query),
                nU(r, e._query).then(r => new hU(t,n,e,r))
            }
            function i0(e) {
                e = nG(e, u9);
                let t = nG(e.firestore, ha)
                  , r = n5(t)
                  , n = new hq(t);
                return (function(e, t) {
                    let r = new sN;
                    return e.asyncQueue.enqueueAndForget(async () => (async function(e, t, r) {
                        try {
                            let n = await rd(e, t, !0)
                              , i = new uz(t,n.Ns)
                              , s = i.Ga(n.documents)
                              , a = i.applyChanges(s, !1);
                            r.resolve(a.snapshot)
                        } catch (n) {
                            let e = rY(n, `Failed to execute query '${t} against cache`);
                            r.reject(e)
                        }
                    }
                    )(await nM(e), t, r)),
                    r.promise
                }
                )(r, e._query).then(r => new hU(t,n,e,r))
            }
            function i1(e) {
                e = nG(e, u9);
                let t = nG(e.firestore, ha)
                  , r = n5(t)
                  , n = new hq(t);
                return nU(r, e._query, {
                    source: "server"
                }).then(r => new hU(t,n,e,r))
            }
            function i2(e, t, r) {
                e = nG(e, he);
                let n = nG(e.firestore, ha)
                  , i = iz(e.converter, t, r);
                return i7(n, [ic(ih(n), "setDoc", e._key, i, null !== e.converter, r).toMutation(e._key, oG.none())])
            }
            function i6(e, t, r, ...n) {
                e = nG(e, he);
                let i = nG(e.firestore, ha)
                  , s = ih(i);
                return i7(i, [("string" == typeof (t = (0,
                d.getModularInstance)(t)) || t instanceof hh ? ig(s, "updateDoc", e._key, t, r, n) : ip(s, "updateDoc", e._key, t)).toMutation(e._key, oG.exists(!0))])
            }
            function i3(e) {
                return i7(nG(e.firestore, ha), [new oY(e._key,oG.none())])
            }
            function i5(e, t) {
                let r = nG(e.firestore, ha)
                  , n = nX(e)
                  , i = iz(e.converter, t);
                return i7(r, [ic(ih(e.firestore), "addDoc", n._key, i, null !== e.converter, {}).toMutation(n._key, oG.exists(!1))]).then( () => n)
            }
            function i4(e, ...t) {
                let r, n, i;
                e = (0,
                d.getModularInstance)(e);
                let s = {
                    includeMetadataChanges: !1,
                    source: "default"
                }
                  , a = 0;
                "object" != typeof t[0] || n2(t[a]) || (s = t[a],
                a++);
                let o = {
                    includeMetadataChanges: s.includeMetadataChanges,
                    source: s.source
                };
                if (n2(t[a])) {
                    let e = t[a];
                    t[a] = null == (l = e.next) ? void 0 : l.bind(e),
                    t[a + 1] = null == (u = e.error) ? void 0 : u.bind(e),
                    t[a + 2] = null == (h = e.complete) ? void 0 : h.bind(e)
                }
                if (e instanceof he)
                    n = nG(e.firestore, ha),
                    i = eB(e._key.path),
                    r = {
                        next: r => {
                            t[a] && t[a](i9(n, e, r))
                        }
                        ,
                        error: t[a + 1],
                        complete: t[a + 2]
                    };
                else {
                    let s = nG(e, u9);
                    n = nG(s.firestore, ha),
                    i = s._query;
                    let o = new hq(n);
                    r = {
                        next: e => {
                            t[a] && t[a](new hU(n,o,s,e))
                        }
                        ,
                        error: t[a + 1],
                        complete: t[a + 2]
                    },
                    iC(e._query)
                }
                var l, u, h, c = n5(n), f = i;
                let p = new uZ(r)
                  , g = new uF(f,p,o);
                return c.asyncQueue.enqueueAndForget(async () => rZ(await nB(c), g)),
                () => {
                    p.yu(),
                    c.asyncQueue.enqueueAndForget(async () => r0(await nB(c), g))
                }
            }
            function i8(e, t) {
                return function(e, t) {
                    let r = new uZ(t);
                    return e.asyncQueue.enqueueAndForget(async () => {
                        var t;
                        return t = await nB(e),
                        void (t.fa.add(r),
                        r.next())
                    }
                    ),
                    () => {
                        r.yu(),
                        e.asyncQueue.enqueueAndForget(async () => {
                            var t;
                            return t = await nB(e),
                            void t.fa.delete(r)
                        }
                        )
                    }
                }(n5(e = nG(e, ha)), n2(t) ? t : {
                    next: t
                })
            }
            function i7(e, t) {
                var r = n5(e);
                let n = new sN;
                return r.asyncQueue.enqueueAndForget(async () => nt(await nL(r), t, n)),
                n.promise
            }
            function i9(e, t, r) {
                let n = r.docs.get(t._key)
                  , i = new hq(e);
                return new hB(e,i,t._key,n,new hF(r.hasPendingWrites,r.fromCache),t.converter)
            }
            function se(e) {
                return st(e, {
                    count: i$()
                })
            }
            function st(e, t) {
                let r = nG(e.firestore, ha)
                  , n = n5(r)
                  , i = W(t, (e, t) => new o2(t,e.aggregateType,e._internalFieldPath));
                return (function(e, t, r) {
                    let n = new sN;
                    return e.asyncQueue.enqueueAndForget(async () => {
                        try {
                            let i = await nF(e);
                            n.resolve(async function(e, t, r) {
                                var n;
                                let {request: i, yt: s, parent: a} = tR(e.serializer, ez(t), r);
                                e.connection.Bo || delete i.parent;
                                let o = (await e.Wo("RunAggregationQuery", e.serializer.databaseId, a, i, 1)).filter(e => !!e.result);
                                _(1 === o.length, 64727);
                                let l = null == (n = o[0].result) ? void 0 : n.aggregateFields;
                                return Object.keys(l).reduce( (e, t) => (e[s[t]] = l[t],
                                e), {})
                            }(i, t, r))
                        } catch (e) {
                            n.reject(e)
                        }
                    }
                    ),
                    n.promise
                }
                )(n, e._query, i).then(t => new hl(e,new hq(r),t))
            }
            class hj {
                constructor(e) {
                    this.kind = "memory",
                    this._onlineComponentProvider = uX.provider,
                    (null == e ? void 0 : e.garbageCollector) ? this._offlineComponentProvider = e.garbageCollector._offlineComponentProvider : this._offlineComponentProvider = {
                        build: () => new uW(void 0)
                    }
                }
                toJSON() {
                    return {
                        kind: this.kind
                    }
                }
            }
            class hz {
                constructor(e) {
                    let t;
                    this.kind = "persistent",
                    (null == e ? void 0 : e.tabManager) ? (e.tabManager._initialize(e),
                    t = e.tabManager) : (t = sa(void 0))._initialize(e),
                    this._onlineComponentProvider = t._onlineComponentProvider,
                    this._offlineComponentProvider = t._offlineComponentProvider
                }
                toJSON() {
                    return {
                        kind: this.kind
                    }
                }
            }
            class hQ {
                constructor() {
                    this.kind = "memoryEager",
                    this._offlineComponentProvider = uH.provider
                }
                toJSON() {
                    return {
                        kind: this.kind
                    }
                }
            }
            class hK {
                constructor(e) {
                    this.kind = "memoryLru",
                    this._offlineComponentProvider = {
                        build: () => new uW(e)
                    }
                }
                toJSON() {
                    return {
                        kind: this.kind
                    }
                }
            }
            function sr() {
                return new hQ
            }
            function sn(e) {
                return new hK(null == e ? void 0 : e.cacheSizeBytes)
            }
            function si(e) {
                return new hj(e)
            }
            function ss(e) {
                return new hz(e)
            }
            class h$ {
                constructor(e) {
                    this.forceOwnership = e,
                    this.kind = "persistentSingleTab"
                }
                toJSON() {
                    return {
                        kind: this.kind
                    }
                }
                _initialize(e) {
                    this._onlineComponentProvider = uX.provider,
                    this._offlineComponentProvider = {
                        build: t => new uJ(t,null == e ? void 0 : e.cacheSizeBytes,this.forceOwnership)
                    }
                }
            }
            class hG {
                constructor() {
                    this.kind = "PersistentMultipleTab"
                }
                toJSON() {
                    return {
                        kind: this.kind
                    }
                }
                _initialize(e) {
                    this._onlineComponentProvider = uX.provider,
                    this._offlineComponentProvider = {
                        build: t => new uY(t,null == e ? void 0 : e.cacheSizeBytes)
                    }
                }
            }
            function sa(e) {
                return new h$(null == e ? void 0 : e.forceOwnership)
            }
            function so() {
                return new hG
            }
            let hH = {
                maxAttempts: 5
            };
            class hW {
                constructor(e, t) {
                    this._firestore = e,
                    this._commitHandler = t,
                    this._mutations = [],
                    this._committed = !1,
                    this._dataReader = ih(e)
                }
                set(e, t, r) {
                    this._verifyNotCommitted();
                    let n = sl(e, this._firestore)
                      , i = iz(n.converter, t, r)
                      , s = ic(this._dataReader, "WriteBatch.set", n._key, i, null !== n.converter, r);
                    return this._mutations.push(s.toMutation(n._key, oG.none())),
                    this
                }
                update(e, t, r, ...n) {
                    let i;
                    this._verifyNotCommitted();
                    let s = sl(e, this._firestore);
                    return i = "string" == typeof (t = (0,
                    d.getModularInstance)(t)) || t instanceof hh ? ig(this._dataReader, "WriteBatch.update", s._key, t, r, n) : ip(this._dataReader, "WriteBatch.update", s._key, t),
                    this._mutations.push(i.toMutation(s._key, oG.exists(!0))),
                    this
                }
                delete(e) {
                    this._verifyNotCommitted();
                    let t = sl(e, this._firestore);
                    return this._mutations = this._mutations.concat(new oY(t._key,oG.none())),
                    this
                }
                commit() {
                    return this._verifyNotCommitted(),
                    this._committed = !0,
                    this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
                }
                _verifyNotCommitted() {
                    if (this._committed)
                        throw new sk(sD.FAILED_PRECONDITION,"A write batch can no longer be used after commit() has been called.")
                }
            }
            function sl(e, t) {
                if ((e = (0,
                d.getModularInstance)(e)).firestore !== t)
                    throw new sk(sD.INVALID_ARGUMENT,"Provided document reference is from a different Firestore instance.");
                return e
            }
            class hJ {
                constructor(e, t) {
                    this._firestore = e,
                    this._transaction = t,
                    this._dataReader = ih(e)
                }
                get(e) {
                    let t = sl(e, this._firestore)
                      , r = new hL(this._firestore);
                    return this._transaction.lookup([t._key]).then(e => {
                        if (!e || 1 !== e.length)
                            return E(24041);
                        let n = e[0];
                        if (n.isFoundDocument())
                            return new hS(this._firestore,r,n.key,n,t.converter);
                        if (n.isNoDocument())
                            return new hS(this._firestore,r,t._key,null,t.converter);
                        throw E(18433, {
                            doc: n
                        })
                    }
                    )
                }
                set(e, t, r) {
                    let n = sl(e, this._firestore)
                      , i = iz(n.converter, t, r)
                      , s = ic(this._dataReader, "Transaction.set", n._key, i, null !== n.converter, r);
                    return this._transaction.set(n._key, s),
                    this
                }
                update(e, t, r, ...n) {
                    let i, s = sl(e, this._firestore);
                    return i = "string" == typeof (t = (0,
                    d.getModularInstance)(t)) || t instanceof hh ? ig(this._dataReader, "Transaction.update", s._key, t, r, n) : ip(this._dataReader, "Transaction.update", s._key, t),
                    this._transaction.update(s._key, i),
                    this
                }
                delete(e) {
                    let t = sl(e, this._firestore);
                    return this._transaction.delete(t._key),
                    this
                }
            }
            class hY extends hJ {
                constructor(e, t) {
                    super(e, t),
                    this._firestore = e
                }
                get(e) {
                    let t = sl(e, this._firestore)
                      , r = new hq(this._firestore);
                    return super.get(e).then(e => new hB(this._firestore,r,t._key,e._document,new hF(!1,!1),t.converter))
                }
            }
            function su(e, t, r) {
                e = nG(e, ha);
                let n = Object.assign(Object.assign({}, hH), r);
                if (n.maxAttempts < 1)
                    throw new sk(sD.INVALID_ARGUMENT,"Max attempts must be at least 1");
                return function(e, t, r) {
                    let n = new sN;
                    return e.asyncQueue.enqueueAndForget(async () => {
                        let i = await nF(e);
                        new u2(e.asyncQueue,i,r,t,n).Nu()
                    }
                    ),
                    n.promise
                }(n5(e), r => t(new hY(e,r)), n)
            }
            function sh() {
                return new hw("deleteField")
            }
            function sc() {
                return new hb("serverTimestamp")
            }
            function sd(...e) {
                return new hE("arrayUnion",e)
            }
            function sf(...e) {
                return new hI("arrayRemove",e)
            }
            function sp(e) {
                return new h_("increment",e)
            }
            function sg(e) {
                return new hf(e)
            }
            function sm(e) {
                return n5(e = nG(e, ha)),
                new hW(e,t => i7(e, t))
            }
            function sy(e, t) {
                let r = n5(e = nG(e, ha));
                if (!r._uninitializedComponentsProvider || "memory" === r._uninitializedComponentsProvider._offline.kind)
                    return w("Cannot enable indexes when persistence is disabled"),
                    Promise.resolve();
                let n = function(e) {
                    let t = "string" == typeof e ? function(e) {
                        try {
                            return JSON.parse(e)
                        } catch (e) {
                            throw new sk(sD.INVALID_ARGUMENT,"Failed to parse JSON: " + (null == e ? void 0 : e.message))
                        }
                    }(e) : e
                      , r = [];
                    if (Array.isArray(t.indexes))
                        for (let e of t.indexes) {
                            let t = sv(e, "collectionGroup")
                              , n = [];
                            if (Array.isArray(e.fields))
                                for (let t of e.fields) {
                                    let e = iI("setIndexConfiguration", sv(t, "fieldPath"));
                                    "CONTAINS" === t.arrayConfig ? n.push(new sY(e,2)) : "ASCENDING" === t.order ? n.push(new sY(e,0)) : "DESCENDING" === t.order && n.push(new sY(e,1))
                                }
                            r.push(new sJ(sJ.UNKNOWN_ID,t,n,sX.empty()))
                        }
                    return r
                }(t);
                return r.asyncQueue.enqueue(async () => (async function(e, t) {
                    let r = e.indexManager
                      , n = [];
                    return e.persistence.runTransaction("Configure indexes", "readwrite", e => r.getFieldIndexes(e).next(i => (function(e, t, r, n, i) {
                        t = [...t],
                        (e = [...e]).sort(r),
                        t.sort(r);
                        let s = e.length
                          , a = t.length
                          , o = 0
                          , l = 0;
                        for (; o < a && l < s; ) {
                            let s = r(e[l], t[o]);
                            s < 0 ? i(e[l++]) : s > 0 ? n(t[o++]) : (o++,
                            l++)
                        }
                        for (; o < a; )
                            n(t[o++]);
                        for (; l < s; )
                            i(e[l++])
                    }
                    )(i, t, O, t => {
                        n.push(r.addFieldIndex(e, t))
                    }
                    , t => {
                        n.push(r.deleteFieldIndex(e, t))
                    }
                    )).next( () => s2.waitFor(n)))
                }
                )(await nM(r), n))
            }
            function sv(e, t) {
                if ("string" != typeof e[t])
                    throw new sk(sD.INVALID_ARGUMENT,"Missing string value for: " + t);
                return e[t]
            }
            class hX {
                constructor(e) {
                    this._firestore = e,
                    this.type = "PersistentCacheIndexManager"
                }
            }
            function sw(e) {
                var t;
                e = nG(e, ha);
                let r = hZ.get(e);
                if (r)
                    return r;
                if ("persistent" !== (null == (t = n5(e)._uninitializedComponentsProvider) ? void 0 : t._offline.kind))
                    return null;
                let n = new hX(e);
                return hZ.set(e, n),
                n
            }
            function sb(e) {
                s_(e, !0)
            }
            function sE(e) {
                s_(e, !1)
            }
            function sI(e) {
                var t;
                (t = n5(e._firestore)).asyncQueue.enqueue(async () => (function(e) {
                    let t = e.indexManager;
                    return e.persistence.runTransaction("Delete All Indexes", "readwrite", e => t.deleteAllFieldIndexes(e))
                }
                )(await nM(t))).then(e => y("deleting all persistent cache indexes succeeded")).catch(e => w("deleting all persistent cache indexes failed", e))
            }
            function s_(e, t) {
                var r;
                (r = n5(e._firestore),
                r.asyncQueue.enqueue(async () => {
                    var e;
                    return e = await nM(r),
                    void (e.bs.Is = t)
                }
                )).then(e => y(`setting persistent cache index auto creation isEnabled=${t} succeeded`)).catch(e => w(`setting persistent cache index auto creation isEnabled=${t} failed`, e))
            }
            let hZ = new WeakMap;
            function sT(e) {
                var t;
                let r = null == (t = n5(nG(e.firestore, ha))._onlineComponents) ? void 0 : t.datastore.serializer;
                return void 0 === r ? null : tO(r, ej(e._query)).gt
            }
            function sS(e, t) {
                var r;
                let n = W(t, (e, t) => new o2(t,e.aggregateType,e._internalFieldPath))
                  , i = null == (r = n5(nG(e.firestore, ha))._onlineComponents) ? void 0 : r.datastore.serializer;
                return void 0 === i ? null : tR(i, ez(e._query), n, !0).request
            }
            class h0 {
                constructor() {
                    throw Error("instances of this class should not be created")
                }
                static onExistenceFilterMismatch(e) {
                    return h1.instance.onExistenceFilterMismatch(e)
                }
            }
            class h1 {
                constructor() {
                    this.Vc = new Map
                }
                static get instance() {
                    return h2 || function(e) {
                        if (o3)
                            throw Error("a TestingHooksSpi instance is already set");
                        o3 = e
                    }(h2 = new h1),
                    h2
                }
                ht(e) {
                    this.Vc.forEach(t => t(e))
                }
                onExistenceFilterMismatch(e) {
                    let t = Symbol()
                      , r = this.Vc;
                    return r.set(t, e),
                    () => r.delete(t)
                }
            }
            let h2 = null;
            !function(e, n=!0) {
                sx = u.SDK_VERSION,
                (0,
                u._registerComponent)(new h.Component("firestore", (e, {instanceIdentifier: t, options: r}) => {
                    let i = e.getProvider("app").getImmediate()
                      , s = new ha(new sP(e.getProvider("auth-internal")),new sV(i,e.getProvider("app-check-internal")),function(e, t) {
                        if (!Object.prototype.hasOwnProperty.apply(e.options, ["projectId"]))
                            throw new sk(sD.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');
                        return new oh(e.options.projectId,t)
                    }(i, t),i);
                    return r = Object.assign({
                        useFetchStreams: n
                    }, r),
                    s._setSettings(r),
                    s
                }
                ,"PUBLIC").setMultipleInstances(!0)),
                (0,
                u.registerVersion)(t, r, void 0),
                (0,
                u.registerVersion)(t, r, "esm2017")
            }()
        }
    }
    ,
    45300: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({}),
        e.i(51123)
    }
    ,
    29244: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        e.s({}),
        e.i(51123),
        e.i(45300)
    }
    ,
    56974: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                firestore: () => r
            }),
            e.i(62728);
            var n = e.i(94334);
            e.i(29244);
            var i = e.i(51123);
            let t = (0,
            n.initializeApp)({
                apiKey: "AIzaSyAIjZxc_LuE6mDb65QbxG2JbX0RrSfeaEg",
                authDomain: "agentsappx.firebaseapp.com",
                projectId: "agentsappx",
                storageBucket: "agentsappx.firebasestorage.app",
                messagingSenderId: "808762676458",
                appId: "1:808762676458:web:e10e346c7fa514acb33393",
                measurementId: "G-L0YEMXTKTP"
            })
              , r = (0,
            i.getFirestore)(t)
        }
    }
    ,
    39708: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                addUpdateBlogData: () => u,
                deleteBlogData: () => c,
                fetchBlogData: () => l,
                fetchBlogInfo: () => t,
                fetchInfo: () => r,
                updateContact: () => h,
                uploadFiles: () => d
            });
            var n = e.i(97434)
              , i = e.i(56974);
            e.i(29244);
            var s = e.i(51123)
              , a = e.i(6522)
              , o = e.i(888);
            let t = (e, t) => new Promise( (r, a) => {
                try {
                    let o = (0,
                    s.collection)(i.firestore, "blogs")
                      , l = (0,
                    s.collection)((0,
                    s.doc)(o, n.default.key), "blogs")
                      , u = (0,
                    s.query)(l, (0,
                    s.where)("slug", "==", t));
                    (0,
                    s.onSnapshot)(u, t => {
                        r(e(t.docs.map(e => ({
                            ...e.data(),
                            id: e.id,
                            _docRef: e
                        }))[0]))
                    }
                    , e => {
                        console.error("Error fetching blog data:", e),
                        a(e)
                    }
                    )
                } catch (e) {
                    console.error("Error in fetchBlogInfo:", e),
                    a({})
                }
            }
            )
              , r = e => new Promise(t => {
                let r = {
                    whatsapp_link: "",
                    phone: "",
                    telegram_link: "",
                    tiktok_link: "",
                    whatsapp_channel_link: ""
                }
                  , a = (0,
                s.collection)(i.firestore, "agent_contacts")
                  , o = (0,
                s.doc)(a, n.default.key);
                (0,
                s.onSnapshot)(o, n => {
                    n.exists() ? t(e(n.data())) : t(r)
                }
                )
            }
            )
              , l = (e, t, r) => new Promise(async (a, o) => {
                try {
                    let l = (0,
                    s.collection)(i.firestore, "blogs")
                      , u = (0,
                    s.collection)((0,
                    s.doc)(l, n.default.key), "blogs")
                      , h = (0,
                    s.query)(u, (0,
                    s.orderBy)("updatedAt", "desc"));
                    if (void 0 != t && void 0 == r)
                        h = (0,
                        s.query)(h, (0,
                        s.limit)(t));
                    else if ("object" == typeof r)
                        h = (0,
                        s.query)(h, (0,
                        s.startAfter)(r), (0,
                        s.limit)(3));
                    else if (void 0 != r) {
                        let e = (await (0,
                        s.getDocs)(h)).docs[r - 1];
                        if (!e)
                            return void console.log("No document found at the specified offset");
                        h = (0,
                        s.query)(h, (0,
                        s.startAfter)(e), (0,
                        s.limit)(4))
                    }
                    (0,
                    s.onSnapshot)(h, t => {
                        a(e(t.docs.map(e => ({
                            ...e.data(),
                            id: e.id,
                            _docRef: e
                        }))))
                    }
                    , e => {
                        console.error("Error fetching blog data:", e),
                        o(e)
                    }
                    )
                } catch (e) {
                    console.error("Error in fetchBlogData:", e),
                    o({})
                }
            }
            )
              , u = async (e, t) => {
                let r = (0,
                s.collection)(i.firestore, "blogs")
                  , l = (0,
                s.collection)((0,
                s.doc)(r, n.default.key), "blogs")
                  , u = (0,
                o.createSlug)(e.title);
                if (t) {
                    let r = (0,
                    s.doc)(l, t)
                      , n = a.default.omitBy(e, a.default.isUndefined);
                    return (0,
                    s.updateDoc)(r, {
                        ...n,
                        ...{
                            slug: u,
                            updatedAt: s.Timestamp.now()
                        }
                    }).then( () => {
                        window.alert("Blog has been updated successfully")
                    }
                    ).catch(e => {
                        window.alert(`Error adding blog: ${e}`)
                    }
                    )
                }
                return (0,
                s.addDoc)(l, {
                    ...e,
                    slug: u,
                    createdAt: s.Timestamp.now(),
                    updatedAt: s.Timestamp.now()
                }).then( () => {
                    window.alert("Blog added successfully")
                }
                ).catch(e => {
                    window.alert(`Error adding blog: ${e}`)
                }
                )
            }
              , h = e => {
                let t = (0,
                s.collection)(i.firestore, "agent_contacts");
                (0,
                s.setDoc)((0,
                s.doc)(t, n.default.key), {
                    ...a.default.omitBy(e, a.default.isUndefined),
                    ...{
                        updatedAt: s.Timestamp.now()
                    }
                }).then( () => {
                    alert("Contact updated successfully")
                }
                ).catch(e => {
                    alert(`Error submitting form: ${e}`)
                }
                )
            }
              , c = e => {
                let t = (0,
                s.collection)(i.firestore, "blogs")
                  , r = (0,
                s.collection)((0,
                s.doc)(t, n.default.key), "blogs")
                  , a = (0,
                s.doc)(r, e);
                (0,
                s.deleteDoc)(a).then( () => {
                    window.alert("Blog deleted successfully")
                }
                ).catch(e => {
                    window.alert(`Error deleting blog: ${e}`)
                }
                )
            }
              , d = e => new Promise( (t, r) => {
                try {
                    let a = e[0]
                      , l = new FormData;
                    l.append("file", a),
                    l.append("random_filename", "True"),
                    fetch(n.default.backend_upload_media, {
                        method: "POST",
                        body: l,
                        redirect: "follow"
                    }).then(async e => {
                        let a = await e.json()
                          , l = (0,
                        o.createSlug)(a?.name)
                          , u = (0,
                        s.collection)(i.firestore, "media")
                          , h = (0,
                        s.collection)((0,
                        s.doc)(u, n.default.key), "media")
                          , c = (0,
                        s.doc)(h, l);
                        (0,
                        s.setDoc)(c, {
                            slug: l,
                            reuploadAttempt: 1,
                            createdAt: s.Timestamp.now(),
                            media: JSON.parse(JSON.stringify({
                                ...a
                            })),
                            updatedAt: s.Timestamp.now()
                        }).then( () => {
                            t(a)
                        }
                        ).catch(e => {
                            r(e)
                        }
                        )
                    }
                    )
                } catch (e) {
                    r(e)
                }
            }
            )
        }
    }
    ,
    59808: e => {
        "use strict";
        var {g: t, __dirname: r} = e;
        {
            e.s({
                Client: () => t,
                featureBlogInt: () => c,
                useAgentInfo: () => g,
                useBlogInfo: () => p,
                useBlogs: () => f,
                useInfiniteBlog: () => d
            });
            var n = e.i(97434)
              , i = e.i(55583)
              , s = e.i(40791)
              , a = e.i(13674)
              , o = e.i(45643)
              , l = e.i(28662)
              , u = e.i(39747)
              , h = e.i(39708);
            let t = new s.QueryClient({
                defaultOptions: {
                    queries: {
                        staleTime: 1 / 0,
                        gcTime: 6048e5,
                        refetchOnWindowFocus: !0
                    }
                }
            })
              , r = (0,
            i.createSyncStoragePersister)({
                storage: window.sessionStorage
            });
            (0,
            u.persistQueryClient)({
                queryClient: t,
                persister: r,
                maxAge: 12096e5,
                buster: "app-persister",
                dehydrateOptions: {
                    shouldDehydrateQuery: e => "cookies" === e.queryKey[0]
                }
            });
            let c = 6
              , d = () => {
                let e = ["infinite_blogs", n.default.key, `offset:${c}`];
                return (0,
                a.useInfiniteQuery)({
                    queryKey: e,
                    queryFn: async ({pageParam: e}) => await (0,
                    h.fetchBlogData)(e => e, void 0, e),
                    initialPageParam: c,
                    getNextPageParam: e => {
                        if (!e?.length)
                            return;
                        let t = e[e.length - 1];
                        return t?._docRef
                    }
                })
            }
              , f = e => {
                let t = ["blogs", n.default.key, `limit:${e}`]
                  , r = (0,
                l.useQueryClient)()
                  , i = e => (r.setQueryData(t, e),
                e);
                return (0,
                o.useQuery)({
                    queryKey: t,
                    queryFn: () => (0,
                    h.fetchBlogData)(i, e),
                    staleTime: 1 / 0,
                    refetchOnWindowFocus: !0,
                    refetchOnMount: !0,
                    refetchInterval: !1,
                    retry: e => !(e >= 2)
                })
            }
              , p = e => {
                let t = ["blog", n.default.key, `slug:${e}`]
                  , r = (0,
                l.useQueryClient)()
                  , i = e => (r.setQueryData(t, e),
                e);
                return (0,
                o.useQuery)({
                    queryKey: t,
                    queryFn: () => (0,
                    h.fetchBlogInfo)(i, e),
                    staleTime: 1 / 0,
                    refetchOnWindowFocus: !0,
                    refetchOnMount: !0,
                    refetchInterval: !1,
                    retry: e => !(e >= 2)
                })
            }
              , g = () => {
                let e = ["agent_info", n.default.key]
                  , t = (0,
                l.useQueryClient)()
                  , r = r => (t.setQueryData(e, r),
                r);
                return (0,
                o.useQuery)({
                    queryKey: e,
                    queryFn: () => (0,
                    h.fetchInfo)(r),
                    staleTime: 1 / 0,
                    refetchOnWindowFocus: !0,
                    refetchOnMount: !0,
                    refetchInterval: !1,
                    retry: e => !(e >= 2)
                })
            }
        }
    }
}]);

//# sourceMappingURL=db95517296f5b1e8.js.map
